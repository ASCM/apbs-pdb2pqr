<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>APBS: /data/work/source/apbs/src/mg/vpmg.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">APBS
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('vpmg_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">/data/work/source/apbs/src/mg/vpmg.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="vpmg_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00073"></a>00073 <span class="preprocessor">#include &quot;<a class="code" href="vpmg_8h.html" title="Contains declarations for class Vpmg.">vpmg.h</a>&quot;</span>
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <a class="code" href="group___vhal.html#ga4b89a5a26de68481d070f76427db33c6" title="Allows embedding of RCS ID tags in object files.">VEMBED</a>(rcsid=<span class="stringliteral">&quot;$Id$&quot;</span>)
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="preprocessor">#if !defined(VINLINE_VPMG)</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a><a class="code" href="group___vpmg.html#gaf893d577d803f14357cc0dce3c5d364e">00079</a> VPUBLIC <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#gaf893d577d803f14357cc0dce3c5d364e" title="Return the memory used by this structure (and its contents) in bytes.">Vpmg_memChk</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l00080"></a>00080     <span class="keywordflow">if</span> (thee == VNULL) <span class="keywordflow">return</span> 0;
<a name="l00081"></a>00081     <span class="keywordflow">return</span> Vmem_bytes(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>);
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="preprocessor">#endif </span><span class="comment">/* if !defined(VINLINE_VPMG) */</span>
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 
<a name="l00087"></a><a class="code" href="group___vpmg.html#gafd544ba4fe172d3f942016cf74e7a31e">00087</a> VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gafd544ba4fe172d3f942016cf74e7a31e" title="Print out a column-compressed sparse matrix in Harwell-Boeing format.">Vpmg_printColComp</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">char</span> path[72], <span class="keywordtype">char</span> title[72],
<a name="l00088"></a>00088   <span class="keywordtype">char</span> mxtype[3], <span class="keywordtype">int</span> flag) {
<a name="l00089"></a>00089 
<a name="l00090"></a>00090     <span class="keywordtype">int</span> nn, nxm2, nym2, nzm2, ncol, nrow, nonz;
<a name="l00091"></a>00091     <span class="keywordtype">double</span> *nzval;
<a name="l00092"></a>00092     <span class="keywordtype">int</span> *colptr, *rowind;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094     <span class="comment">/* Calculate the total number of unknowns */</span>
<a name="l00095"></a>00095     nxm2 = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a> - 2;
<a name="l00096"></a>00096     nym2 = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a> - 2;
<a name="l00097"></a>00097     nzm2 = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a> - 2;
<a name="l00098"></a>00098     nn = nxm2*nym2*nzm2;
<a name="l00099"></a>00099     ncol = nn;
<a name="l00100"></a>00100     nrow = nn;
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     <span class="comment">/* Calculate the number of non-zero matrix entries:</span>
<a name="l00103"></a>00103 <span class="comment">     *    nn       nonzeros on diagonal</span>
<a name="l00104"></a>00104 <span class="comment">     *    nn-1     nonzeros on first off-diagonal</span>
<a name="l00105"></a>00105 <span class="comment">     *    nn-nx    nonzeros on second off-diagonal</span>
<a name="l00106"></a>00106 <span class="comment">     *    nn-nx*ny nonzeros on third off-diagonal</span>
<a name="l00107"></a>00107 <span class="comment">     *</span>
<a name="l00108"></a>00108 <span class="comment">     *    7*nn-2*nx*ny-2*nx-2 TOTAL non-zeros</span>
<a name="l00109"></a>00109 <span class="comment">     */</span>
<a name="l00110"></a>00110     nonz = 7*nn - 2*nxm2*nym2 - 2*nxm2 - 2;
<a name="l00111"></a>00111     nzval  = (<span class="keywordtype">double</span>*)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, nonz, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00112"></a>00112     rowind = (<span class="keywordtype">int</span>*)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, nonz, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00113"></a>00113     colptr = (<span class="keywordtype">int</span>*)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, (ncol+1), <span class="keyword">sizeof</span>(int));
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="preprocessor">#ifndef VAPBSQUIET</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>    Vnm_print(1, <span class="stringliteral">&quot;Vpmg_printColComp:  Allocated space for %d nonzeros\n&quot;</span>,
<a name="l00117"></a>00117       nonz);
<a name="l00118"></a>00118 <span class="preprocessor">#endif</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>
<a name="l00120"></a>00120     <a class="code" href="group___vpmg.html#ga60b35ab9ae779ffa7329589f64a4111e" title="Build a column-compressed matrix in Harwell-Boeing format.">bcolcomp</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a40be00c9f8e1a7974391a6e6bf3461b0">iparm</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>, thee-&gt;<a class="code" href="structs_vpmg.html#ac0908d30703d6255e301caef5a20c7c8">iwork</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a1ac4dfbbeb3bd0680998c80dee6e8e6a">rwork</a>,
<a name="l00121"></a>00121       nzval, rowind, colptr, &amp;flag);
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="preprocessor">#if 0</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i=0; i&lt;nn; i++) {
<a name="l00126"></a>00126         Vnm_print(1, <span class="stringliteral">&quot;nnz(%d) = %g\n&quot;</span>, i, nzval[i]);
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128 <span class="preprocessor">#endif</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>
<a name="l00130"></a>00130     <span class="comment">/* I do not understand why I need to pass nzval in this way, but it</span>
<a name="l00131"></a>00131 <span class="comment">     * works... */</span>
<a name="l00132"></a>00132     <a class="code" href="group___vpmg.html#ga08fc3acae8bd36d0ff7c463f3d68988f" title="Print a column-compressed matrix in Harwell-Boeing format.">pcolcomp</a>(&amp;nrow, &amp;ncol, &amp;nonz, &amp;(nzval[0]), rowind, colptr, path, title,
<a name="l00133"></a>00133       mxtype);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, (ncol+1), <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), (<span class="keywordtype">void</span> **)&amp;colptr);
<a name="l00136"></a>00136     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, nonz, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), (<span class="keywordtype">void</span> **)&amp;rowind);
<a name="l00137"></a>00137     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, nonz, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>), (<span class="keywordtype">void</span> **)&amp;nzval);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a><a class="code" href="group___vpmg.html#ga7e280e4beb3cd7dc7ddcf7dda904f481">00141</a> VPUBLIC <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a>* <a class="code" href="group___vpmg.html#ga7e280e4beb3cd7dc7ddcf7dda904f481" title="Constructor for the Vpmg class (allocates new memory)">Vpmg_ctor</a>(<a class="code" href="structs_vpmgp.html" title="Contains public data members for Vpmgp class/module.">Vpmgp</a> *pmgp, <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>, <span class="keywordtype">int</span> focusFlag,
<a name="l00142"></a>00142         <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *pmgOLD, <a class="code" href="structs_m_gparm.html" title="Parameter structure for MG-specific variables from input files.">MGparm</a> *mgparm, <a class="code" href="group___p_b_eparm.html#ga8cc295f42b2029944d85402f93190603" title="Define ePBEparm_calcEnergy enumeration as PBEparm_calcEnergy.">PBEparm_calcEnergy</a> energyFlag) {
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee = VNULL;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     thee = (<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a>*)Vmem_malloc(VNULL, 1, <span class="keyword">sizeof</span>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a>) );
<a name="l00147"></a>00147     VASSERT(thee != VNULL);
<a name="l00148"></a>00148     VASSERT( <a class="code" href="group___vpmg.html#ga44b9a21b48776d5d308a2de3c658f6a7" title="FORTRAN stub constructor for the Vpmg class (uses previously-allocated memory)">Vpmg_ctor2</a>(thee, pmgp, pbe, focusFlag, pmgOLD, mgparm,
<a name="l00149"></a>00149                 energyFlag) );
<a name="l00150"></a>00150     <span class="keywordflow">return</span> thee;
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 
<a name="l00153"></a><a class="code" href="group___vpmg.html#ga44b9a21b48776d5d308a2de3c658f6a7">00153</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#ga44b9a21b48776d5d308a2de3c658f6a7" title="FORTRAN stub constructor for the Vpmg class (uses previously-allocated memory)">Vpmg_ctor2</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vpmgp.html" title="Contains public data members for Vpmgp class/module.">Vpmgp</a> *pmgp, <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>, <span class="keywordtype">int</span> focusFlag,
<a name="l00154"></a>00154                        <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *pmgOLD, <a class="code" href="structs_m_gparm.html" title="Parameter structure for MG-specific variables from input files.">MGparm</a> *mgparm, <a class="code" href="group___p_b_eparm.html#ga8cc295f42b2029944d85402f93190603" title="Define ePBEparm_calcEnergy enumeration as PBEparm_calcEnergy.">PBEparm_calcEnergy</a> energyFlag) {
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     <span class="keywordtype">int</span> i, j, nion;
<a name="l00157"></a>00157     <span class="keywordtype">double</span> ionConc[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>], ionQ[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>], ionRadii[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>], zkappa2, zks2;
<a name="l00158"></a>00158     <span class="keywordtype">double</span> ionstr, partMin[3], partMax[3];
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="comment">/* Get the parameters */</span>
<a name="l00161"></a>00161     VASSERT(pmgp != VNULL);
<a name="l00162"></a>00162     VASSERT(pbe != VNULL);
<a name="l00163"></a>00163     thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a> = pmgp;
<a name="l00164"></a>00164     thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a> = <a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     <span class="comment">/* Set up the memory */</span>
<a name="l00167"></a>00167     thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a> = Vmem_ctor(<span class="stringliteral">&quot;APBS:VPMG&quot;</span>);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 
<a name="l00172"></a>00172     <span class="comment">/* Initialize ion concentrations and valencies in PMG routines */</span>
<a name="l00173"></a>00173     zkappa2 = <a class="code" href="group___vpbe.html#ga56e38face81d2d29659541b5e3f5e442" title="Get modified squared Debye-Huckel parameter.">Vpbe_getZkappa2</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l00174"></a>00174     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l00175"></a>00175     <span class="keywordflow">if</span> (ionstr &gt; 0.0) zks2 = 0.5/ionstr;
<a name="l00176"></a>00176     <span class="keywordflow">else</span> zks2 = 0.0;
<a name="l00177"></a>00177     <a class="code" href="group___vpbe.html#gae42c09bef7405779d87bce73c44e1ebf" title="Get information about the counterion species present.">Vpbe_getIons</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>, &amp;nion, ionConc, ionRadii, ionQ);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179     <span class="comment">/* TEMPORARY USEAQUA */</span>
<a name="l00180"></a>00180         <span class="comment">/* Calculate storage requirements */</span>
<a name="l00181"></a>00181     <span class="keywordflow">if</span>(mgparm-&gt;<a class="code" href="structs_m_gparm.html#a92fda61574f2e4d114e339f25924d9f2">useAqua</a> == 0){
<a name="l00182"></a>00182             <a class="code" href="group___vpmgp.html#gadb713e70f5724ce0f63ec4cf380278d7" title="Determine array sizes and parameters for multigrid solver.">Vpmgp_size</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>);
<a name="l00183"></a>00183     }<span class="keywordflow">else</span>{
<a name="l00184"></a>00184         VABORT_MSG0(<span class="stringliteral">&quot;Aqua is currently disabled&quot;</span>);
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="comment">/* We need some additional storage if: nonlinear &amp; newton OR cgmg */</span>
<a name="l00188"></a>00188     <span class="comment">/* SMPBE Added - nonlin = 2 added since it mimics NPBE */</span>
<a name="l00189"></a>00189     <span class="keywordflow">if</span> ( ( ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a> == NONLIN_NPBE) || (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a> == NONLIN_SMPBE))
<a name="l00190"></a>00190            &amp;&amp; (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac09242118a756eb1fde8d14b132c27ec">meth</a> == VSOL_Newton) ) || (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac09242118a756eb1fde8d14b132c27ec">meth</a> == VSOL_CGMG) )
<a name="l00191"></a>00191     {
<a name="l00192"></a>00192         thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a98e54f761e0cd85460831d47407001b2">nrwk</a> += (2*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aad2c7f0437a34192dce5896d84b6a786">nf</a>));
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1) {
<a name="l00197"></a>00197             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ctor2:  PMG chose nx = %d, ny = %d, nz = %d\n&quot;</span>,
<a name="l00198"></a>00198                             thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>);
<a name="l00199"></a>00199             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ctor2:  PMG chose nlev = %d\n&quot;</span>,
<a name="l00200"></a>00200                             thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aec6d6d38e34f56c5324575331323d141">nlev</a>);
<a name="l00201"></a>00201             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ctor2:  PMG chose nxc = %d, nyc = %d, nzc = %d\n&quot;</span>,
<a name="l00202"></a>00202                             thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a21349d7c9930586f6deea38f47147c9a">nxc</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afbcb3d7b6862cafe613d0f474867a59d">nyc</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1788f2d118407ebe6d2957c9d46f7e31">nzc</a>);
<a name="l00203"></a>00203             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ctor2:  PMG chose nf = %d, nc = %d\n&quot;</span>,
<a name="l00204"></a>00204                             thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aad2c7f0437a34192dce5896d84b6a786">nf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a2e6c8f821f88e1dab510dc11a7824721">nc</a>);
<a name="l00205"></a>00205             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ctor2:  PMG chose narr = %d, narrc = %d\n&quot;</span>,
<a name="l00206"></a>00206                             thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a534b6fb7418cb526326a4a57cf1cc36f">narrc</a>);
<a name="l00207"></a>00207             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ctor2:  PMG chose n_rpc = %d, n_iz = %d, n_ipc = %d\n&quot;</span>,
<a name="l00208"></a>00208                             thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a99a071f56e5d7e5f398e6a7810418e80">n_rpc</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae92f00e47d2c7d818662939a06b2b472">n_iz</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a3fee434cb99e7cc4a1a1a9c5b82715f7">n_ipc</a>);
<a name="l00209"></a>00209             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ctor2:  PMG chose nrwk = %d, niwk = %d\n&quot;</span>,
<a name="l00210"></a>00210                             thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a98e54f761e0cd85460831d47407001b2">nrwk</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad5d46810a61a64f1ce15e001ba347b8d">niwk</a>);
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     <span class="comment">/* Allocate boundary storage */</span>
<a name="l00216"></a>00216     thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a> = (<span class="keywordtype">double</span> *)Vmem_malloc(
<a name="l00217"></a>00217         thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,
<a name="l00218"></a>00218         10*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>),
<a name="l00219"></a>00219         <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)
<a name="l00220"></a>00220         );
<a name="l00221"></a>00221 
<a name="l00222"></a>00222     thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a> = (<span class="keywordtype">double</span> *)Vmem_malloc(
<a name="l00223"></a>00223         thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,
<a name="l00224"></a>00224         10*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>),
<a name="l00225"></a>00225         <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)
<a name="l00226"></a>00226         );
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a> = (<span class="keywordtype">double</span> *)Vmem_malloc(
<a name="l00229"></a>00229         thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,
<a name="l00230"></a>00230         10*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>),
<a name="l00231"></a>00231         <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)
<a name="l00232"></a>00232         );
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <span class="comment">/* Warn users if they are using BCFL_MAP that</span>
<a name="l00237"></a>00237 <span class="comment">       we do not include external energies */</span>
<a name="l00238"></a>00238     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> == <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)
<a name="l00239"></a>00239         Vnm_print(2,<span class="stringliteral">&quot;Vpmg_ctor2: \nWarning: External energies are not used in BCFL_MAP calculations!\n&quot;</span>);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <span class="keywordflow">if</span> (focusFlag) {
<a name="l00242"></a>00242 
<a name="l00243"></a>00243         <span class="comment">/* Overwrite any default or user-specified boundary condition</span>
<a name="l00244"></a>00244 <span class="comment">        * arguments; we are now committed to a calculation via focusing */</span>
<a name="l00245"></a>00245         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) {
<a name="l00246"></a>00246             Vnm_print(2,
<a name="l00247"></a>00247                       <span class="stringliteral">&quot;Vpmg_ctor2: reset boundary condition flag to BCFL_FOCUS!\n&quot;</span>);
<a name="l00248"></a>00248             thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> = <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>;
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251         <span class="comment">/* Fill boundaries */</span>
<a name="l00252"></a>00252         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_ctor2:  Filling boundary with old solution!\n&quot;</span>);
<a name="l00253"></a>00253         focusFillBound(thee, pmgOLD);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         <span class="comment">/* Calculate energetic contributions from region outside focusing</span>
<a name="l00256"></a>00256 <span class="comment">            * domain */</span>
<a name="l00257"></a>00257         <span class="keywordflow">if</span> (energyFlag != <a class="code" href="group___p_b_eparm.html#gga42fe5940fc6e4b56a0d6da1c8c823d5cab1d3606138a36b1a9746ad9ce20f87d3">PCE_NO</a>) {
<a name="l00258"></a>00258 
<a name="l00259"></a>00259             <span class="keywordflow">if</span> (mgparm-&gt;<a class="code" href="structs_m_gparm.html#a68597b6cd91f0473d21c41ac8443224e">type</a> == <a class="code" href="group___m_gparm.html#ggabaf271dcb16eb54b794cf2d5ffb7383aa002e1684dcccbd89ab59917d0e10eaf2">MCT_PARALLEL</a>) {
<a name="l00260"></a>00260 
<a name="l00261"></a>00261                 <span class="keywordflow">for</span> (j=0; j&lt;3; j++) {
<a name="l00262"></a>00262                     partMin[j] = mgparm-&gt;<a class="code" href="structs_m_gparm.html#ae15169546754b982ad7a29a96631832b">partDisjCenter</a>[j]
<a name="l00263"></a>00263                     - 0.5*mgparm-&gt;<a class="code" href="structs_m_gparm.html#a28140358014572680cdef134640b090d">partDisjLength</a>[j];
<a name="l00264"></a>00264                     partMax[j] = mgparm-&gt;<a class="code" href="structs_m_gparm.html#ae15169546754b982ad7a29a96631832b">partDisjCenter</a>[j]
<a name="l00265"></a>00265                         + 0.5*mgparm-&gt;<a class="code" href="structs_m_gparm.html#a28140358014572680cdef134640b090d">partDisjLength</a>[j];
<a name="l00266"></a>00266                 }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268             } <span class="keywordflow">else</span> {
<a name="l00269"></a>00269                 <span class="keywordflow">for</span> (j=0; j&lt;3; j++) {
<a name="l00270"></a>00270                     partMin[j] = mgparm-&gt;<a class="code" href="structs_m_gparm.html#a9da2c4f10aed3a86628aad3dd87c9d6a">center</a>[j] - 0.5*mgparm-&gt;<a class="code" href="structs_m_gparm.html#a21e3a7ca2cf5d13fec660614a9c9d653">glen</a>[j];
<a name="l00271"></a>00271                     partMax[j] = mgparm-&gt;<a class="code" href="structs_m_gparm.html#a9da2c4f10aed3a86628aad3dd87c9d6a">center</a>[j] + 0.5*mgparm-&gt;<a class="code" href="structs_m_gparm.html#a21e3a7ca2cf5d13fec660614a9c9d653">glen</a>[j];
<a name="l00272"></a>00272                 }
<a name="l00273"></a>00273             }
<a name="l00274"></a>00274             extEnergy(thee, pmgOLD, energyFlag, partMin, partMax,
<a name="l00275"></a>00275                       mgparm-&gt;<a class="code" href="structs_m_gparm.html#a17b58f93a2e7a415095f3b664c490df8">partDisjOwnSide</a>);
<a name="l00276"></a>00276         }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     } <span class="keywordflow">else</span> {
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         <span class="comment">/* Ignore external energy contributions */</span>
<a name="l00281"></a>00281         thee-&gt;<a class="code" href="structs_vpmg.html#ab19b8dec8f40e3ceacb5d8f864c5dd3a">extQmEnergy</a> = 0;
<a name="l00282"></a>00282         thee-&gt;<a class="code" href="structs_vpmg.html#a76aee83486bc3b4a9f6352668d25d463">extDiEnergy</a> = 0;
<a name="l00283"></a>00283         thee-&gt;<a class="code" href="structs_vpmg.html#aefba7183c581d5dd81a716f5c65687dd">extQfEnergy</a> = 0;
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="comment">/* Allocate partition vector storage */</span>
<a name="l00287"></a>00287     thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a> = (<span class="keywordtype">double</span> *)Vmem_malloc(
<a name="l00288"></a>00288         thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,
<a name="l00289"></a>00289         (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>),
<a name="l00290"></a>00290         <span class="keyword">sizeof</span>(double)
<a name="l00291"></a>00291         );
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <span class="comment">/* Allocate remaining storage */</span>
<a name="l00294"></a>00294     thee-&gt;<a class="code" href="structs_vpmg.html#a40be00c9f8e1a7974391a6e6bf3461b0">iparm</a>  = (   <span class="keywordtype">int</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,                100, <span class="keyword">sizeof</span>(   <span class="keywordtype">int</span>));
<a name="l00295"></a>00295     thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>  = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,                100, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00296"></a>00296     thee-&gt;<a class="code" href="structs_vpmg.html#ac0908d30703d6255e301caef5a20c7c8">iwork</a>  = (   <span class="keywordtype">int</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad5d46810a61a64f1ce15e001ba347b8d">niwk</a>, <span class="keyword">sizeof</span>(   <span class="keywordtype">int</span>));
<a name="l00297"></a>00297     thee-&gt;<a class="code" href="structs_vpmg.html#a1ac4dfbbeb3bd0680998c80dee6e8e6a">rwork</a>  = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a98e54f761e0cd85460831d47407001b2">nrwk</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00298"></a>00298     thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a> = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00299"></a>00299     thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>  = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00300"></a>00300     thee-&gt;<a class="code" href="structs_vpmg.html#a34ec3c42c48d141ec30c8d2195722e11">pot</a>    = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00301"></a>00301     thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>   = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00302"></a>00302     thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>   = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00303"></a>00303     thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>   = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00304"></a>00304     thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>   = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00305"></a>00305     thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>   = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00306"></a>00306     thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>   = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00307"></a>00307     thee-&gt;<a class="code" href="structs_vpmg.html#af1686768f19068d072c38c028b651a4d">ccf</a>    = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00308"></a>00308     thee-&gt;<a class="code" href="structs_vpmg.html#a52279f4736f2cd888d764c049517a68b">fcf</a>    = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00309"></a>00309     thee-&gt;<a class="code" href="structs_vpmg.html#a4340bbd780d87a004aa32f56db41e63c">tcf</a>    = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00310"></a>00310     thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>      = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,   thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00311"></a>00311     thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>     = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 5*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>), <span class="keyword">sizeof</span>(double));
<a name="l00312"></a>00312     thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>     = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 5*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>), <span class="keyword">sizeof</span>(double));
<a name="l00313"></a>00313     thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>     = (<span class="keywordtype">double</span> *)Vmem_malloc(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 5*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>), <span class="keyword">sizeof</span>(double));
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 
<a name="l00317"></a>00317     <span class="comment">/* Packs parameters into the iparm and rparm arrays */</span>
<a name="l00318"></a>00318     <a class="code" href="group___vpmg.html#ga5aa26cf409548947ad0e1315e912bf90" title="Print out a column-compressed sparse matrix in Harwell-Boeing format.">Vpackmg</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a40be00c9f8e1a7974391a6e6bf3461b0">iparm</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>, &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a98e54f761e0cd85460831d47407001b2">nrwk</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad5d46810a61a64f1ce15e001ba347b8d">niwk</a>),
<a name="l00319"></a>00319             &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>),
<a name="l00320"></a>00320             &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aec6d6d38e34f56c5324575331323d141">nlev</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0bfef855e0e6daab86bb2647506da74c">nu1</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aff633121d381a9c3ad0e21d51d797a26">nu2</a>),
<a name="l00321"></a>00321             &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af97ed4881b05725f594da740e63303de">mgkey</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac8da2a7f67eddd46d6b08817471e3063">itmax</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#abb1062d08fbab63f575813d12c33b327">istop</a>),
<a name="l00322"></a>00322             &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aa6be27a1536423deddc3c89f891ac32f">ipcon</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae401b48b3e5aec3f7d12ebae96293de5">mgsmoo</a>),
<a name="l00323"></a>00323             &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f7948361733b4f5bcbc7783b018c6f8">mgprol</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af44829cd2374ff0df22f6e0b84cc5d15">mgcoar</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9e1c61ef69ce2cfd1b158fa298c94f0a">mgsolv</a>),
<a name="l00324"></a>00324             &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a4895390586968668002e176b0883f6a9">mgdisc</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac05afb7d877c01697396253aa6d47cb2">errtol</a>),
<a name="l00325"></a>00325             &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a3f1bcd3a128e97bf445ce23fa55305e5">ipkey</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a2736fa2de0b4fea98f5c30704541fa41">omegal</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab609e27ec6bf3820ef72c189027afec1">omegan</a>),
<a name="l00326"></a>00326             &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a698d522da0b3f6f582f83c079dc2d65d">irite</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0452f1983970e26d358a30f598f2b2b2">iperf</a>));
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     <span class="comment">/* Currently for SMPBE type calculations we do not want to apply a scale</span>
<a name="l00331"></a>00331 <span class="comment">        factor to the ionConc */</span>
<a name="l00338"></a>00338     <span class="keywordflow">switch</span>(pmgp-&gt;<a class="code" href="structs_vpmgp.html#a3f1bcd3a128e97bf445ce23fa55305e5">ipkey</a>){
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#ggad16654551e609cdf34580c7722164d21a9cf856b3b07d357f63e8be09adc71a01">IPKEY_SMPBE</a>:
<a name="l00341"></a>00341 
<a name="l00342"></a>00342                         <a class="code" href="group___p_m_g_c.html#gac56d2f62a96de22f3daac68f9a91cdd4" title="Set up the ionic species to be used in later calculations. This must be called before any other of th...">Vmypdefinitsmpbe</a>(&amp;nion, ionQ, ionConc, &amp;pbe-&gt;<a class="code" href="structs_vpbe.html#aed52321725281a48a9a52440363f3f68">smvolume</a>, &amp;pbe-&gt;<a class="code" href="structs_vpbe.html#a0329f3338754e5a8dd3ae0b556670c5f">smsize</a>);
<a name="l00343"></a>00343             <span class="keywordflow">break</span>;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#ggad16654551e609cdf34580c7722164d21a59d9662a52d0c0862fffdfbc722a5eb0">IPKEY_NPBE</a>:
<a name="l00348"></a>00348 
<a name="l00349"></a>00349             <span class="comment">/* Else adjust the inoConc by scaling factor zks2 */</span>
<a name="l00350"></a>00350             <span class="keywordflow">for</span> (i=0; i&lt;nion; i++)
<a name="l00351"></a>00351                 ionConc[i] = zks2 * ionConc[i];
<a name="l00352"></a>00352 
<a name="l00353"></a>00353                         <a class="code" href="group___p_m_g_c.html#ga066ca8c224e32501a389bdb7ee96c742" title="Set up the ionic species to be used in later calculations. This must be called before any other of th...">Vmypdefinitnpbe</a>(&amp;nion, ionQ, ionConc);
<a name="l00354"></a>00354             <span class="keywordflow">break</span>;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#ggad16654551e609cdf34580c7722164d21a53245a979a96e2dc914a75f135104a62">IPKEY_LPBE</a>:
<a name="l00359"></a>00359 
<a name="l00360"></a>00360             <span class="comment">/* Else adjust the inoConc by scaling factor zks2 */</span>
<a name="l00361"></a>00361             <span class="keywordflow">for</span> (i=0; i&lt;nion; i++)
<a name="l00362"></a>00362                             ionConc[i] = zks2 * ionConc[i];
<a name="l00363"></a>00363 
<a name="l00364"></a>00364             <a class="code" href="group___p_m_g_c.html#ga1c839153d47de1cf0642f9371847bb37" title="Set up the ionic species to be used in later calculations. This must be called before any other of th...">Vmypdefinitlpbe</a>(&amp;nion, ionQ, ionConc);
<a name="l00365"></a>00365             <span class="keywordflow">break</span>;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         <span class="keywordflow">default</span>:
<a name="l00370"></a>00370             Vnm_print(2, <span class="stringliteral">&quot;PMG: Warning: PBE structure not initialized!\n&quot;</span>);
<a name="l00371"></a>00371             <span class="comment">/* Else adjust the inoConc by scaling factor zks2 */</span>
<a name="l00372"></a>00372             <span class="keywordflow">for</span> (i=0; i&lt;nion; i++)
<a name="l00373"></a>00373                 ionConc[i] = zks2 * ionConc[i];
<a name="l00374"></a>00374             <span class="keywordflow">break</span>;
<a name="l00375"></a>00375     }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377     <span class="comment">/* Set the default chargeSrc for 5th order splines */</span>
<a name="l00378"></a>00378     thee-&gt;<a class="code" href="structs_vpmg.html#a311ed24e465040d2095273159d497995">chargeSrc</a> = mgparm-&gt;<a class="code" href="structs_m_gparm.html#a204c2d3f20f3f710f479d0548e729f58">chgs</a>;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     <span class="comment">/* Turn off restriction of observable calculations to a specific</span>
<a name="l00381"></a>00381 <span class="comment">    * partition */</span>
<a name="l00382"></a>00382     <a class="code" href="group___vpmg.html#gafc90a96505e0bddd5cc15b69f3c7613c" title="Remove partition restrictions.">Vpmg_unsetPart</a>(thee);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384     <span class="comment">/* The coefficient arrays have not been filled */</span>
<a name="l00385"></a>00385     thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a> = 0;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     <span class="comment">/*</span>
<a name="l00389"></a>00389 <span class="comment">     * TODO: Move the dtor out of here. The current ctor is done in routines.c,</span>
<a name="l00390"></a>00390 <span class="comment">     *       This was originally moved out to kill a memory leak. The dtor has</span>
<a name="l00391"></a>00391 <span class="comment">     *       has been removed from initMG and placed back here to keep memory</span>
<a name="l00392"></a>00392 <span class="comment">     *       usage low. killMG has been modified accordingly.</span>
<a name="l00393"></a>00393 <span class="comment">     */</span>
<a name="l00394"></a>00394     <a class="code" href="group___vpmg.html#ga1c87698f1d365aa7677f6b3ff64c9e8d" title="Object destructor.">Vpmg_dtor</a>(&amp;pmgOLD);
<a name="l00395"></a>00395 
<a name="l00396"></a>00396     <span class="keywordflow">return</span> 1;
<a name="l00397"></a>00397 }
<a name="l00398"></a>00398 
<a name="l00399"></a><a class="code" href="group___vpmg.html#ga86a44c6ef4ada350900ef88e87428082">00399</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#ga86a44c6ef4ada350900ef88e87428082" title="Solve the PBE using PMG.">Vpmg_solve</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <span class="keywordtype">int</span> i,
<a name="l00402"></a>00402         nx,
<a name="l00403"></a>00403         ny,
<a name="l00404"></a>00404         nz,
<a name="l00405"></a>00405         n;
<a name="l00406"></a>00406     <span class="keywordtype">double</span> zkappa2;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l00409"></a>00409     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l00410"></a>00410     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l00411"></a>00411     n = nx*ny*nz;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413     <span class="keywordflow">if</span> (!(thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>)) {
<a name="l00414"></a>00414         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_solve:  Need to call Vpmg_fillco()!\n&quot;</span>);
<a name="l00415"></a>00415         <span class="keywordflow">return</span> 0;
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418     <span class="comment">/* Fill the &quot;true solution&quot; array */</span>
<a name="l00419"></a>00419     <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
<a name="l00420"></a>00420         thee-&gt;<a class="code" href="structs_vpmg.html#a4340bbd780d87a004aa32f56db41e63c">tcf</a>[i] = 0.0;
<a name="l00421"></a>00421     }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="comment">/* Fill the RHS array */</span>
<a name="l00424"></a>00424     <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
<a name="l00425"></a>00425         thee-&gt;<a class="code" href="structs_vpmg.html#a52279f4736f2cd888d764c049517a68b">fcf</a>[i] = thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[i];
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="comment">/* Fill the operator coefficient array. */</span>
<a name="l00429"></a>00429     <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
<a name="l00430"></a>00430         thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[i] = thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i];
<a name="l00431"></a>00431         thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[i] = thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i];
<a name="l00432"></a>00432         thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[i] = thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i];
<a name="l00433"></a>00433     }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     <span class="comment">/* Fill the nonlinear coefficient array by multiplying the kappa</span>
<a name="l00436"></a>00436 <span class="comment">     * accessibility array (containing values between 0 and 1) by zkappa2. */</span>
<a name="l00437"></a>00437     zkappa2 = <a class="code" href="group___vpbe.html#ga56e38face81d2d29659541b5e3f5e442" title="Get modified squared Debye-Huckel parameter.">Vpbe_getZkappa2</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l00438"></a>00438     <span class="keywordflow">if</span> (zkappa2 &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l00439"></a>00439         <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
<a name="l00440"></a>00440             thee-&gt;<a class="code" href="structs_vpmg.html#af1686768f19068d072c38c028b651a4d">ccf</a>[i] = zkappa2*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i];
<a name="l00441"></a>00441         }
<a name="l00442"></a>00442     } <span class="keywordflow">else</span> {
<a name="l00443"></a>00443         <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
<a name="l00444"></a>00444             thee-&gt;<a class="code" href="structs_vpmg.html#af1686768f19068d072c38c028b651a4d">ccf</a>[i] = 0.0;
<a name="l00445"></a>00445         }
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="keywordflow">switch</span>(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac09242118a756eb1fde8d14b132c27ec">meth</a>) {
<a name="l00449"></a>00449         <span class="comment">/* CGMG (linear) */</span>
<a name="l00450"></a>00450         <span class="keywordflow">case</span> VSOL_CGMG:
<a name="l00451"></a>00451 
<a name="l00452"></a>00452             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00453"></a>00453                 Vnm_print(2, <span class="stringliteral">&quot;Driving with CGMGDRIV\n&quot;</span>);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455             VABORT_MSG0(<span class="stringliteral">&quot;CGMGDRIV is not currently supported&quot;</span>);
<a name="l00456"></a>00456             <span class="keywordflow">break</span>;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458         <span class="comment">/* Newton (nonlinear) */</span>
<a name="l00459"></a>00459         <span class="keywordflow">case</span> VSOL_Newton:
<a name="l00460"></a>00460 
<a name="l00461"></a>00461             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00462"></a>00462                 Vnm_print(2, <span class="stringliteral">&quot;Driving with NEWDRIV\n&quot;</span>);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464             <a class="code" href="group___p_m_g_c.html#ga5cd0e12d9b1732dbdf439982b46c3c71" title="Driver for the Newton Solver.">Vnewdriv</a>
<a name="l00465"></a>00465                       (thee-&gt;<a class="code" href="structs_vpmg.html#a40be00c9f8e1a7974391a6e6bf3461b0">iparm</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>, thee-&gt;<a class="code" href="structs_vpmg.html#ac0908d30703d6255e301caef5a20c7c8">iwork</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a1ac4dfbbeb3bd0680998c80dee6e8e6a">rwork</a>,
<a name="l00466"></a>00466                        thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>,
<a name="l00467"></a>00467                        thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#af1686768f19068d072c38c028b651a4d">ccf</a>,
<a name="l00468"></a>00468                        thee-&gt;<a class="code" href="structs_vpmg.html#a52279f4736f2cd888d764c049517a68b">fcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a4340bbd780d87a004aa32f56db41e63c">tcf</a>);
<a name="l00469"></a>00469             <span class="keywordflow">break</span>;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <span class="comment">/* MG (linear/nonlinear) */</span>
<a name="l00472"></a>00472         <span class="keywordflow">case</span> VSOL_MG:
<a name="l00473"></a>00473 
<a name="l00474"></a>00474             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00475"></a>00475                 Vnm_print(2, <span class="stringliteral">&quot;Driving with MGDRIV\n&quot;</span>);
<a name="l00476"></a>00476 
<a name="l00477"></a>00477             <a class="code" href="group___p_m_g_c.html#ga0ca13ed4d4b437d4c5118e201c3e6a13" title="Multilevel solver driver.">Vmgdriv</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a40be00c9f8e1a7974391a6e6bf3461b0">iparm</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>, thee-&gt;<a class="code" href="structs_vpmg.html#ac0908d30703d6255e301caef5a20c7c8">iwork</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a1ac4dfbbeb3bd0680998c80dee6e8e6a">rwork</a>,
<a name="l00478"></a>00478                                         thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>,
<a name="l00479"></a>00479                                         thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#af1686768f19068d072c38c028b651a4d">ccf</a>,
<a name="l00480"></a>00480                                         thee-&gt;<a class="code" href="structs_vpmg.html#a52279f4736f2cd888d764c049517a68b">fcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a4340bbd780d87a004aa32f56db41e63c">tcf</a>);
<a name="l00481"></a>00481             <span class="keywordflow">break</span>;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="comment">/* CGHS (linear/nonlinear) */</span>
<a name="l00484"></a>00484         <span class="keywordflow">case</span> VSOL_CG:
<a name="l00485"></a>00485 
<a name="l00486"></a>00486             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00487"></a>00487                 Vnm_print(2, <span class="stringliteral">&quot;Driving with NCGHSDRIV\n&quot;</span>);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489             VABORT_MSG0(<span class="stringliteral">&quot;NCGHSDRIV is not currently supported&quot;</span>);
<a name="l00490"></a>00490             <span class="keywordflow">break</span>;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         <span class="comment">/* SOR (linear/nonlinear) */</span>
<a name="l00493"></a>00493         <span class="keywordflow">case</span> VSOL_SOR:
<a name="l00494"></a>00494 
<a name="l00495"></a>00495             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00496"></a>00496                 Vnm_print(2, <span class="stringliteral">&quot;Driving with NSORDRIV\n&quot;</span>);
<a name="l00497"></a>00497 
<a name="l00498"></a>00498             VABORT_MSG0(<span class="stringliteral">&quot;NSORDRIV is not currently supported&quot;</span>);
<a name="l00499"></a>00499             <span class="keywordflow">break</span>;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         <span class="comment">/* GSRB (linear/nonlinear) */</span>
<a name="l00502"></a>00502         <span class="keywordflow">case</span> VSOL_RBGS:
<a name="l00503"></a>00503 
<a name="l00504"></a>00504             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00505"></a>00505                 Vnm_print(2, <span class="stringliteral">&quot;Driving with NGSRBDRIV\n&quot;</span>);
<a name="l00506"></a>00506 
<a name="l00507"></a>00507             VABORT_MSG0(<span class="stringliteral">&quot;NGSRBDRIV is not currently supported&quot;</span>);
<a name="l00508"></a>00508             <span class="keywordflow">break</span>;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         <span class="comment">/* WJAC (linear/nonlinear) */</span>
<a name="l00511"></a>00511         <span class="keywordflow">case</span> VSOL_WJ:
<a name="l00512"></a>00512 
<a name="l00513"></a>00513             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00514"></a>00514                 Vnm_print(2, <span class="stringliteral">&quot;Driving with NWJACDRIV\n&quot;</span>);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516             VABORT_MSG0(<span class="stringliteral">&quot;NWJACDRIV is not currently supported&quot;</span>);
<a name="l00517"></a>00517             <span class="keywordflow">break</span>;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         <span class="comment">/* RICH (linear/nonlinear) */</span>
<a name="l00520"></a>00520         <span class="keywordflow">case</span> VSOL_Richardson:
<a name="l00521"></a>00521 
<a name="l00522"></a>00522             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00523"></a>00523                 Vnm_print(2, <span class="stringliteral">&quot;Driving with NRICHDRIV\n&quot;</span>);
<a name="l00524"></a>00524 
<a name="l00525"></a>00525             VABORT_MSG0(<span class="stringliteral">&quot;NRICHDRIV is not currently supported&quot;</span>);
<a name="l00526"></a>00526             <span class="keywordflow">break</span>;
<a name="l00527"></a>00527 
<a name="l00528"></a>00528         <span class="comment">/* CGMG (linear) TEMPORARY USEAQUA */</span>
<a name="l00529"></a>00529         <span class="keywordflow">case</span> VSOL_CGMGAqua:
<a name="l00530"></a>00530 
<a name="l00531"></a>00531             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00532"></a>00532                 Vnm_print(2, <span class="stringliteral">&quot;Driving with CGMGDRIVAQUA\n&quot;</span>);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534             VABORT_MSG0(<span class="stringliteral">&quot;CGMGDRIVAQUA is not currently supported&quot;</span>);
<a name="l00535"></a>00535             <span class="keywordflow">break</span>;
<a name="l00536"></a>00536 
<a name="l00537"></a>00537         <span class="comment">/* Newton (nonlinear) TEMPORARY USEAQUA */</span>
<a name="l00538"></a>00538         <span class="keywordflow">case</span> VSOL_NewtonAqua:
<a name="l00539"></a>00539 
<a name="l00540"></a>00540             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3465c920e73bb3096d213e8a19740ee">iinfo</a> &gt; 1)
<a name="l00541"></a>00541                 Vnm_print(2, <span class="stringliteral">&quot;Driving with NEWDRIVAQUA\n&quot;</span>);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543             VABORT_MSG0(<span class="stringliteral">&quot;NEWDRIVAQUA is not currently supported&quot;</span>);
<a name="l00544"></a>00544             <span class="keywordflow">break</span>;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         <span class="comment">/* Error handling */</span>
<a name="l00547"></a>00547         <span class="keywordflow">default</span>:
<a name="l00548"></a>00548             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_solve: invalid solver method key (%d)\n&quot;</span>,
<a name="l00549"></a>00549               thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a35af0be900467fedbb610bd6ea65ed78">key</a>);
<a name="l00550"></a>00550             <span class="keywordflow">return</span> 0;
<a name="l00551"></a>00551             <span class="keywordflow">break</span>;
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554     <span class="keywordflow">return</span> 1;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558 
<a name="l00559"></a><a class="code" href="group___vpmg.html#ga1c87698f1d365aa7677f6b3ff64c9e8d">00559</a> VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga1c87698f1d365aa7677f6b3ff64c9e8d" title="Object destructor.">Vpmg_dtor</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> **thee) {
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="keywordflow">if</span> ((*thee) != VNULL) {
<a name="l00562"></a>00562         <a class="code" href="group___vpmg.html#ga8d5a7ccc99d8b4644683bc2a862d7597" title="FORTRAN stub object destructor.">Vpmg_dtor2</a>(*thee);
<a name="l00563"></a>00563         Vmem_free(VNULL, 1, <span class="keyword">sizeof</span>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a>), (<span class="keywordtype">void</span> **)thee);
<a name="l00564"></a>00564         (*thee) = VNULL;
<a name="l00565"></a>00565     }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 }
<a name="l00568"></a>00568 
<a name="l00569"></a><a class="code" href="group___vpmg.html#ga8d5a7ccc99d8b4644683bc2a862d7597">00569</a> VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga8d5a7ccc99d8b4644683bc2a862d7597" title="FORTRAN stub object destructor.">Vpmg_dtor2</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l00570"></a>00570 
<a name="l00571"></a>00571     <span class="comment">/* Clean up the storage */</span>
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,              100, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),
<a name="l00574"></a>00574       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a40be00c9f8e1a7974391a6e6bf3461b0">iparm</a>));
<a name="l00575"></a>00575     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>,              100, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00576"></a>00576         (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>));
<a name="l00577"></a>00577     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad5d46810a61a64f1ce15e001ba347b8d">niwk</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),
<a name="l00578"></a>00578       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#ac0908d30703d6255e301caef5a20c7c8">iwork</a>));
<a name="l00579"></a>00579     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a98e54f761e0cd85460831d47407001b2">nrwk</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00580"></a>00580       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a1ac4dfbbeb3bd0680998c80dee6e8e6a">rwork</a>));
<a name="l00581"></a>00581     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00582"></a>00582       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>));
<a name="l00583"></a>00583     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00584"></a>00584       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>));
<a name="l00585"></a>00585     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00586"></a>00586               (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a34ec3c42c48d141ec30c8d2195722e11">pot</a>));
<a name="l00587"></a>00587     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00588"></a>00588       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>));
<a name="l00589"></a>00589     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00590"></a>00590       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>));
<a name="l00591"></a>00591     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00592"></a>00592       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>));
<a name="l00593"></a>00593     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00594"></a>00594       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>));
<a name="l00595"></a>00595     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00596"></a>00596       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>));
<a name="l00597"></a>00597     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00598"></a>00598       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>));
<a name="l00599"></a>00599     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00600"></a>00600       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#af1686768f19068d072c38c028b651a4d">ccf</a>));
<a name="l00601"></a>00601     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00602"></a>00602       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a52279f4736f2cd888d764c049517a68b">fcf</a>));
<a name="l00603"></a>00603     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00604"></a>00604       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a4340bbd780d87a004aa32f56db41e63c">tcf</a>));
<a name="l00605"></a>00605     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a50dceb4b3401035d973d63d7123b551c">narr</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00606"></a>00606       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>));
<a name="l00607"></a>00607     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 5*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00608"></a>00608       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>));
<a name="l00609"></a>00609     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 5*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00610"></a>00610       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>));
<a name="l00611"></a>00611     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 5*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00612"></a>00612       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>));
<a name="l00613"></a>00613     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 10*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00614"></a>00614       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>));
<a name="l00615"></a>00615     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 10*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00616"></a>00616       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>));
<a name="l00617"></a>00617     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, 10*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),
<a name="l00618"></a>00618       (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>));
<a name="l00619"></a>00619     Vmem_free(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>, (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>)*(thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>),
<a name="l00620"></a>00620       <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>), (<span class="keywordtype">void</span> **)&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>));
<a name="l00621"></a>00621 
<a name="l00622"></a>00622     Vmem_dtor(&amp;(thee-&gt;<a class="code" href="structs_vpmg.html#adfacdf16f7a3cf04b35f4821208b5bdd">vmem</a>));
<a name="l00623"></a>00623 }
<a name="l00624"></a>00624 
<a name="l00625"></a><a class="code" href="group___vpmg.html#gafe4fbd069927d516936116a417a256c1">00625</a> VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gafe4fbd069927d516936116a417a256c1" title="Set partition information which restricts the calculation of observables to a (rectangular) subset of...">Vpmg_setPart</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> lowerCorner[3],
<a name="l00626"></a>00626         <span class="keywordtype">double</span> upperCorner[3], <span class="keywordtype">int</span> bflags[6]) {
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l00629"></a>00629     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l00630"></a>00630     <span class="keywordtype">int</span> i, j, k, nx, ny, nz;
<a name="l00631"></a>00631     <span class="keywordtype">double</span> xmin, ymin, zmin, x, y, z, hx, hy, hzed, xok, yok, zok;
<a name="l00632"></a>00632     <span class="keywordtype">double</span> x0,x1,y0,y1,z0,z1;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l00635"></a>00635     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l00636"></a>00636     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l00637"></a>00637     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l00638"></a>00638     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l00639"></a>00639     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l00640"></a>00640     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - 0.5*hx*(nx-1);
<a name="l00641"></a>00641     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - 0.5*hy*(ny-1);
<a name="l00642"></a>00642     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - 0.5*hzed*(nz-1);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     xok = 0;
<a name="l00645"></a>00645     yok = 0;
<a name="l00646"></a>00646     zok = 0;
<a name="l00647"></a>00647 
<a name="l00648"></a>00648     <span class="comment">/* We need have called Vpmg_fillco first */</span>
<a name="l00649"></a>00649 
<a name="l00650"></a>00650     alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  lower corner = (%g, %g, %g)\n&quot;</span>,
<a name="l00653"></a>00653       lowerCorner[0], lowerCorner[1], lowerCorner[2]);
<a name="l00654"></a>00654     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  upper corner = (%g, %g, %g)\n&quot;</span>,
<a name="l00655"></a>00655       upperCorner[0], upperCorner[1], upperCorner[2]);
<a name="l00656"></a>00656     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  actual minima = (%g, %g, %g)\n&quot;</span>,
<a name="l00657"></a>00657       xmin, ymin, zmin);
<a name="l00658"></a>00658     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  actual maxima = (%g, %g, %g)\n&quot;</span>,
<a name="l00659"></a>00659       xmin+hx*(nx-1), ymin+hy*(ny-1), zmin+hzed*(nz-1));
<a name="l00660"></a>00660     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  bflag[FRONT] = %d\n&quot;</span>,
<a name="l00661"></a>00661       bflags[<a class="code" href="group___vhal.html#ga448448d313ecbdf83a7f93434f0a584a" title="Face definition for a volume.">VAPBS_FRONT</a>]);
<a name="l00662"></a>00662     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  bflag[BACK] = %d\n&quot;</span>,
<a name="l00663"></a>00663       bflags[<a class="code" href="group___vhal.html#gaf4e4333b48f727631b092261d9f92c81" title="Face definition for a volume.">VAPBS_BACK</a>]);
<a name="l00664"></a>00664     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  bflag[LEFT] = %d\n&quot;</span>,
<a name="l00665"></a>00665       bflags[<a class="code" href="group___vhal.html#ga798032036c9c60fc5f471c6b7d2b7db6" title="Face definition for a volume.">VAPBS_LEFT</a>]);
<a name="l00666"></a>00666     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  bflag[RIGHT] = %d\n&quot;</span>,
<a name="l00667"></a>00667       bflags[<a class="code" href="group___vhal.html#ga8f2dde497bc361d93ca1ddb94dae77d3" title="Face definition for a volume.">VAPBS_RIGHT</a>]);
<a name="l00668"></a>00668     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  bflag[UP] = %d\n&quot;</span>,
<a name="l00669"></a>00669       bflags[<a class="code" href="group___vhal.html#ga26162951b2540e56cf9b7e0cd0ed9caa" title="Face definition for a volume.">VAPBS_UP</a>]);
<a name="l00670"></a>00670     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_setPart:  bflag[DOWN] = %d\n&quot;</span>,
<a name="l00671"></a>00671       bflags[<a class="code" href="group___vhal.html#ga57969092add9d0a00e8552a6e8995bcf" title="Face definition for a volume.">VAPBS_DOWN</a>]);
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     <span class="comment">/* Identify atoms as inside, outside, or on the border</span>
<a name="l00674"></a>00674 <span class="comment">       If on the border, use the bflags to determine if there</span>
<a name="l00675"></a>00675 <span class="comment">       is an adjacent processor - if so, this atom should be equally</span>
<a name="l00676"></a>00676 <span class="comment">       shared. */</span>
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); i++) {
<a name="l00679"></a>00679         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, i);
<a name="l00680"></a>00680 
<a name="l00681"></a>00681         <span class="keywordflow">if</span> ((atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0] &lt; upperCorner[0]) &amp;&amp;
<a name="l00682"></a>00682             (atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0] &gt; lowerCorner[0])) xok = 1;
<a name="l00683"></a>00683         <span class="keywordflow">else</span> {
<a name="l00684"></a>00684             <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0] - lowerCorner[0]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00685"></a>00685                 (bflags[VAPBS_LEFT] == 0)) xok = 1;
<a name="l00686"></a>00686             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0] - lowerCorner[0]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00687"></a>00687                 (bflags[VAPBS_LEFT] == 1)) xok = 0.5;
<a name="l00688"></a>00688             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0] - upperCorner[0]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00689"></a>00689                 (bflags[VAPBS_RIGHT] == 0)) xok = 1;
<a name="l00690"></a>00690             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0] - upperCorner[0]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00691"></a>00691                 (bflags[VAPBS_RIGHT] == 1)) xok = 0.5;
<a name="l00692"></a>00692             <span class="keywordflow">else</span> xok = 0;
<a name="l00693"></a>00693         }
<a name="l00694"></a>00694         <span class="keywordflow">if</span> ((atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1] &lt; upperCorner[1]) &amp;&amp;
<a name="l00695"></a>00695             (atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1] &gt; lowerCorner[1])) yok = 1;
<a name="l00696"></a>00696         <span class="keywordflow">else</span> {
<a name="l00697"></a>00697             <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1] - lowerCorner[1]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00698"></a>00698                 (bflags[VAPBS_BACK] == 0)) yok = 1;
<a name="l00699"></a>00699             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1] - lowerCorner[1]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00700"></a>00700                 (bflags[VAPBS_BACK] == 1)) yok = 0.5;
<a name="l00701"></a>00701             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1] - upperCorner[1]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00702"></a>00702                 (bflags[VAPBS_FRONT] == 0)) yok = 1;
<a name="l00703"></a>00703             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1] - upperCorner[1]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00704"></a>00704                 (bflags[VAPBS_FRONT] == 1)) yok = 0.5;
<a name="l00705"></a>00705             <span class="keywordflow">else</span> yok = 0;
<a name="l00706"></a>00706         }
<a name="l00707"></a>00707         <span class="keywordflow">if</span> ((atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2] &lt; upperCorner[2]) &amp;&amp;
<a name="l00708"></a>00708             (atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2] &gt; lowerCorner[2])) zok = 1;
<a name="l00709"></a>00709         <span class="keywordflow">else</span> {
<a name="l00710"></a>00710             <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2] - lowerCorner[2]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00711"></a>00711                 (bflags[VAPBS_DOWN] == 0)) zok = 1;
<a name="l00712"></a>00712             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2] - lowerCorner[2]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00713"></a>00713                 (bflags[VAPBS_DOWN] == 1)) zok = 0.5;
<a name="l00714"></a>00714             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2] - upperCorner[2]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00715"></a>00715                 (bflags[VAPBS_UP] == 0)) zok = 1;
<a name="l00716"></a>00716             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2] - upperCorner[2]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00717"></a>00717                 (bflags[VAPBS_UP] == 1)) zok = 0.5;
<a name="l00718"></a>00718             <span class="keywordflow">else</span> zok = 0;
<a name="l00719"></a>00719         }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> = xok*yok*zok;
<a name="l00722"></a>00722         <span class="comment">/*</span>
<a name="l00723"></a>00723 <span class="comment">        Vnm_print(1, &quot;DEBUG (%s, %d):  atom-&gt;position[0] - upperCorner[0] = %g\n&quot;,</span>
<a name="l00724"></a>00724 <span class="comment">                  __FILE__, __LINE__, atom-&gt;position[0] - upperCorner[0]);</span>
<a name="l00725"></a>00725 <span class="comment">        Vnm_print(1, &quot;DEBUG (%s, %d):  atom-&gt;position[0] - lowerCorner[0] = %g\n&quot;,</span>
<a name="l00726"></a>00726 <span class="comment">                  __FILE__, __LINE__, atom-&gt;position[0] - lowerCorner[0]);</span>
<a name="l00727"></a>00727 <span class="comment">        Vnm_print(1, &quot;DEBUG (%s, %d):  atom-&gt;position[1] - upperCorner[1] = %g\n&quot;,</span>
<a name="l00728"></a>00728 <span class="comment">                  __FILE__, __LINE__, atom-&gt;position[1] - upperCorner[1]);</span>
<a name="l00729"></a>00729 <span class="comment">        Vnm_print(1, &quot;DEBUG (%s, %d):  atom-&gt;position[1] - lowerCorner[1] = %g\n&quot;,</span>
<a name="l00730"></a>00730 <span class="comment">                  __FILE__, __LINE__, atom-&gt;position[1] - lowerCorner[1]);</span>
<a name="l00731"></a>00731 <span class="comment">        Vnm_print(1, &quot;DEBUG (%s, %d):  atom-&gt;position[2] - upperCorner[2] = %g\n&quot;,</span>
<a name="l00732"></a>00732 <span class="comment">                  __FILE__, __LINE__, atom-&gt;position[2] - upperCorner[2]);</span>
<a name="l00733"></a>00733 <span class="comment">        Vnm_print(1, &quot;DEBUG (%s, %d):  atom-&gt;position[2] - lowerCorner[0] = %g\n&quot;,</span>
<a name="l00734"></a>00734 <span class="comment">                  __FILE__, __LINE__, atom-&gt;position[2] - lowerCorner[2]);</span>
<a name="l00735"></a>00735 <span class="comment">        Vnm_print(1, &quot;DEBUG (%s, %d):  xok = %g, yok = %g, zok = %g\n&quot;,</span>
<a name="l00736"></a>00736 <span class="comment">                  __FILE__, __LINE__, xok, yok, zok);</span>
<a name="l00737"></a>00737 <span class="comment">         */</span>
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741     <span class="comment">/* Load up pvec -</span>
<a name="l00742"></a>00742 <span class="comment">       For all points within h{axis}/2 of a border - use a gradient</span>
<a name="l00743"></a>00743 <span class="comment">       to determine the pvec weight.</span>
<a name="l00744"></a>00744 <span class="comment">       Points on the boundary depend on the presence of an adjacent</span>
<a name="l00745"></a>00745 <span class="comment">       processor. */</span>
<a name="l00746"></a>00746 
<a name="l00747"></a>00747     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i] = 0.0;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     for (i=0; i&lt;nx; i++) {
<a name="l00750"></a>00750         xok = 0.0;
<a name="l00751"></a>00751         x = i*hx + xmin;
<a name="l00752"></a>00752         <span class="keywordflow">if</span> ( (x &lt; (upperCorner[0]-hx/2)) &amp;&amp;
<a name="l00753"></a>00753              (x &gt; (lowerCorner[0]+hx/2))
<a name="l00754"></a>00754            ) xok = 1.0;
<a name="l00755"></a>00755         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (VABS(x - lowerCorner[0]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00756"></a>00756                   (bflags[VAPBS_LEFT] == 0)) xok = 1.0;
<a name="l00757"></a>00757         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(x - lowerCorner[0]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00758"></a>00758                  (bflags[VAPBS_LEFT] == 1)) xok = 0.5;
<a name="l00759"></a>00759         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(x - upperCorner[0]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00760"></a>00760                  (bflags[VAPBS_RIGHT] == 0)) xok = 1.0;
<a name="l00761"></a>00761         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(x - upperCorner[0]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00762"></a>00762                  (bflags[VAPBS_RIGHT] == 1)) xok = 0.5;
<a name="l00763"></a>00763         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; (upperCorner[0] + hx/2)) || (x &lt; (lowerCorner[0] - hx/2))) xok = 0.0;
<a name="l00764"></a>00764         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &lt; (upperCorner[0] + hx/2)) || (x &gt; (lowerCorner[0] - hx/2))) {
<a name="l00765"></a>00765             x0 = VMAX2(x - hx/2, lowerCorner[0]);
<a name="l00766"></a>00766             x1 = VMIN2(x + hx/2, upperCorner[0]);
<a name="l00767"></a>00767             xok = VABS(x1-x0)/hx;
<a name="l00768"></a>00768 
<a name="l00769"></a>00769             <span class="keywordflow">if</span> (xok &lt; 0.0) {
<a name="l00770"></a>00770                 <span class="keywordflow">if</span> (VABS(xok) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) xok = 0.0;
<a name="l00771"></a>00771                 <span class="keywordflow">else</span> {
<a name="l00772"></a>00772                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_setPart:  fell off x-interval (%1.12E)!\n&quot;</span>,
<a name="l00773"></a>00773                             xok);
<a name="l00774"></a>00774                     VASSERT(0);
<a name="l00775"></a>00775                 }
<a name="l00776"></a>00776             }
<a name="l00777"></a>00777             <span class="keywordflow">if</span> (xok &gt; 1.0) {
<a name="l00778"></a>00778                 <span class="keywordflow">if</span> (VABS(xok - 1.0) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) xok = 1.0;
<a name="l00779"></a>00779                 <span class="keywordflow">else</span> {
<a name="l00780"></a>00780                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_setPart:  fell off x-interval (%1.12E)!\n&quot;</span>,
<a name="l00781"></a>00781                             xok);
<a name="l00782"></a>00782                     VASSERT(0);
<a name="l00783"></a>00783                 }
<a name="l00784"></a>00784             }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         } <span class="keywordflow">else</span> xok = 0.0;
<a name="l00787"></a>00787 
<a name="l00788"></a>00788         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l00789"></a>00789             yok = 0.0;
<a name="l00790"></a>00790             y = j*hy + ymin;
<a name="l00791"></a>00791             <span class="keywordflow">if</span> ((y &lt; (upperCorner[1]-hy/2)) &amp;&amp; (y &gt; (lowerCorner[1]+hy/2))) yok = 1.0;
<a name="l00792"></a>00792             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(y - lowerCorner[1]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00793"></a>00793                      (bflags[VAPBS_BACK] == 0)) yok = 1.0;
<a name="l00794"></a>00794             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(y - lowerCorner[1]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00795"></a>00795                      (bflags[VAPBS_BACK] == 1)) yok = 0.5;
<a name="l00796"></a>00796             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(y - upperCorner[1]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00797"></a>00797                      (bflags[VAPBS_FRONT] == 0)) yok = 1.0;
<a name="l00798"></a>00798             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(y - upperCorner[1]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00799"></a>00799                      (bflags[VAPBS_FRONT] == 1)) yok = 0.5;
<a name="l00800"></a>00800             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((y &gt; (upperCorner[1] + hy/2)) || (y &lt; (lowerCorner[1] - hy/2))) yok=0.0;
<a name="l00801"></a>00801             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((y &lt; (upperCorner[1] + hy/2)) || (y &gt; (lowerCorner[1] - hy/2))){
<a name="l00802"></a>00802                 y0 = VMAX2(y - hy/2, lowerCorner[1]);
<a name="l00803"></a>00803                 y1 = VMIN2(y + hy/2, upperCorner[1]);
<a name="l00804"></a>00804                 yok = VABS(y1-y0)/hy;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806                 <span class="keywordflow">if</span> (yok &lt; 0.0) {
<a name="l00807"></a>00807                     <span class="keywordflow">if</span> (VABS(yok) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) yok = 0.0;
<a name="l00808"></a>00808                     <span class="keywordflow">else</span> {
<a name="l00809"></a>00809                         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_setPart:  fell off y-interval (%1.12E)!\n&quot;</span>,
<a name="l00810"></a>00810                                 yok);
<a name="l00811"></a>00811                         VASSERT(0);
<a name="l00812"></a>00812                     }
<a name="l00813"></a>00813                 }
<a name="l00814"></a>00814                 <span class="keywordflow">if</span> (yok &gt; 1.0) {
<a name="l00815"></a>00815                     <span class="keywordflow">if</span> (VABS(yok - 1.0) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) yok = 1.0;
<a name="l00816"></a>00816                     <span class="keywordflow">else</span> {
<a name="l00817"></a>00817                         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_setPart:  fell off y-interval (%1.12E)!\n&quot;</span>,
<a name="l00818"></a>00818                                 yok);
<a name="l00819"></a>00819                         VASSERT(0);
<a name="l00820"></a>00820                     }
<a name="l00821"></a>00821                 }
<a name="l00822"></a>00822             }
<a name="l00823"></a>00823             <span class="keywordflow">else</span> yok=0.0;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l00826"></a>00826                 zok = 0.0;
<a name="l00827"></a>00827                 z = k*hzed + zmin;
<a name="l00828"></a>00828                 <span class="keywordflow">if</span> ((z &lt; (upperCorner[2]-hzed/2)) &amp;&amp; (z &gt; (lowerCorner[2]+hzed/2))) zok = 1.0;
<a name="l00829"></a>00829                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(z - lowerCorner[2]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00830"></a>00830                          (bflags[VAPBS_DOWN] == 0)) zok = 1.0;
<a name="l00831"></a>00831                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(z - lowerCorner[2]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00832"></a>00832                          (bflags[VAPBS_DOWN] == 1)) zok = 0.5;
<a name="l00833"></a>00833                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(z - upperCorner[2]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00834"></a>00834                          (bflags[VAPBS_UP] == 0)) zok = 1.0;
<a name="l00835"></a>00835                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((VABS(z - upperCorner[2]) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp;
<a name="l00836"></a>00836                          (bflags[VAPBS_UP] == 1)) zok = 0.5;
<a name="l00837"></a>00837                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((z &gt; (upperCorner[2] + hzed/2)) || (z &lt; (lowerCorner[2] - hzed/2))) zok=0.0;
<a name="l00838"></a>00838                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((z &lt; (upperCorner[2] + hzed/2)) || (z &gt; (lowerCorner[2] - hzed/2))){
<a name="l00839"></a>00839                     z0 = VMAX2(z - hzed/2, lowerCorner[2]);
<a name="l00840"></a>00840                     z1 = VMIN2(z + hzed/2, upperCorner[2]);
<a name="l00841"></a>00841                     zok = VABS(z1-z0)/hzed;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843                     <span class="keywordflow">if</span> (zok &lt; 0.0) {
<a name="l00844"></a>00844                         <span class="keywordflow">if</span> (VABS(zok) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) zok = 0.0;
<a name="l00845"></a>00845                         <span class="keywordflow">else</span> {
<a name="l00846"></a>00846                             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_setPart:  fell off z-interval (%1.12E)!\n&quot;</span>,
<a name="l00847"></a>00847                                     zok);
<a name="l00848"></a>00848                             VASSERT(0);
<a name="l00849"></a>00849                         }
<a name="l00850"></a>00850                     }
<a name="l00851"></a>00851                     <span class="keywordflow">if</span> (zok &gt; 1.0) {
<a name="l00852"></a>00852                         <span class="keywordflow">if</span> (VABS(zok - 1.0) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) zok = 1.0;
<a name="l00853"></a>00853                         <span class="keywordflow">else</span> {
<a name="l00854"></a>00854                             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_setPart:  fell off z-interval (%1.12E)!\n&quot;</span>,
<a name="l00855"></a>00855                                     zok);
<a name="l00856"></a>00856                             VASSERT(0);
<a name="l00857"></a>00857                         }
<a name="l00858"></a>00858                     }
<a name="l00859"></a>00859                 }
<a name="l00860"></a>00860                 <span class="keywordflow">else</span> zok = 0.0;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862                 <span class="keywordflow">if</span> (VABS(xok*yok*zok) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)] = 0.0;
<a name="l00863"></a>00863                 <span class="keywordflow">else</span> thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)] = xok*yok*zok;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865             }
<a name="l00866"></a>00866         }
<a name="l00867"></a>00867     }
<a name="l00868"></a>00868 }
<a name="l00869"></a>00869 
<a name="l00870"></a><a class="code" href="group___vpmg.html#gafc90a96505e0bddd5cc15b69f3c7613c">00870</a> VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gafc90a96505e0bddd5cc15b69f3c7613c" title="Remove partition restrictions.">Vpmg_unsetPart</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     <span class="keywordtype">int</span> i, nx, ny, nz;
<a name="l00873"></a>00873     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l00874"></a>00874     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876     VASSERT(thee != VNULL);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l00879"></a>00879     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l00880"></a>00880     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l00881"></a>00881     alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l00882"></a>00882 
<a name="l00883"></a>00883     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i] = 1;
<a name="l00884"></a>00884     for (i=0; i&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); i++) {
<a name="l00885"></a>00885         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, i);
<a name="l00886"></a>00886         atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> = 1;
<a name="l00887"></a>00887     }
<a name="l00888"></a>00888 }
<a name="l00889"></a>00889 
<a name="l00890"></a><a class="code" href="group___vpmg.html#ga11ed702159c3c6ee7d89c9d0bcdee240">00890</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#ga11ed702159c3c6ee7d89c9d0bcdee240" title="Fill the specified array with accessibility values.">Vpmg_fillArray</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> *vec, <a class="code" href="group___vhal.html#gadfc214425db779e6548c11fab04ab043" title="Declaration of the Vdata_Type type as the Vdata_Type enum.">Vdata_Type</a> type,
<a name="l00891"></a>00891   <span class="keywordtype">double</span> parm, <a class="code" href="group___vhal.html#gaa0aabb1579af98f26effe7796b2d0a0c" title="Declaration of the Vhal_PBEType type as the Vhal_PBEType enum.">Vhal_PBEType</a> pbetype, <a class="code" href="structs_p_b_eparm.html" title="Parameter structure for PBE variables from input files.">PBEparm</a> *pbeparm) {
<a name="l00892"></a>00892 
<a name="l00893"></a>00893     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc = VNULL;
<a name="l00894"></a>00894     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a> = VNULL;
<a name="l00895"></a>00895     <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *grid = VNULL;
<a name="l00896"></a>00896     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atoms = VNULL;
<a name="l00897"></a>00897     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist = VNULL;
<a name="l00898"></a>00898     <span class="keywordtype">double</span> position[3], hx, hy, hzed, xmin, ymin, zmin;
<a name="l00899"></a>00899     <span class="keywordtype">double</span> grad[3], eps, epsp, epss, zmagic;
<a name="l00900"></a>00900     <span class="keywordtype">int</span> i, j, k, l, nx, ny, nz, ichop;
<a name="l00901"></a>00901 
<a name="l00902"></a>00902     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l00903"></a>00903     acc = <a class="code" href="group___vpbe.html#gae9e1820d03a7d68c53dca41072a65640" title="Get accessibility oracle.">Vpbe_getVacc</a>(pbe);
<a name="l00904"></a>00904     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l00905"></a>00905     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l00906"></a>00906     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l00907"></a>00907     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l00908"></a>00908     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l00909"></a>00909     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l00910"></a>00910     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l00911"></a>00911     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l00912"></a>00912     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l00913"></a>00913     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l00914"></a>00914     epss = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l00915"></a>00915     zmagic = <a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     <span class="keywordflow">if</span> (!(thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>)) {
<a name="l00918"></a>00918         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillArray:  need to call Vpmg_fillco first!\n&quot;</span>);
<a name="l00919"></a>00919         <span class="keywordflow">return</span> 0;
<a name="l00920"></a>00920     }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922     <span class="keywordflow">switch</span> (type) {
<a name="l00923"></a>00923 
<a name="l00924"></a>00924         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605a186faf74bda42dcbc795add9e98dd0b6">VDT_CHARGE</a>:
<a name="l00925"></a>00925 
<a name="l00926"></a>00926             <span class="keywordflow">for</span> (i=0; i&lt;nx*ny*nz; i++) vec[i] = thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[i]/zmagic;
<a name="l00927"></a>00927             <span class="keywordflow">break</span>;
<a name="l00928"></a>00928 
<a name="l00929"></a>00929         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605a81ed944a04823938f7c709e9537e23b7">VDT_DIELX</a>:
<a name="l00930"></a>00930 
<a name="l00931"></a>00931             for (i=0; i&lt;nx*ny*nz; i++) vec[i] = thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i];
<a name="l00932"></a>00932             <span class="keywordflow">break</span>;
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605ad53339f5d19ea98ff63304e6a660ed94">VDT_DIELY</a>:
<a name="l00935"></a>00935 
<a name="l00936"></a>00936             for (i=0; i&lt;nx*ny*nz; i++) vec[i] = thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i];
<a name="l00937"></a>00937             <span class="keywordflow">break</span>;
<a name="l00938"></a>00938 
<a name="l00939"></a>00939         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605ab6839510f11e75b04c7e74bc7e3b48fc">VDT_DIELZ</a>:
<a name="l00940"></a>00940 
<a name="l00941"></a>00941             for (i=0; i&lt;nx*ny*nz; i++) vec[i] = thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i];
<a name="l00942"></a>00942             <span class="keywordflow">break</span>;
<a name="l00943"></a>00943 
<a name="l00944"></a>00944         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605a28b2bab7637e8c5d2aa789130366083f">VDT_KAPPA</a>:
<a name="l00945"></a>00945 
<a name="l00946"></a>00946             for (i=0; i&lt;nx*ny*nz; i++) vec[i] = thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i];
<a name="l00947"></a>00947             <span class="keywordflow">break</span>;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605ab1fafa3cff7f438d0181e9e1259be3e0">VDT_POT</a>:
<a name="l00950"></a>00950 
<a name="l00951"></a>00951             for (i=0; i&lt;nx*ny*nz; i++) vec[i] = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i];
<a name="l00952"></a>00952             <span class="keywordflow">break</span>;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605aef9c456dfc9eccac7f9ab573facc6f6e">VDT_ATOMPOT</a>:
<a name="l00955"></a>00955             alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l00956"></a>00956             atoms = alist[pbeparm-&gt;<a class="code" href="structs_p_b_eparm.html#ae2b837562f7605f66a1c7817a1c820ef">molid</a>-1].<a class="code" href="structs_valist.html#abcf7d483565ac8ac342a6dd0af8ee18d">atoms</a>;
<a name="l00957"></a>00957             grid = <a class="code" href="group___vgrid.html#ga5ef6f1d4f8ace74fbf26318659f4948e" title="Construct Vgrid object with values obtained from Vpmg_readDX (for example)">Vgrid_ctor</a>(nx, ny, nz, hx, hy,
<a name="l00958"></a>00958                               hzed, xmin, ymin, zmin,thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>);
<a name="l00959"></a>00959             <span class="keywordflow">for</span> (i=0; i&lt;alist[pbeparm-&gt;<a class="code" href="structs_p_b_eparm.html#ae2b837562f7605f66a1c7817a1c820ef">molid</a>-1].<a class="code" href="structs_valist.html#a7106e2abc437ad981830d14176d15f09">number</a>;i++) {
<a name="l00960"></a>00960                 position[0] = atoms[i].<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0];
<a name="l00961"></a>00961                 position[1] = atoms[i].<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1];
<a name="l00962"></a>00962                 position[2] = atoms[i].<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2];
<a name="l00963"></a>00963 
<a name="l00964"></a>00964                 <a class="code" href="group___vgrid.html#gae96a803dbd3016673affbc3d10310150" title="Get potential value (from mesh or approximation) at a point.">Vgrid_value</a>(grid, position, &amp;vec[i]);
<a name="l00965"></a>00965             }
<a name="l00966"></a>00966             <a class="code" href="group___vgrid.html#ga2f2ff1e7df77e0206d37df732d4bb4e9" title="Object destructor.">Vgrid_dtor</a>(&amp;grid);
<a name="l00967"></a>00967             <span class="keywordflow">break</span>;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605a568ec69898d3ca1eb2dae4d24a993674">VDT_SMOL</a>:
<a name="l00970"></a>00970 
<a name="l00971"></a>00971             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l00972"></a>00972                 <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l00973"></a>00973                     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l00974"></a>00974 
<a name="l00975"></a>00975                         position[0] = i*hx + xmin;
<a name="l00976"></a>00976                         position[1] = j*hy + ymin;
<a name="l00977"></a>00977                         position[2] = k*hzed + zmin;
<a name="l00978"></a>00978 
<a name="l00979"></a>00979                         vec[IJK(i,j,k)] = (<a class="code" href="group___vacc.html#ga31a47b0e2a3e828ab38802dbebb07415" title="Report molecular accessibility.">Vacc_molAcc</a>(acc,position,parm));
<a name="l00980"></a>00980                     }
<a name="l00981"></a>00981                 }
<a name="l00982"></a>00982             }
<a name="l00983"></a>00983             <span class="keywordflow">break</span>;
<a name="l00984"></a>00984 
<a name="l00985"></a>00985         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605a099bad23256fecbd106e3359cdcf9f3d">VDT_SSPL</a>:
<a name="l00986"></a>00986 
<a name="l00987"></a>00987             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l00988"></a>00988                 <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l00989"></a>00989                     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l00990"></a>00990 
<a name="l00991"></a>00991                         position[0] = i*hx + xmin;
<a name="l00992"></a>00992                         position[1] = j*hy + ymin;
<a name="l00993"></a>00993                         position[2] = k*hzed + zmin;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995                         vec[IJK(i,j,k)] = <a class="code" href="group___vacc.html#ga6ba9bfeee26f30304543c0c15aeb34ef" title="Report spline-based accessibility.">Vacc_splineAcc</a>(acc,position,parm,0);
<a name="l00996"></a>00996                     }
<a name="l00997"></a>00997                 }
<a name="l00998"></a>00998             }
<a name="l00999"></a>00999             <span class="keywordflow">break</span>;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605ada6a45220656dcdd347ca208e4a4beb6">VDT_VDW</a>:
<a name="l01002"></a>01002 
<a name="l01003"></a>01003             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l01004"></a>01004                 <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l01005"></a>01005                     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l01006"></a>01006 
<a name="l01007"></a>01007                         position[0] = i*hx + xmin;
<a name="l01008"></a>01008                         position[1] = j*hy + ymin;
<a name="l01009"></a>01009                         position[2] = k*hzed + zmin;
<a name="l01010"></a>01010 
<a name="l01011"></a>01011                         vec[IJK(i,j,k)] = <a class="code" href="group___vacc.html#ga3720639ef38c9755860950a1d3f32c74" title="Report van der Waals accessibility.">Vacc_vdwAcc</a>(acc,position);
<a name="l01012"></a>01012                     }
<a name="l01013"></a>01013                 }
<a name="l01014"></a>01014             }
<a name="l01015"></a>01015             <span class="keywordflow">break</span>;
<a name="l01016"></a>01016 
<a name="l01017"></a>01017         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605a4aa42188f13ba77371168b0b31bd3bdb">VDT_IVDW</a>:
<a name="l01018"></a>01018 
<a name="l01019"></a>01019             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l01020"></a>01020                 <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l01021"></a>01021                     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l01022"></a>01022 
<a name="l01023"></a>01023                         position[0] = i*hx + xmin;
<a name="l01024"></a>01024                         position[1] = j*hy + ymin;
<a name="l01025"></a>01025                         position[2] = k*hzed + zmin;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027                         vec[IJK(i,j,k)] = <a class="code" href="group___vacc.html#ga050da431e776227898c5a7e7060d2202" title="Report inflated van der Waals accessibility.">Vacc_ivdwAcc</a>(acc,position,parm);
<a name="l01028"></a>01028                     }
<a name="l01029"></a>01029                 }
<a name="l01030"></a>01030             }
<a name="l01031"></a>01031             <span class="keywordflow">break</span>;
<a name="l01032"></a>01032 
<a name="l01033"></a>01033         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605afbc9ba97afee71bae21c24eefa1a8b4c">VDT_LAP</a>:
<a name="l01034"></a>01034 
<a name="l01035"></a>01035             grid = <a class="code" href="group___vgrid.html#ga5ef6f1d4f8ace74fbf26318659f4948e" title="Construct Vgrid object with values obtained from Vpmg_readDX (for example)">Vgrid_ctor</a>(nx, ny, nz, hx, hy, hzed, xmin, ymin, zmin,
<a name="l01036"></a>01036               thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>);
<a name="l01037"></a>01037             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l01038"></a>01038                 <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l01039"></a>01039                     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l01040"></a>01040 
<a name="l01041"></a>01041                         <span class="keywordflow">if</span> ((k==0) || (k==(nz-1)) ||
<a name="l01042"></a>01042                             (j==0) || (j==(ny-1)) ||
<a name="l01043"></a>01043                             (i==0) || (i==(nx-1))) {
<a name="l01044"></a>01044 
<a name="l01045"></a>01045                             vec[IJK(i,j,k)] = 0;
<a name="l01046"></a>01046 
<a name="l01047"></a>01047                         } <span class="keywordflow">else</span> {
<a name="l01048"></a>01048                                 position[0] = i*hx + xmin;
<a name="l01049"></a>01049                                 position[1] = j*hy + ymin;
<a name="l01050"></a>01050                                 position[2] = k*hzed + zmin;
<a name="l01051"></a>01051                                 VASSERT(<a class="code" href="group___vgrid.html#gaababece8cabca6d17f714107c6afd8dd" title="Get second derivative values at a point.">Vgrid_curvature</a>(grid,position, 1,
<a name="l01052"></a>01052                                   &amp;(vec[IJK(i,j,k)])));
<a name="l01053"></a>01053                         }
<a name="l01054"></a>01054                     }
<a name="l01055"></a>01055                 }
<a name="l01056"></a>01056             }
<a name="l01057"></a>01057             <a class="code" href="group___vgrid.html#ga2f2ff1e7df77e0206d37df732d4bb4e9" title="Object destructor.">Vgrid_dtor</a>(&amp;grid);
<a name="l01058"></a>01058             <span class="keywordflow">break</span>;
<a name="l01059"></a>01059 
<a name="l01060"></a>01060         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605a985a38432d729cca6ff30859d56b1fe6">VDT_EDENS</a>:
<a name="l01061"></a>01061 
<a name="l01062"></a>01062             grid = <a class="code" href="group___vgrid.html#ga5ef6f1d4f8ace74fbf26318659f4948e" title="Construct Vgrid object with values obtained from Vpmg_readDX (for example)">Vgrid_ctor</a>(nx, ny, nz, hx, hy, hzed, xmin, ymin, zmin,
<a name="l01063"></a>01063               thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>);
<a name="l01064"></a>01064             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l01065"></a>01065                 <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l01066"></a>01066                     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l01067"></a>01067 
<a name="l01068"></a>01068                         position[0] = i*hx + xmin;
<a name="l01069"></a>01069                         position[1] = j*hy + ymin;
<a name="l01070"></a>01070                         position[2] = k*hzed + zmin;
<a name="l01071"></a>01071                         VASSERT(<a class="code" href="group___vgrid.html#ga74468f9a1d749f5573ea7f67c919abe9" title="Get first derivative values at a point.">Vgrid_gradient</a>(grid, position, grad));
<a name="l01072"></a>01072                         eps = epsp + (epss-epsp)*<a class="code" href="group___vacc.html#ga31a47b0e2a3e828ab38802dbebb07415" title="Report molecular accessibility.">Vacc_molAcc</a>(acc, position,
<a name="l01073"></a>01073                           pbe-&gt;<a class="code" href="structs_vpbe.html#ade790e68fbb69ba5054621cf0ec9f24c">solventRadius</a>);
<a name="l01074"></a>01074                         vec[IJK(i,j,k)] = 0.0;
<a name="l01075"></a>01075                         <span class="keywordflow">for</span> (l=0; l&lt;3; l++)
<a name="l01076"></a>01076                           vec[IJK(i,j,k)] += eps*VSQR(grad[l]);
<a name="l01077"></a>01077                     }
<a name="l01078"></a>01078                 }
<a name="l01079"></a>01079             }
<a name="l01080"></a>01080             <a class="code" href="group___vgrid.html#ga2f2ff1e7df77e0206d37df732d4bb4e9" title="Object destructor.">Vgrid_dtor</a>(&amp;grid);
<a name="l01081"></a>01081             <span class="keywordflow">break</span>;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605a1f38b0861fefd64ccf81c290224caef0">VDT_NDENS</a>:
<a name="l01084"></a>01084 
<a name="l01085"></a>01085             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l01086"></a>01086                 <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l01087"></a>01087                     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l01088"></a>01088 
<a name="l01089"></a>01089                         position[0] = i*hx + xmin;
<a name="l01090"></a>01090                         position[1] = j*hy + ymin;
<a name="l01091"></a>01091                         position[2] = k*hzed + zmin;
<a name="l01092"></a>01092                         vec[IJK(i,j,k)] = 0.0;
<a name="l01093"></a>01093                         <span class="keywordflow">if</span> ( VABS(<a class="code" href="group___vacc.html#ga050da431e776227898c5a7e7060d2202" title="Report inflated van der Waals accessibility.">Vacc_ivdwAcc</a>(acc,
<a name="l01094"></a>01094                                position, pbe-&gt;<a class="code" href="structs_vpbe.html#ad2c95924e6663fe49fbef89a5ade0248">maxIonRadius</a>) - 1.0) &lt; VSMALL) {
<a name="l01095"></a>01095                             <span class="keywordflow">for</span> (l=0; l&lt;pbe-&gt;<a class="code" href="structs_vpbe.html#a8f04230e38b5728bdad9daf37323f783">numIon</a>; l++) {
<a name="l01096"></a>01096                                 <span class="keywordflow">if</span> (pbetype == <a class="code" href="group___vhal.html#ggaa8a15d1df1766830ccc02f11c0b80154aae9324e651d3d2229e32620a66ab3d4e">PBE_NPBE</a> || pbetype == <a class="code" href="group___vhal.html#ggaa8a15d1df1766830ccc02f11c0b80154a55b89e584fbbe7e386f054adcf3efbd7">PBE_SMPBE</a> <span class="comment">/*  SMPBE Added */</span>) {
<a name="l01097"></a>01097                                     vec[IJK(i,j,k)] += (pbe-&gt;<a class="code" href="structs_vpbe.html#ae33e45044c553dd172e46c302ffeb0c8">ionConc</a>[l]
<a name="l01098"></a>01098                                         * <a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-pbe-&gt;<a class="code" href="structs_vpbe.html#afaf48998eac66e6e67c15ea20e41f22f">ionQ</a>[l]*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)],
<a name="l01099"></a>01099                                         &amp;ichop));
<a name="l01100"></a>01100                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pbetype == <a class="code" href="group___vhal.html#ggaa8a15d1df1766830ccc02f11c0b80154a8aff524083a4982a3b9b5a45100235f7">PBE_LPBE</a>){
<a name="l01101"></a>01101                                     vec[IJK(i,j,k)] += (pbe-&gt;<a class="code" href="structs_vpbe.html#ae33e45044c553dd172e46c302ffeb0c8">ionConc</a>[l]
<a name="l01102"></a>01102                                         * (1 - pbe-&gt;<a class="code" href="structs_vpbe.html#afaf48998eac66e6e67c15ea20e41f22f">ionQ</a>[l]*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)]));
<a name="l01103"></a>01103                                 }
<a name="l01104"></a>01104                             }
<a name="l01105"></a>01105                         }
<a name="l01106"></a>01106                     }
<a name="l01107"></a>01107                 }
<a name="l01108"></a>01108             }
<a name="l01109"></a>01109             <span class="keywordflow">break</span>;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga0737cad7c1ef6392a8cf959794d8a605ad901b47300f80e1ae4c19598a3c9179c">VDT_QDENS</a>:
<a name="l01112"></a>01112 
<a name="l01113"></a>01113             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l01114"></a>01114                 <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l01115"></a>01115                     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l01116"></a>01116 
<a name="l01117"></a>01117                         position[0] = i*hx + xmin;
<a name="l01118"></a>01118                         position[1] = j*hy + ymin;
<a name="l01119"></a>01119                         position[2] = k*hzed + zmin;
<a name="l01120"></a>01120                         vec[IJK(i,j,k)] = 0.0;
<a name="l01121"></a>01121                         <span class="keywordflow">if</span> ( VABS(<a class="code" href="group___vacc.html#ga050da431e776227898c5a7e7060d2202" title="Report inflated van der Waals accessibility.">Vacc_ivdwAcc</a>(acc,
<a name="l01122"></a>01122                                position, pbe-&gt;<a class="code" href="structs_vpbe.html#ad2c95924e6663fe49fbef89a5ade0248">maxIonRadius</a>) - 1.0) &lt; VSMALL) {
<a name="l01123"></a>01123                             <span class="keywordflow">for</span> (l=0; l&lt;pbe-&gt;<a class="code" href="structs_vpbe.html#a8f04230e38b5728bdad9daf37323f783">numIon</a>; l++) {
<a name="l01124"></a>01124                                 <span class="keywordflow">if</span> (pbetype == <a class="code" href="group___vhal.html#ggaa8a15d1df1766830ccc02f11c0b80154aae9324e651d3d2229e32620a66ab3d4e">PBE_NPBE</a> || pbetype == <a class="code" href="group___vhal.html#ggaa8a15d1df1766830ccc02f11c0b80154a55b89e584fbbe7e386f054adcf3efbd7">PBE_SMPBE</a> <span class="comment">/*  SMPBE Added */</span>) {
<a name="l01125"></a>01125                                     vec[IJK(i,j,k)] += (pbe-&gt;<a class="code" href="structs_vpbe.html#ae33e45044c553dd172e46c302ffeb0c8">ionConc</a>[l]
<a name="l01126"></a>01126                                         * pbe-&gt;<a class="code" href="structs_vpbe.html#afaf48998eac66e6e67c15ea20e41f22f">ionQ</a>[l]
<a name="l01127"></a>01127                                         * <a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-pbe-&gt;<a class="code" href="structs_vpbe.html#afaf48998eac66e6e67c15ea20e41f22f">ionQ</a>[l]*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)],
<a name="l01128"></a>01128                                         &amp;ichop));
<a name="l01129"></a>01129                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pbetype == <a class="code" href="group___vhal.html#ggaa8a15d1df1766830ccc02f11c0b80154a8aff524083a4982a3b9b5a45100235f7">PBE_LPBE</a>) {
<a name="l01130"></a>01130                                     vec[IJK(i,j,k)] += (pbe-&gt;<a class="code" href="structs_vpbe.html#ae33e45044c553dd172e46c302ffeb0c8">ionConc</a>[l]
<a name="l01131"></a>01131                                         * pbe-&gt;<a class="code" href="structs_vpbe.html#afaf48998eac66e6e67c15ea20e41f22f">ionQ</a>[l]
<a name="l01132"></a>01132                                         * (1 - pbe-&gt;<a class="code" href="structs_vpbe.html#afaf48998eac66e6e67c15ea20e41f22f">ionQ</a>[l]*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)]));
<a name="l01133"></a>01133                                 }
<a name="l01134"></a>01134                             }
<a name="l01135"></a>01135                         }
<a name="l01136"></a>01136                     }
<a name="l01137"></a>01137                 }
<a name="l01138"></a>01138             }
<a name="l01139"></a>01139             <span class="keywordflow">break</span>;
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         <span class="keywordflow">default</span>:
<a name="l01142"></a>01142 
<a name="l01143"></a>01143             Vnm_print(2, <span class="stringliteral">&quot;main:  Bogus data type (%d)!\n&quot;</span>, type);
<a name="l01144"></a>01144             <span class="keywordflow">return</span> 0;
<a name="l01145"></a>01145             <span class="keywordflow">break</span>;
<a name="l01146"></a>01146 
<a name="l01147"></a>01147     }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149     <span class="keywordflow">return</span> 1;
<a name="l01150"></a>01150 
<a name="l01151"></a>01151 }
<a name="l01152"></a>01152 
<a name="l01153"></a><a class="code" href="vpmg_8h.html#ae22a67401cf36cc85b0bd58938587913">01153</a> VPRIVATE <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#ae22a67401cf36cc85b0bd58938587913" title="Determines energy from polarizeable charge and interaction with fixed charges according to Rocchia et...">Vpmg_polarizEnergy</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01154"></a>01154                                    <span class="keywordtype">int</span> extFlag
<a name="l01155"></a>01155                                   ) {
<a name="l01156"></a>01156 
<a name="l01157"></a>01157     <span class="keywordtype">int</span> i,
<a name="l01158"></a>01158         j,
<a name="l01159"></a>01159         k,
<a name="l01160"></a>01160         ijk,
<a name="l01161"></a>01161         nx,
<a name="l01162"></a>01162         ny,
<a name="l01163"></a>01163         nz,
<a name="l01164"></a>01164         iatom;
<a name="l01165"></a>01165     <span class="keywordtype">double</span> xmin,
<a name="l01166"></a>01166            ymin,
<a name="l01167"></a>01167            zmin,
<a name="l01168"></a>01168            <span class="comment">//x, // gcc: not used</span>
<a name="l01169"></a>01169            <span class="comment">//y,</span>
<a name="l01170"></a>01170            <span class="comment">//z,</span>
<a name="l01171"></a>01171            hx,
<a name="l01172"></a>01172            hy,
<a name="l01173"></a>01173            hzed,
<a name="l01174"></a>01174            epsp,
<a name="l01175"></a>01175            lap,
<a name="l01176"></a>01176            pt[3],
<a name="l01177"></a>01177            T,
<a name="l01178"></a>01178            pre,
<a name="l01179"></a>01179            polq,
<a name="l01180"></a>01180            dist2,
<a name="l01181"></a>01181            dist,
<a name="l01182"></a>01182            energy,
<a name="l01183"></a>01183            q,
<a name="l01184"></a>01184            *charge,
<a name="l01185"></a>01185            *pos,
<a name="l01186"></a>01186            eps_w;
<a name="l01187"></a>01187     <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *potgrid;
<a name="l01188"></a>01188     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l01189"></a>01189     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l01190"></a>01190     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l01191"></a>01191 
<a name="l01192"></a>01192     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l01193"></a>01193     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l01194"></a>01194     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l01195"></a>01195     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01196"></a>01196     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01197"></a>01197     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01198"></a>01198     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01199"></a>01199     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01200"></a>01200     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01201"></a>01201     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l01202"></a>01202     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l01203"></a>01203     eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l01204"></a>01204     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l01205"></a>01205     charge = thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>;
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     <span class="comment">/* Calculate the prefactor for Coulombic calculations */</span>
<a name="l01208"></a>01208     T = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe);
<a name="l01209"></a>01209     pre = (<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*eps_w*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T);
<a name="l01210"></a>01210     pre = pre*(1.0e10);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212     <span class="comment">/* Set up Vgrid object with solution */</span>
<a name="l01213"></a>01213     potgrid = <a class="code" href="group___vgrid.html#ga5ef6f1d4f8ace74fbf26318659f4948e" title="Construct Vgrid object with values obtained from Vpmg_readDX (for example)">Vgrid_ctor</a>(nx, ny, nz, hx, hy, hzed, xmin, ymin, zmin, thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>);
<a name="l01214"></a>01214 
<a name="l01215"></a>01215     <span class="comment">/* Calculate polarization charge */</span>
<a name="l01216"></a>01216     energy = 0.0;
<a name="l01217"></a>01217     <span class="keywordflow">for</span> (i=1; i&lt;(nx-1); i++) {
<a name="l01218"></a>01218         pt[0] = xmin + hx*i;
<a name="l01219"></a>01219         <span class="keywordflow">for</span> (j=1; j&lt;(ny-1); j++) {
<a name="l01220"></a>01220             pt[1] = ymin + hy*j;
<a name="l01221"></a>01221             <span class="keywordflow">for</span> (k=1; k&lt;(nz-1); k++) {
<a name="l01222"></a>01222                 pt[2] = zmin + hzed*k;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224                 <span class="comment">/* Calculate polarization charge */</span>
<a name="l01225"></a>01225                 VASSERT(<a class="code" href="group___vgrid.html#gaababece8cabca6d17f714107c6afd8dd" title="Get second derivative values at a point.">Vgrid_curvature</a>(potgrid, pt, 1, &amp;lap));
<a name="l01226"></a>01226                 ijk = IJK(i,j,k);
<a name="l01227"></a>01227                 polq = charge[ijk] + epsp*lap*3.0;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229                 <span class="comment">/* Calculate interaction energy with atoms */</span>
<a name="l01230"></a>01230                 <span class="keywordflow">if</span> (VABS(polq) &gt; VSMALL) {
<a name="l01231"></a>01231                     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l01232"></a>01232                         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l01233"></a>01233                         q = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l01234"></a>01234                         pos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l01235"></a>01235                         dist2 = VSQR(pos[0]-pt[0]) + VSQR(pos[1]-pt[1]) \
<a name="l01236"></a>01236                                 + VSQR(pos[2]-pt[2]);
<a name="l01237"></a>01237                         dist = VSQRT(dist2);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239                         <span class="keywordflow">if</span> (dist &lt; VSMALL) {
<a name="l01240"></a>01240                             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_polarizEnergy:  atom on grid point; ignoring!\n&quot;</span>);
<a name="l01241"></a>01241                         } <span class="keywordflow">else</span> {
<a name="l01242"></a>01242                             energy = energy + polq*q/dist;
<a name="l01243"></a>01243                         }
<a name="l01244"></a>01244                     }
<a name="l01245"></a>01245                 }
<a name="l01246"></a>01246             }
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248     }
<a name="l01249"></a>01249 
<a name="l01250"></a>01250     <span class="keywordflow">return</span> pre*energy;
<a name="l01251"></a>01251 }
<a name="l01252"></a>01252 
<a name="l01253"></a><a class="code" href="group___vpmg.html#gad8cdc819e2c366c7b2da0afd20d9735b">01253</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="group___vpmg.html#gad8cdc819e2c366c7b2da0afd20d9735b" title="Get the total electrostatic energy.">Vpmg_energy</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01254"></a>01254                            <span class="keywordtype">int</span> extFlag
<a name="l01255"></a>01255                           ) {
<a name="l01256"></a>01256 
<a name="l01257"></a>01257     <span class="keywordtype">double</span> totEnergy = 0.0,
<a name="l01258"></a>01258            dielEnergy = 0.0,
<a name="l01259"></a>01259            qmEnergy = 0.0,
<a name="l01260"></a>01260            qfEnergy = 0.0;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     VASSERT(thee != VNULL);
<a name="l01263"></a>01263 
<a name="l01264"></a>01264     <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>) &amp;&amp; (<a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>) &gt; 0.)) {
<a name="l01265"></a>01265         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_energy:  calculating full PBE energy\n&quot;</span>);
<a name="l01266"></a>01266         qmEnergy = <a class="code" href="group___vpmg.html#gaa742b2c423bcb09628a84833a5f1e7ae" title="Get the &quot;mobile charge&quot; contribution to the electrostatic energy.">Vpmg_qmEnergy</a>(thee, extFlag);
<a name="l01267"></a>01267         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_energy:  qmEnergy = %1.12E kT\n&quot;</span>, qmEnergy);
<a name="l01268"></a>01268         qfEnergy = <a class="code" href="group___vpmg.html#gad1a07a9d24211983ddcbcbf67267fbfb" title="Get the &quot;fixed charge&quot; contribution to the electrostatic energy.">Vpmg_qfEnergy</a>(thee, extFlag);
<a name="l01269"></a>01269         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_energy:  qfEnergy = %1.12E kT\n&quot;</span>, qfEnergy);
<a name="l01270"></a>01270         dielEnergy = <a class="code" href="group___vpmg.html#ga855098121480f53fffc85f15b97cb88c" title="Get the &quot;polarization&quot; contribution to the electrostatic energy.">Vpmg_dielEnergy</a>(thee, extFlag);
<a name="l01271"></a>01271         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_energy:  dielEnergy = %1.12E kT\n&quot;</span>, dielEnergy);
<a name="l01272"></a>01272         totEnergy = qfEnergy - dielEnergy - qmEnergy;
<a name="l01273"></a>01273     } <span class="keywordflow">else</span> {
<a name="l01274"></a>01274         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_energy:  calculating only q-phi energy\n&quot;</span>);
<a name="l01275"></a>01275         qfEnergy = <a class="code" href="group___vpmg.html#gad1a07a9d24211983ddcbcbf67267fbfb" title="Get the &quot;fixed charge&quot; contribution to the electrostatic energy.">Vpmg_qfEnergy</a>(thee, extFlag);
<a name="l01276"></a>01276         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_energy:  qfEnergy = %1.12E kT\n&quot;</span>, qfEnergy);
<a name="l01277"></a>01277         totEnergy = 0.5*qfEnergy;
<a name="l01278"></a>01278     }
<a name="l01279"></a>01279 
<a name="l01280"></a>01280     <span class="keywordflow">return</span> totEnergy;
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 }
<a name="l01283"></a>01283 
<a name="l01284"></a><a class="code" href="group___vpmg.html#ga855098121480f53fffc85f15b97cb88c">01284</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="group___vpmg.html#ga855098121480f53fffc85f15b97cb88c" title="Get the &quot;polarization&quot; contribution to the electrostatic energy.">Vpmg_dielEnergy</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01285"></a>01285                                <span class="keywordtype">int</span> extFlag
<a name="l01286"></a>01286                               ) {
<a name="l01287"></a>01287 
<a name="l01288"></a>01288     <span class="keywordtype">double</span> hx,
<a name="l01289"></a>01289            hy,
<a name="l01290"></a>01290            hzed,
<a name="l01291"></a>01291            energy,
<a name="l01292"></a>01292            nrgx,
<a name="l01293"></a>01293            nrgy,
<a name="l01294"></a>01294            nrgz,
<a name="l01295"></a>01295            pvecx,
<a name="l01296"></a>01296            pvecy,
<a name="l01297"></a>01297            pvecz;
<a name="l01298"></a>01298     <span class="keywordtype">int</span> i,
<a name="l01299"></a>01299         j,
<a name="l01300"></a>01300         k,
<a name="l01301"></a>01301         nx,
<a name="l01302"></a>01302         ny,
<a name="l01303"></a>01303         nz;
<a name="l01304"></a>01304 
<a name="l01305"></a>01305     VASSERT(thee != VNULL);
<a name="l01306"></a>01306 
<a name="l01307"></a>01307     <span class="comment">/* Get the mesh information */</span>
<a name="l01308"></a>01308     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01309"></a>01309     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01310"></a>01310     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01311"></a>01311     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01312"></a>01312     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01313"></a>01313     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01314"></a>01314 
<a name="l01315"></a>01315     energy = 0.0;
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="keywordflow">if</span> (!thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>) {
<a name="l01318"></a>01318         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dielEnergy:  Need to call Vpmg_fillco!\n&quot;</span>);
<a name="l01319"></a>01319         VASSERT(0);
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321 
<a name="l01322"></a>01322     <span class="keywordflow">for</span> (k=0; k&lt;(nz-1); k++) {
<a name="l01323"></a>01323         <span class="keywordflow">for</span> (j=0; j&lt;(ny-1); j++) {
<a name="l01324"></a>01324             <span class="keywordflow">for</span> (i=0; i&lt;(nx-1); i++) {
<a name="l01325"></a>01325                 pvecx = 0.5*(thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)]+thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i+1,j,k)]);
<a name="l01326"></a>01326                 pvecy = 0.5*(thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)]+thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j+1,k)]);
<a name="l01327"></a>01327                 pvecz = 0.5*(thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)]+thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k+1)]);
<a name="l01328"></a>01328                 nrgx = thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)]*pvecx
<a name="l01329"></a>01329                   * VSQR((thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)]-thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i+1,j,k)])/hx);
<a name="l01330"></a>01330                 nrgy = thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)]*pvecy
<a name="l01331"></a>01331                   * VSQR((thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)]-thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j+1,k)])/hy);
<a name="l01332"></a>01332                 nrgz = thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)]*pvecz
<a name="l01333"></a>01333                   * VSQR((thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)]-thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k+1)])/hzed);
<a name="l01334"></a>01334                 energy += (nrgx + nrgy + nrgz);
<a name="l01335"></a>01335             }
<a name="l01336"></a>01336         }
<a name="l01337"></a>01337     }
<a name="l01338"></a>01338 
<a name="l01339"></a>01339     energy = 0.5*energy*hx*hy*hzed;
<a name="l01340"></a>01340     energy = energy/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l01341"></a>01341 
<a name="l01342"></a>01342     <span class="keywordflow">if</span> (extFlag == 1) energy += (thee-&gt;<a class="code" href="structs_vpmg.html#a76aee83486bc3b4a9f6352668d25d463">extDiEnergy</a>);
<a name="l01343"></a>01343 
<a name="l01344"></a>01344     <span class="keywordflow">return</span> energy;
<a name="l01345"></a>01345 }
<a name="l01346"></a>01346 
<a name="l01347"></a><a class="code" href="group___vpmg.html#ga30a8e156ba65cbbf6720b8a9ef688ef4">01347</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="group___vpmg.html#ga30a8e156ba65cbbf6720b8a9ef688ef4" title="Get the integral of the gradient of the dielectric function.">Vpmg_dielGradNorm</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l01348"></a>01348 
<a name="l01349"></a>01349     <span class="keywordtype">double</span> hx, hy, hzed, energy, nrgx, nrgy, nrgz, pvecx, pvecy, pvecz;
<a name="l01350"></a>01350     <span class="keywordtype">int</span> i, j, k, nx, ny, nz;
<a name="l01351"></a>01351 
<a name="l01352"></a>01352     VASSERT(thee != VNULL);
<a name="l01353"></a>01353 
<a name="l01354"></a>01354     <span class="comment">/* Get the mesh information */</span>
<a name="l01355"></a>01355     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01356"></a>01356     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01357"></a>01357     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01358"></a>01358     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01359"></a>01359     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01360"></a>01360     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01361"></a>01361 
<a name="l01362"></a>01362     energy = 0.0;
<a name="l01363"></a>01363 
<a name="l01364"></a>01364     <span class="keywordflow">if</span> (!thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>) {
<a name="l01365"></a>01365         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dielGradNorm:  Need to call Vpmg_fillco!\n&quot;</span>);
<a name="l01366"></a>01366         VASSERT(0);
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368 
<a name="l01369"></a>01369     <span class="keywordflow">for</span> (k=1; k&lt;nz; k++) {
<a name="l01370"></a>01370         <span class="keywordflow">for</span> (j=1; j&lt;ny; j++) {
<a name="l01371"></a>01371             <span class="keywordflow">for</span> (i=1; i&lt;nx; i++) {
<a name="l01372"></a>01372                 pvecx = 0.5*(thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)]+thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i-1,j,k)]);
<a name="l01373"></a>01373                 pvecy = 0.5*(thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)]+thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j-1,k)]);
<a name="l01374"></a>01374                 pvecz = 0.5*(thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)]+thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k-1)]);
<a name="l01375"></a>01375                 nrgx = pvecx
<a name="l01376"></a>01376                  * VSQR((thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)]-thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i-1,j,k)])/hx);
<a name="l01377"></a>01377                 nrgy = pvecy
<a name="l01378"></a>01378                  * VSQR((thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)]-thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j-1,k)])/hy);
<a name="l01379"></a>01379                 nrgz = pvecz
<a name="l01380"></a>01380                  * VSQR((thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)]-thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k-1)])/hzed);
<a name="l01381"></a>01381                 energy += VSQRT(nrgx + nrgy + nrgz);
<a name="l01382"></a>01382             }
<a name="l01383"></a>01383         }
<a name="l01384"></a>01384     }
<a name="l01385"></a>01385 
<a name="l01386"></a>01386     energy = energy*hx*hy*hzed;
<a name="l01387"></a>01387 
<a name="l01388"></a>01388     <span class="keywordflow">return</span> energy;
<a name="l01389"></a>01389 }
<a name="l01390"></a>01390 
<a name="l01391"></a><a class="code" href="group___vpmg.html#gaa742b2c423bcb09628a84833a5f1e7ae">01391</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="group___vpmg.html#gaa742b2c423bcb09628a84833a5f1e7ae" title="Get the &quot;mobile charge&quot; contribution to the electrostatic energy.">Vpmg_qmEnergy</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01392"></a>01392                              <span class="keywordtype">int</span> extFlag
<a name="l01393"></a>01393                             ) {
<a name="l01394"></a>01394 
<a name="l01395"></a>01395     <span class="keywordtype">double</span> energy;
<a name="l01396"></a>01396 
<a name="l01397"></a>01397     <span class="keywordflow">if</span>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a3f1bcd3a128e97bf445ce23fa55305e5">ipkey</a> == <a class="code" href="group___vhal.html#ggad16654551e609cdf34580c7722164d21a9cf856b3b07d357f63e8be09adc71a01">IPKEY_SMPBE</a>){
<a name="l01398"></a>01398         energy = <a class="code" href="vpmg_8c.html#aff52adddfe50ff4e6282f3bcf05f3dd5" title="Vpmg_qmEnergy for SMPBE.">Vpmg_qmEnergySMPBE</a>(thee,extFlag);
<a name="l01399"></a>01399     }<span class="keywordflow">else</span>{
<a name="l01400"></a>01400         energy = Vpmg_qmEnergyNONLIN(thee,extFlag);
<a name="l01401"></a>01401     }
<a name="l01402"></a>01402 
<a name="l01403"></a>01403     <span class="keywordflow">return</span> energy;
<a name="l01404"></a>01404 }
<a name="l01405"></a>01405 
<a name="l01406"></a>01406 VPRIVATE <span class="keywordtype">double</span> Vpmg_qmEnergyNONLIN(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01407"></a>01407                                     <span class="keywordtype">int</span> extFlag
<a name="l01408"></a>01408                                    ) {
<a name="l01409"></a>01409 
<a name="l01410"></a>01410     <span class="keywordtype">double</span> hx,
<a name="l01411"></a>01411            hy,
<a name="l01412"></a>01412            hzed,
<a name="l01413"></a>01413            energy,
<a name="l01414"></a>01414            ionConc[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>],
<a name="l01415"></a>01415            ionRadii[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>],
<a name="l01416"></a>01416            ionQ[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>],
<a name="l01417"></a>01417            zkappa2,
<a name="l01418"></a>01418            ionstr,
<a name="l01419"></a>01419            zks2;
<a name="l01420"></a>01420     <span class="keywordtype">int</span> i, <span class="comment">/* Loop variable */</span>
<a name="l01421"></a>01421         j,
<a name="l01422"></a>01422         nx,
<a name="l01423"></a>01423         ny,
<a name="l01424"></a>01424         nz,
<a name="l01425"></a>01425         nion,
<a name="l01426"></a>01426         ichop,
<a name="l01427"></a>01427         nchop,
<a name="l01428"></a>01428         len; <span class="comment">/* Stores number of iterations for loops to avoid multiple recalculations */</span>
<a name="l01429"></a>01429 
<a name="l01430"></a>01430     VASSERT(thee != VNULL);
<a name="l01431"></a>01431 
<a name="l01432"></a>01432     <span class="comment">/* Get the mesh information */</span>
<a name="l01433"></a>01433     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01434"></a>01434     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01435"></a>01435     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01436"></a>01436     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01437"></a>01437     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01438"></a>01438     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01439"></a>01439     zkappa2 = <a class="code" href="group___vpbe.html#ga56e38face81d2d29659541b5e3f5e442" title="Get modified squared Debye-Huckel parameter.">Vpbe_getZkappa2</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l01440"></a>01440     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442     <span class="comment">/* Bail if we&#39;re at zero ionic strength */</span>
<a name="l01443"></a>01443     <span class="keywordflow">if</span> (zkappa2 &lt; VSMALL) {
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="preprocessor">#ifndef VAPBSQUIET</span>
<a name="l01446"></a>01446 <span class="preprocessor"></span>        Vnm_print(0, <span class="stringliteral">&quot;Vpmg_qmEnergy:  Zero energy for zero ionic strength!\n&quot;</span>);
<a name="l01447"></a>01447 <span class="preprocessor">#endif</span>
<a name="l01448"></a>01448 <span class="preprocessor"></span>
<a name="l01449"></a>01449         <span class="keywordflow">return</span> 0.0;
<a name="l01450"></a>01450     }
<a name="l01451"></a>01451     zks2 = 0.5*zkappa2/ionstr;
<a name="l01452"></a>01452 
<a name="l01453"></a>01453     <span class="keywordflow">if</span> (!thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>) {
<a name="l01454"></a>01454         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qmEnergy:  Need to call Vpmg_fillco()!\n&quot;</span>);
<a name="l01455"></a>01455         VASSERT(0);
<a name="l01456"></a>01456     }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458     energy = 0.0;
<a name="l01459"></a>01459     nchop = 0;
<a name="l01460"></a>01460     <a class="code" href="group___vpbe.html#gae42c09bef7405779d87bce73c44e1ebf" title="Get information about the counterion species present.">Vpbe_getIons</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>, &amp;nion, ionConc, ionRadii, ionQ);
<a name="l01461"></a>01461     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>) {
<a name="l01462"></a>01462         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_qmEnergy:  Calculating nonlinear energy\n&quot;</span>);
<a name="l01463"></a>01463         <span class="keywordflow">for</span> (i=0, len=nx*ny*nz; i&lt;len; i++) {
<a name="l01464"></a>01464             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] &gt; VSMALL) {
<a name="l01465"></a>01465                 <span class="keywordflow">for</span> (j=0; j&lt;nion; j++) {
<a name="l01466"></a>01466                     energy += (thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i]*zks2
<a name="l01467"></a>01467                       * ionConc[j]
<a name="l01468"></a>01468                       * (<a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-ionQ[j]*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i], &amp;ichop)-1.0));
<a name="l01469"></a>01469                     nchop += ichop;
<a name="l01470"></a>01470                 }
<a name="l01471"></a>01471             }
<a name="l01472"></a>01472         }
<a name="l01473"></a>01473         <span class="keywordflow">if</span> (nchop &gt; 0){
<a name="l01474"></a>01474             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qmEnergy:  Chopped EXP %d times!\n&quot;</span>,nchop);
<a name="l01475"></a>01475             Vnm_print(2, <span class="stringliteral">&quot;\nERROR!  Detected large potential values in energy evaluation! \nERROR!  This calculation failed -- please report to the APBS developers!\n\n&quot;</span>);
<a name="l01476"></a>01476             VASSERT(0);
<a name="l01477"></a>01477         }
<a name="l01478"></a>01478     } <span class="keywordflow">else</span> {
<a name="l01479"></a>01479         <span class="comment">/* Zkappa2 OK here b/c LPBE approx */</span>
<a name="l01480"></a>01480         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_qmEnergy:  Calculating linear energy\n&quot;</span>);
<a name="l01481"></a>01481         <span class="keywordflow">for</span> (i=0, len=nx*ny*nz; i&lt;len; i++) {
<a name="l01482"></a>01482             <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] &gt; VSMALL)
<a name="l01483"></a>01483               energy += (thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*zkappa2*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i]*VSQR(thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i]));
<a name="l01484"></a>01484         }
<a name="l01485"></a>01485         energy = 0.5*energy;
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487     energy = energy*hx*hy*hzed;
<a name="l01488"></a>01488     energy = energy/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l01489"></a>01489 
<a name="l01490"></a>01490     <span class="keywordflow">if</span> (extFlag == 1) energy += thee-&gt;<a class="code" href="structs_vpmg.html#ab19b8dec8f40e3ceacb5d8f864c5dd3a">extQmEnergy</a>;
<a name="l01491"></a>01491 
<a name="l01492"></a>01492     <span class="keywordflow">return</span> energy;
<a name="l01493"></a>01493 }
<a name="l01494"></a>01494 
<a name="l01495"></a><a class="code" href="vpmg_8h.html#a9bbc2d7d63eea65e627e398cc05ee342">01495</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#aff52adddfe50ff4e6282f3bcf05f3dd5" title="Vpmg_qmEnergy for SMPBE.">Vpmg_qmEnergySMPBE</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01496"></a>01496                                   <span class="keywordtype">int</span> extFlag
<a name="l01497"></a>01497                                  ) {
<a name="l01498"></a>01498 
<a name="l01499"></a>01499     <span class="keywordtype">double</span> hx,
<a name="l01500"></a>01500            hy,
<a name="l01501"></a>01501            hzed,
<a name="l01502"></a>01502            energy,
<a name="l01503"></a>01503            ionConc[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>],
<a name="l01504"></a>01504            ionRadii[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>],
<a name="l01505"></a>01505            ionQ[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>],
<a name="l01506"></a>01506            zkappa2,
<a name="l01507"></a>01507            ionstr,
<a name="l01508"></a>01508            zks2;
<a name="l01509"></a>01509     <span class="keywordtype">int</span> i,
<a name="l01510"></a>01510         <span class="comment">//j, // gcc: not used</span>
<a name="l01511"></a>01511         nx,
<a name="l01512"></a>01512         ny,
<a name="l01513"></a>01513         nz,
<a name="l01514"></a>01514         nion,
<a name="l01515"></a>01515         <span class="comment">//ichop, // gcc: not used</span>
<a name="l01516"></a>01516         nchop,
<a name="l01517"></a>01517         len; <span class="comment">/* Loop variable */</span>
<a name="l01518"></a>01518 
<a name="l01519"></a>01519     <span class="comment">/* SMPB Modification (vchu, 09/21/06)*/</span>
<a name="l01520"></a>01520     <span class="comment">/* variable declarations for SMPB energy terms */</span>
<a name="l01521"></a>01521     <span class="keywordtype">double</span> a,
<a name="l01522"></a>01522            k,
<a name="l01523"></a>01523            z1,
<a name="l01524"></a>01524            z2,
<a name="l01525"></a>01525            z3,
<a name="l01526"></a>01526            cb1,
<a name="l01527"></a>01527            cb2,
<a name="l01528"></a>01528            cb3,
<a name="l01529"></a>01529            a1,
<a name="l01530"></a>01530            a2,
<a name="l01531"></a>01531            a3,
<a name="l01532"></a>01532            c1,
<a name="l01533"></a>01533            c2,
<a name="l01534"></a>01534            c3,
<a name="l01535"></a>01535            currEnergy,
<a name="l01536"></a>01536            fracOccA,
<a name="l01537"></a>01537            fracOccB,
<a name="l01538"></a>01538            fracOccC,
<a name="l01539"></a>01539            phi,
<a name="l01540"></a>01540            gpark,
<a name="l01541"></a>01541            denom;
<a name="l01542"></a>01542            <span class="comment">// Na; /**&lt; @todo remove if no conflicts are caused - This constant is already defined in vpde.h.  no need to redefine. */</span>
<a name="l01543"></a>01543     <span class="keywordtype">int</span> ichop1,
<a name="l01544"></a>01544         ichop2,
<a name="l01545"></a>01545         ichop3;
<a name="l01546"></a>01546 
<a name="l01547"></a>01547     VASSERT(thee != VNULL);
<a name="l01548"></a>01548 
<a name="l01549"></a>01549     <span class="comment">/* Get the mesh information */</span>
<a name="l01550"></a>01550     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01551"></a>01551     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01552"></a>01552     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01553"></a>01553     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01554"></a>01554     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01555"></a>01555     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01556"></a>01556     zkappa2 = <a class="code" href="group___vpbe.html#ga56e38face81d2d29659541b5e3f5e442" title="Get modified squared Debye-Huckel parameter.">Vpbe_getZkappa2</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l01557"></a>01557     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l01558"></a>01558 
<a name="l01559"></a>01559     <span class="comment">/* Bail if we&#39;re at zero ionic strength */</span>
<a name="l01560"></a>01560     <span class="keywordflow">if</span> (zkappa2 &lt; VSMALL) {
<a name="l01561"></a>01561 
<a name="l01562"></a>01562 <span class="preprocessor">#ifndef VAPBSQUIET</span>
<a name="l01563"></a>01563 <span class="preprocessor"></span>        Vnm_print(0, <span class="stringliteral">&quot;Vpmg_qmEnergySMPBE:  Zero energy for zero ionic strength!\n&quot;</span>);
<a name="l01564"></a>01564 <span class="preprocessor">#endif</span>
<a name="l01565"></a>01565 <span class="preprocessor"></span>
<a name="l01566"></a>01566         <span class="keywordflow">return</span> 0.0;
<a name="l01567"></a>01567     }
<a name="l01568"></a>01568     zks2 = 0.5*zkappa2/ionstr;
<a name="l01569"></a>01569 
<a name="l01570"></a>01570     <span class="keywordflow">if</span> (!thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>) {
<a name="l01571"></a>01571         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qmEnergySMPBE:  Need to call Vpmg_fillco()!\n&quot;</span>);
<a name="l01572"></a>01572         VASSERT(0);
<a name="l01573"></a>01573     }
<a name="l01574"></a>01574 
<a name="l01575"></a>01575     energy = 0.0;
<a name="l01576"></a>01576     nchop = 0;
<a name="l01577"></a>01577     <a class="code" href="group___vpbe.html#gae42c09bef7405779d87bce73c44e1ebf" title="Get information about the counterion species present.">Vpbe_getIons</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>, &amp;nion, ionConc, ionRadii, ionQ);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579     <span class="comment">/* SMPB Modification (vchu, 09/21/06) */</span>
<a name="l01580"></a>01580     <span class="comment">/* Extensive modification to the first part of the if statement</span>
<a name="l01581"></a>01581 <span class="comment">        where that handles the thee-&gt;pmgp-&gt;nonlin part. Basically, I&#39;ve</span>
<a name="l01582"></a>01582 <span class="comment">        deleted all of the original code and written my own code that computes</span>
<a name="l01583"></a>01583 <span class="comment">        the electrostatic free energy in the SMPB framework. Definitely really hacky</span>
<a name="l01584"></a>01584 <span class="comment">        at this stage of the game, but gets the job done. The second part of the</span>
<a name="l01585"></a>01585 <span class="comment">        if statement (the part that handles linear poisson-boltzmann) has been deleted</span>
<a name="l01586"></a>01586 <span class="comment">        because there will be no linearized SMPB energy.. */</span>
<a name="l01587"></a>01587 
<a name="l01588"></a>01588     z1 = ionQ[0];
<a name="l01589"></a>01589     z2 = ionQ[1];
<a name="l01590"></a>01590     z3 = ionQ[2];
<a name="l01591"></a>01591     cb1 = ionConc[0];
<a name="l01592"></a>01592     cb2 = ionConc[1];
<a name="l01593"></a>01593     cb3 = ionConc[2];
<a name="l01594"></a>01594     a  = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#aed52321725281a48a9a52440363f3f68">smvolume</a>;
<a name="l01595"></a>01595     k  = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a0329f3338754e5a8dd3ae0b556670c5f">smsize</a>;
<a name="l01596"></a>01596 
<a name="l01598"></a>01598     <span class="comment">// This constant is defined in vpde.h  Do not need to redefine</span>
<a name="l01599"></a>01599     <span class="comment">//Na = 6.022045000e-04; /* Converts from Molar to N/A^3 */</span>
<a name="l01600"></a>01600 
<a name="l01601"></a>01601     fracOccA = Na*cb1*VCUB(a);
<a name="l01602"></a>01602     fracOccB = Na*cb2*VCUB(a);
<a name="l01603"></a>01603     fracOccC = Na*cb3*VCUB(a);
<a name="l01604"></a>01604 
<a name="l01605"></a>01605     phi = (fracOccA/k) + fracOccB + fracOccC;
<a name="l01606"></a>01606 
<a name="l01607"></a>01607     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>) {
<a name="l01608"></a>01608         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_qmEnergySMPBE:  Calculating nonlinear energy using SMPB functional!\n&quot;</span>);
<a name="l01609"></a>01609         <span class="keywordflow">for</span> (i=0, len=nx*ny*nz; i&lt;len; i++) {
<a name="l01610"></a>01610             <span class="keywordflow">if</span> (((k-1) &gt; VSMALL) &amp;&amp; (thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] &gt; VSMALL)) {
<a name="l01611"></a>01611 
<a name="l01612"></a>01612                 a1 = <a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-1.0*z1*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i], &amp;ichop1);
<a name="l01613"></a>01613                 a2 = <a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-1.0*z2*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i], &amp;ichop2);
<a name="l01614"></a>01614                 a3 = <a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-1.0*z3*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i], &amp;ichop3);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616                 nchop += ichop1 + ichop2 + ichop3;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618                 gpark = (1 - phi + (fracOccA/k)*a1);
<a name="l01619"></a>01619                 denom = VPOW(gpark, k) + VPOW(1-fracOccB-fracOccC, k-1)*(fracOccB*a2+fracOccC*a3);
<a name="l01620"></a>01620 
<a name="l01621"></a>01621                 <span class="keywordflow">if</span> (cb1 &gt; VSMALL) {
<a name="l01622"></a>01622                     c1 = Na*cb1*VPOW(gpark, k-1)*a1/denom;
<a name="l01623"></a>01623                     <span class="keywordflow">if</span>(c1 != c1) c1 = 0.;
<a name="l01624"></a>01624                 } <span class="keywordflow">else</span> c1 = 0.;
<a name="l01625"></a>01625 
<a name="l01626"></a>01626                 <span class="keywordflow">if</span> (cb2 &gt; VSMALL) {
<a name="l01627"></a>01627                     c2 = Na*cb2*VPOW(1-fracOccB-fracOccC,k-1)*a2/denom;
<a name="l01628"></a>01628                     <span class="keywordflow">if</span>(c2 != c2) c2 = 0.;
<a name="l01629"></a>01629                 } <span class="keywordflow">else</span> c2 = 0.;
<a name="l01630"></a>01630 
<a name="l01631"></a>01631                 <span class="keywordflow">if</span> (cb3 &gt; VSMALL) {
<a name="l01632"></a>01632                     c3 = Na*cb3*VPOW(1-fracOccB-fracOccC,k-1)*a3/denom;
<a name="l01633"></a>01633                     <span class="keywordflow">if</span>(c3 != c3) c3 = 0.;
<a name="l01634"></a>01634                 } <span class="keywordflow">else</span> c3 = 0.;
<a name="l01635"></a>01635 
<a name="l01636"></a>01636                 currEnergy = k*VLOG((1-(c1*VCUB(a)/k)-c2*VCUB(a)-c3*VCUB(a))/(1-phi))
<a name="l01637"></a>01637                     -(k-1)*VLOG((1-c2*VCUB(a)-c3*VCUB(a))/(1-phi+(fracOccA/k)));
<a name="l01638"></a>01638 
<a name="l01639"></a>01639                 energy += thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i]*currEnergy;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] &gt; VSMALL){
<a name="l01642"></a>01642 
<a name="l01643"></a>01643                 a1 = <a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-1.0*z1*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i], &amp;ichop1);
<a name="l01644"></a>01644                 a2 = <a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-1.0*z2*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i], &amp;ichop2);
<a name="l01645"></a>01645                 a3 = <a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-1.0*z3*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i], &amp;ichop3);
<a name="l01646"></a>01646 
<a name="l01647"></a>01647                 nchop += ichop1 + ichop2 + ichop3;
<a name="l01648"></a>01648 
<a name="l01649"></a>01649                 gpark = (1 - phi + (fracOccA)*a1);
<a name="l01650"></a>01650                 denom = gpark + (fracOccB*a2+fracOccC*a3);
<a name="l01651"></a>01651 
<a name="l01652"></a>01652                 <span class="keywordflow">if</span> (cb1 &gt; VSMALL) {
<a name="l01653"></a>01653                     c1 = Na*cb1*a1/denom;
<a name="l01654"></a>01654                     <span class="keywordflow">if</span>(c1 != c1) c1 = 0.;
<a name="l01655"></a>01655                 } <span class="keywordflow">else</span> c1 = 0.;
<a name="l01656"></a>01656 
<a name="l01657"></a>01657                 <span class="keywordflow">if</span> (cb2 &gt; VSMALL) {
<a name="l01658"></a>01658                     c2 = Na*cb2*a2/denom;
<a name="l01659"></a>01659                     <span class="keywordflow">if</span>(c2 != c2) c2 = 0.;
<a name="l01660"></a>01660                 } <span class="keywordflow">else</span> c2 = 0.;
<a name="l01661"></a>01661 
<a name="l01662"></a>01662                 <span class="keywordflow">if</span> (cb3 &gt; VSMALL) {
<a name="l01663"></a>01663                     c3 = Na*cb3*a3/denom;
<a name="l01664"></a>01664                     <span class="keywordflow">if</span>(c3 != c3) c3 = 0.;
<a name="l01665"></a>01665                 } <span class="keywordflow">else</span> c3 = 0.;
<a name="l01666"></a>01666 
<a name="l01667"></a>01667                 currEnergy = VLOG((1-c1*VCUB(a)-c2*VCUB(a)-c3*VCUB(a))/(1-fracOccA-fracOccB-fracOccC));
<a name="l01668"></a>01668 
<a name="l01669"></a>01669                 energy += thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i]*currEnergy;
<a name="l01670"></a>01670             }
<a name="l01671"></a>01671         }
<a name="l01672"></a>01672 
<a name="l01673"></a>01673         energy = -energy/VCUB(a);
<a name="l01674"></a>01674 
<a name="l01675"></a>01675         <span class="keywordflow">if</span> (nchop &gt; 0) Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qmEnergySMPBE:  Chopped EXP %d times!\n&quot;</span>,
<a name="l01676"></a>01676                                  nchop);
<a name="l01677"></a>01677 
<a name="l01678"></a>01678     } <span class="keywordflow">else</span> {
<a name="l01679"></a>01679         <span class="comment">/* Zkappa2 OK here b/c LPBE approx */</span>
<a name="l01680"></a>01680         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_qmEnergySMPBE:  ERROR: NO LINEAR ENERGY!! Returning 0!\n&quot;</span>);
<a name="l01681"></a>01681 
<a name="l01682"></a>01682         energy = 0.0;
<a name="l01683"></a>01683 
<a name="l01684"></a>01684     }
<a name="l01685"></a>01685     energy = energy*hx*hy*hzed;
<a name="l01686"></a>01686 
<a name="l01687"></a>01687     <span class="keywordflow">if</span> (extFlag == 1) energy += thee-&gt;<a class="code" href="structs_vpmg.html#ab19b8dec8f40e3ceacb5d8f864c5dd3a">extQmEnergy</a>;
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     <span class="keywordflow">return</span> energy;
<a name="l01690"></a>01690 }
<a name="l01691"></a>01691 
<a name="l01692"></a><a class="code" href="group___vpmg.html#gad1a07a9d24211983ddcbcbf67267fbfb">01692</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="group___vpmg.html#gad1a07a9d24211983ddcbcbf67267fbfb" title="Get the &quot;fixed charge&quot; contribution to the electrostatic energy.">Vpmg_qfEnergy</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01693"></a>01693                              <span class="keywordtype">int</span> extFlag
<a name="l01694"></a>01694                             ) {
<a name="l01695"></a>01695 
<a name="l01696"></a>01696     <span class="keywordtype">double</span> energy = 0.0;
<a name="l01697"></a>01697 
<a name="l01698"></a>01698     VASSERT(thee != VNULL);
<a name="l01699"></a>01699 
<a name="l01700"></a>01700     <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a3e7c8b5aba81f00256dc7f302ed73722">useChargeMap</a>) || (thee-&gt;<a class="code" href="structs_vpmg.html#a6327432ac9805931a52cd96505836c35">chargeMeth</a> == <a class="code" href="group___vhal.html#gga3008c37bfa581864fd3dd8a61f10aa1cacd947c58b709cba6c3df8f56785db184">VCM_BSPL2</a>)) {
<a name="l01701"></a>01701         energy = <a class="code" href="vpmg_8c.html#a78687d08a4040d18d46337e1345b6dac" title="Calculates charge-potential energy as integral over a volume.">Vpmg_qfEnergyVolume</a>(thee, extFlag);
<a name="l01702"></a>01702     } <span class="keywordflow">else</span> {
<a name="l01703"></a>01703         energy = <a class="code" href="vpmg_8c.html#a0876512b1ee9f93ee0378334b886938c" title="Calculates charge-potential energy using summation over delta function positions (i.e. something like an Linf norm)">Vpmg_qfEnergyPoint</a>(thee, extFlag);
<a name="l01704"></a>01704     }
<a name="l01705"></a>01705 
<a name="l01706"></a>01706     <span class="keywordflow">return</span> energy;
<a name="l01707"></a>01707 }
<a name="l01708"></a>01708 
<a name="l01709"></a><a class="code" href="vpmg_8h.html#a0876512b1ee9f93ee0378334b886938c">01709</a> VPRIVATE <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#a0876512b1ee9f93ee0378334b886938c" title="Calculates charge-potential energy using summation over delta function positions (i.e. something like an Linf norm)">Vpmg_qfEnergyPoint</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01710"></a>01710                                    <span class="keywordtype">int</span> extFlag
<a name="l01711"></a>01711                                   ) {
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     <span class="keywordtype">int</span> iatom, nx, ny, nz, ihi, ilo, jhi, jlo, khi, klo;
<a name="l01714"></a>01714     <span class="keywordtype">double</span> xmax, ymax, zmax, xmin, ymin, zmin, hx, hy, hzed, ifloat, jfloat;
<a name="l01715"></a>01715     <span class="keywordtype">double</span> charge, kfloat, dx, dy, dz, energy, uval, *position;
<a name="l01716"></a>01716     <span class="keywordtype">double</span> *u;
<a name="l01717"></a>01717     <span class="keywordtype">double</span> *pvec;
<a name="l01718"></a>01718     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l01719"></a>01719     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l01720"></a>01720     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l01721"></a>01721 
<a name="l01722"></a>01722     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l01723"></a>01723     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l01724"></a>01724     VASSERT(alist != VNULL);
<a name="l01725"></a>01725 
<a name="l01726"></a>01726     <span class="comment">/* Get the mesh information */</span>
<a name="l01727"></a>01727     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01728"></a>01728     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01729"></a>01729     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01730"></a>01730     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01731"></a>01731     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01732"></a>01732     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01733"></a>01733     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l01734"></a>01734     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l01735"></a>01735     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l01736"></a>01736     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l01737"></a>01737     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l01738"></a>01738     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l01739"></a>01739 
<a name="l01740"></a>01740     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l01741"></a>01741     pvec = thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>;
<a name="l01742"></a>01742 
<a name="l01743"></a>01743     energy = 0.0;
<a name="l01744"></a>01744 
<a name="l01745"></a>01745     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l01746"></a>01746 
<a name="l01747"></a>01747         <span class="comment">/* Get atomic information */</span>
<a name="l01748"></a>01748         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750         position = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l01751"></a>01751         charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l01752"></a>01752 
<a name="l01753"></a>01753         <span class="comment">/* Figure out which vertices we&#39;re next to */</span>
<a name="l01754"></a>01754         ifloat = (position[0] - xmin)/hx;
<a name="l01755"></a>01755         jfloat = (position[1] - ymin)/hy;
<a name="l01756"></a>01756         kfloat = (position[2] - zmin)/hzed;
<a name="l01757"></a>01757         ihi = (int)ceil(ifloat);
<a name="l01758"></a>01758         ilo = (int)floor(ifloat);
<a name="l01759"></a>01759         jhi = (int)ceil(jfloat);
<a name="l01760"></a>01760         jlo = (int)floor(jfloat);
<a name="l01761"></a>01761         khi = (int)ceil(kfloat);
<a name="l01762"></a>01762         klo = (int)floor(kfloat);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764         <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> &gt; 0) {
<a name="l01765"></a>01765 
<a name="l01766"></a>01766             <span class="keywordflow">if</span> ((ihi&lt;nx) &amp;&amp; (jhi&lt;ny) &amp;&amp; (khi&lt;nz) &amp;&amp;
<a name="l01767"></a>01767                 (ilo&gt;=0) &amp;&amp; (jlo&gt;=0) &amp;&amp; (klo&gt;=0)) {
<a name="l01768"></a>01768 
<a name="l01769"></a>01769                 <span class="comment">/* Now get trilinear interpolation constants */</span>
<a name="l01770"></a>01770                 dx = ifloat - (double)(ilo);
<a name="l01771"></a>01771                 dy = jfloat - (double)(jlo);
<a name="l01772"></a>01772                 dz = kfloat - (double)(klo);
<a name="l01773"></a>01773                 uval =
<a name="l01774"></a>01774                   dx*dy*dz*u[IJK(ihi,jhi,khi)]
<a name="l01775"></a>01775                 + dx*(1.0-dy)*dz*u[IJK(ihi,jlo,khi)]
<a name="l01776"></a>01776                 + dx*dy*(1.0-dz)*u[IJK(ihi,jhi,klo)]
<a name="l01777"></a>01777                 + dx*(1.0-dy)*(1.0-dz)*u[IJK(ihi,jlo,klo)]
<a name="l01778"></a>01778                 + (1.0-dx)*dy*dz*u[IJK(ilo,jhi,khi)]
<a name="l01779"></a>01779                 + (1.0-dx)*(1.0-dy)*dz*u[IJK(ilo,jlo,khi)]
<a name="l01780"></a>01780                 + (1.0-dx)*dy*(1.0-dz)*u[IJK(ilo,jhi,klo)]
<a name="l01781"></a>01781                 + (1.0-dx)*(1.0-dy)*(1.0-dz)*u[IJK(ilo,jlo,klo)];
<a name="l01782"></a>01782                 energy += (uval*charge*atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a>);
<a name="l01783"></a>01783             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) {
<a name="l01784"></a>01784                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfEnergy:  Atom #%d at (%4.3f, %4.3f, \</span>
<a name="l01785"></a>01785 <span class="stringliteral">%4.3f) is off the mesh (ignoring)!\n&quot;</span>,
<a name="l01786"></a>01786                 iatom, position[0], position[1], position[2]);
<a name="l01787"></a>01787             }
<a name="l01788"></a>01788         }
<a name="l01789"></a>01789     }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791     <span class="keywordflow">if</span> (extFlag) energy += thee-&gt;<a class="code" href="structs_vpmg.html#aefba7183c581d5dd81a716f5c65687dd">extQfEnergy</a>;
<a name="l01792"></a>01792 
<a name="l01793"></a>01793     <span class="keywordflow">return</span> energy;
<a name="l01794"></a>01794 }
<a name="l01795"></a>01795 
<a name="l01796"></a><a class="code" href="group___vpmg.html#ga8c76962bbd84a7b87f7bc27840bfb183">01796</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="group___vpmg.html#ga8c76962bbd84a7b87f7bc27840bfb183" title="Get the per-atom &quot;fixed charge&quot; contribution to the electrostatic energy.">Vpmg_qfAtomEnergy</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom) {
<a name="l01797"></a>01797 
<a name="l01798"></a>01798     <span class="keywordtype">int</span> nx, ny, nz, ihi, ilo, jhi, jlo, khi, klo;
<a name="l01799"></a>01799     <span class="keywordtype">double</span> xmax, xmin, ymax, ymin, zmax, zmin, hx, hy, hzed, ifloat, jfloat;
<a name="l01800"></a>01800     <span class="keywordtype">double</span> charge, kfloat, dx, dy, dz, energy, uval, *position;
<a name="l01801"></a>01801     <span class="keywordtype">double</span> *u;
<a name="l01802"></a>01802 
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     <span class="comment">/* Get the mesh information */</span>
<a name="l01805"></a>01805     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01806"></a>01806     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01807"></a>01807     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01808"></a>01808     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01809"></a>01809     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01810"></a>01810     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01811"></a>01811     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[nx-1];
<a name="l01812"></a>01812     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[ny-1];
<a name="l01813"></a>01813     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[nz-1];
<a name="l01814"></a>01814     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[0];
<a name="l01815"></a>01815     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[0];
<a name="l01816"></a>01816     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[0];
<a name="l01817"></a>01817 
<a name="l01818"></a>01818     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l01819"></a>01819 
<a name="l01820"></a>01820     energy = 0.0;
<a name="l01821"></a>01821 
<a name="l01822"></a>01822 
<a name="l01823"></a>01823     position = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l01824"></a>01824     charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l01825"></a>01825 
<a name="l01826"></a>01826     <span class="comment">/* Figure out which vertices we&#39;re next to */</span>
<a name="l01827"></a>01827     ifloat = (position[0] - xmin)/hx;
<a name="l01828"></a>01828     jfloat = (position[1] - ymin)/hy;
<a name="l01829"></a>01829     kfloat = (position[2] - zmin)/hzed;
<a name="l01830"></a>01830     ihi = (int)ceil(ifloat);
<a name="l01831"></a>01831     ilo = (int)floor(ifloat);
<a name="l01832"></a>01832     jhi = (int)ceil(jfloat);
<a name="l01833"></a>01833     jlo = (int)floor(jfloat);
<a name="l01834"></a>01834     khi = (int)ceil(kfloat);
<a name="l01835"></a>01835     klo = (int)floor(kfloat);
<a name="l01836"></a>01836 
<a name="l01837"></a>01837     <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> &gt; 0) {
<a name="l01838"></a>01838 
<a name="l01839"></a>01839         <span class="keywordflow">if</span> ((ihi&lt;nx) &amp;&amp; (jhi&lt;ny) &amp;&amp; (khi&lt;nz) &amp;&amp;
<a name="l01840"></a>01840             (ilo&gt;=0) &amp;&amp; (jlo&gt;=0) &amp;&amp; (klo&gt;=0)) {
<a name="l01841"></a>01841 
<a name="l01842"></a>01842             <span class="comment">/* Now get trilinear interpolation constants */</span>
<a name="l01843"></a>01843             dx = ifloat - (double)(ilo);
<a name="l01844"></a>01844             dy = jfloat - (double)(jlo);
<a name="l01845"></a>01845             dz = kfloat - (double)(klo);
<a name="l01846"></a>01846             uval =
<a name="l01847"></a>01847               dx*dy*dz*u[IJK(ihi,jhi,khi)]
<a name="l01848"></a>01848             + dx*(1.0-dy)*dz*u[IJK(ihi,jlo,khi)]
<a name="l01849"></a>01849             + dx*dy*(1.0-dz)*u[IJK(ihi,jhi,klo)]
<a name="l01850"></a>01850             + dx*(1.0-dy)*(1.0-dz)*u[IJK(ihi,jlo,klo)]
<a name="l01851"></a>01851             + (1.0-dx)*dy*dz*u[IJK(ilo,jhi,khi)]
<a name="l01852"></a>01852             + (1.0-dx)*(1.0-dy)*dz*u[IJK(ilo,jlo,khi)]
<a name="l01853"></a>01853             + (1.0-dx)*dy*(1.0-dz)*u[IJK(ilo,jhi,klo)]
<a name="l01854"></a>01854             + (1.0-dx)*(1.0-dy)*(1.0-dz)*u[IJK(ilo,jlo,klo)];
<a name="l01855"></a>01855             energy += (uval*charge*atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a>);
<a name="l01856"></a>01856         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) {
<a name="l01857"></a>01857             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfAtomEnergy:  Atom at (%4.3f, %4.3f, \</span>
<a name="l01858"></a>01858 <span class="stringliteral">%4.3f) is off the mesh (ignoring)!\n&quot;</span>,
<a name="l01859"></a>01859             position[0], position[1], position[2]);
<a name="l01860"></a>01860         }
<a name="l01861"></a>01861     }
<a name="l01862"></a>01862 
<a name="l01863"></a>01863     <span class="keywordflow">return</span> energy;
<a name="l01864"></a>01864 }
<a name="l01865"></a>01865 
<a name="l01866"></a><a class="code" href="vpmg_8h.html#a78687d08a4040d18d46337e1345b6dac">01866</a> VPRIVATE <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#a78687d08a4040d18d46337e1345b6dac" title="Calculates charge-potential energy as integral over a volume.">Vpmg_qfEnergyVolume</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">int</span> extFlag) {
<a name="l01867"></a>01867 
<a name="l01868"></a>01868     <span class="keywordtype">double</span> hx, hy, hzed, energy;
<a name="l01869"></a>01869     <span class="keywordtype">int</span> i, nx, ny, nz;
<a name="l01870"></a>01870 
<a name="l01871"></a>01871     VASSERT(thee != VNULL);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873     <span class="comment">/* Get the mesh information */</span>
<a name="l01874"></a>01874     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01875"></a>01875     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01876"></a>01876     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01877"></a>01877     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01878"></a>01878     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01879"></a>01879     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01880"></a>01880 
<a name="l01881"></a>01881     <span class="keywordflow">if</span> (!thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>) {
<a name="l01882"></a>01882         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfEnergyVolume:  need to call Vpmg_fillco!\n&quot;</span>);
<a name="l01883"></a>01883         VASSERT(0);
<a name="l01884"></a>01884     }
<a name="l01885"></a>01885 
<a name="l01886"></a>01886     energy = 0.0;
<a name="l01887"></a>01887     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_qfEnergyVolume:  Calculating energy\n&quot;</span>);
<a name="l01888"></a>01888     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) {
<a name="l01889"></a>01889         energy += (thee-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i]*thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[i]);
<a name="l01890"></a>01890     }
<a name="l01891"></a>01891     energy = energy*hx*hy*hzed/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l01892"></a>01892 
<a name="l01893"></a>01893     <span class="keywordflow">if</span> (extFlag == 1) energy += thee-&gt;<a class="code" href="structs_vpmg.html#aefba7183c581d5dd81a716f5c65687dd">extQfEnergy</a>;
<a name="l01894"></a>01894 
<a name="l01895"></a>01895     <span class="keywordflow">return</span> energy;
<a name="l01896"></a>01896 }
<a name="l01897"></a>01897 
<a name="l01898"></a><a class="code" href="vpmg_8h.html#a1271687db8aa07b73c4ce3316943b72c">01898</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(<span class="keywordtype">int</span> srfm,<a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc,<span class="keywordtype">double</span> *gpos,<span class="keywordtype">double</span> win,
<a name="l01899"></a>01899                                       <span class="keywordtype">double</span> infrad,<a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom,<span class="keywordtype">double</span> *force){
<a name="l01900"></a>01900 
<a name="l01901"></a>01901     <span class="keywordflow">switch</span> (srfm) {
<a name="l01902"></a>01902         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8abf8efa6fb4b60ce37f33598a7fd4d8e0">VSM_SPLINE</a> :
<a name="l01903"></a>01903             <a class="code" href="group___vacc.html#ga02bc1d0af5c35f2f5acaecf4f6b46449" title="Report gradient of spline-based accessibility with respect to a particular atom normalized by the acc...">Vacc_splineAccGradAtomNorm</a>(acc, gpos, win, infrad, atom, force);
<a name="l01904"></a>01904             <span class="keywordflow">break</span>;
<a name="l01905"></a>01905         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8a03532041240be6ec5531304c179cf921">VSM_SPLINE3</a>:
<a name="l01906"></a>01906             <a class="code" href="group___vacc.html#ga406f82703bc43217e0e39412e2e780c4" title="Report gradient of spline-based accessibility with respect to a particular atom normalized by a 3rd o...">Vacc_splineAccGradAtomNorm3</a>(acc, gpos, win, infrad, atom, force);
<a name="l01907"></a>01907             <span class="keywordflow">break</span>;
<a name="l01908"></a>01908         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8ab38c84c490653dab4a075d30cfb2c955">VSM_SPLINE4</a> :
<a name="l01909"></a>01909             <a class="code" href="group___vacc.html#gad3f1efb0d9af322e255746a09ac674d2" title="Report gradient of spline-based accessibility with respect to a particular atom normalized by a 4th o...">Vacc_splineAccGradAtomNorm4</a>(acc, gpos, win, infrad, atom, force);
<a name="l01910"></a>01910             <span class="keywordflow">break</span>;
<a name="l01911"></a>01911         <span class="keywordflow">default</span>:
<a name="l01912"></a>01912             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbnbForce: Unknown surface method.\n&quot;</span>);
<a name="l01913"></a>01913             <span class="keywordflow">return</span>;
<a name="l01914"></a>01914     }
<a name="l01915"></a>01915 
<a name="l01916"></a>01916     <span class="keywordflow">return</span>;
<a name="l01917"></a>01917 }
<a name="l01918"></a>01918 
<a name="l01919"></a>01919 VPRIVATE <span class="keywordtype">void</span> focusFillBound(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l01920"></a>01920                              <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *pmgOLD
<a name="l01921"></a>01921                             ) {
<a name="l01922"></a>01922 
<a name="l01923"></a>01923     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l01924"></a>01924     <span class="keywordtype">double</span> hxOLD,
<a name="l01925"></a>01925            hyOLD,
<a name="l01926"></a>01926            hzOLD,
<a name="l01927"></a>01927            xminOLD,
<a name="l01928"></a>01928            yminOLD,
<a name="l01929"></a>01929            zminOLD,
<a name="l01930"></a>01930            xmaxOLD,
<a name="l01931"></a>01931            ymaxOLD,
<a name="l01932"></a>01932            zmaxOLD,
<a name="l01933"></a>01933            hxNEW,
<a name="l01934"></a>01934            hyNEW,
<a name="l01935"></a>01935            hzNEW,
<a name="l01936"></a>01936            xminNEW,
<a name="l01937"></a>01937            yminNEW,
<a name="l01938"></a>01938            zminNEW,
<a name="l01939"></a>01939            xmaxNEW,
<a name="l01940"></a>01940            ymaxNEW,
<a name="l01941"></a>01941            zmaxNEW,
<a name="l01942"></a>01942            x,
<a name="l01943"></a>01943            y,
<a name="l01944"></a>01944            z,
<a name="l01945"></a>01945            dx,
<a name="l01946"></a>01946            dy,
<a name="l01947"></a>01947            dz,
<a name="l01948"></a>01948            ifloat,
<a name="l01949"></a>01949            jfloat,
<a name="l01950"></a>01950            kfloat,
<a name="l01951"></a>01951            uval,
<a name="l01952"></a>01952            eps_w,
<a name="l01953"></a>01953            T,
<a name="l01954"></a>01954            pre1,
<a name="l01955"></a>01955            xkappa,
<a name="l01956"></a>01956            size,
<a name="l01957"></a>01957            *apos,
<a name="l01958"></a>01958            charge,
<a name="l01959"></a>01959            <span class="comment">//pos[3], // gcc: not used</span>
<a name="l01960"></a>01960            uvalMin,
<a name="l01961"></a>01961            uvalMax,
<a name="l01962"></a>01962            *data;
<a name="l01963"></a>01963     <span class="keywordtype">int</span> nxOLD,
<a name="l01964"></a>01964         nyOLD,
<a name="l01965"></a>01965         nzOLD,
<a name="l01966"></a>01966         nxNEW,
<a name="l01967"></a>01967         nyNEW,
<a name="l01968"></a>01968         nzNEW,
<a name="l01969"></a>01969         i,
<a name="l01970"></a>01970         j,
<a name="l01971"></a>01971         k,
<a name="l01972"></a>01972         ihi,
<a name="l01973"></a>01973         ilo,
<a name="l01974"></a>01974         jhi,
<a name="l01975"></a>01975         jlo,
<a name="l01976"></a>01976         khi,
<a name="l01977"></a>01977         klo,
<a name="l01978"></a>01978         nx,
<a name="l01979"></a>01979         ny,
<a name="l01980"></a>01980         nz;
<a name="l01981"></a>01981 
<a name="l01982"></a>01982     <span class="comment">/* Calculate new problem dimensions */</span>
<a name="l01983"></a>01983     hxNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l01984"></a>01984     hyNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l01985"></a>01985     hzNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l01986"></a>01986     nx =  thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01987"></a>01987     ny =  thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01988"></a>01988     nz =  thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01989"></a>01989     nxNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l01990"></a>01990     nyNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l01991"></a>01991     nzNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l01992"></a>01992     xminNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - ((double)(nxNEW-1)*hxNEW)/2.0;
<a name="l01993"></a>01993     xmaxNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + ((double)(nxNEW-1)*hxNEW)/2.0;
<a name="l01994"></a>01994     yminNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - ((double)(nyNEW-1)*hyNEW)/2.0;
<a name="l01995"></a>01995     ymaxNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + ((double)(nyNEW-1)*hyNEW)/2.0;
<a name="l01996"></a>01996     zminNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - ((double)(nzNEW-1)*hzNEW)/2.0;
<a name="l01997"></a>01997     zmaxNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + ((double)(nzNEW-1)*hzNEW)/2.0;
<a name="l01998"></a>01998 
<a name="l01999"></a>01999     <span class="keywordflow">if</span>(pmgOLD != VNULL){
<a name="l02000"></a>02000         <span class="comment">/* Relevant old problem parameters */</span>
<a name="l02001"></a>02001         hxOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l02002"></a>02002         hyOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l02003"></a>02003         hzOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l02004"></a>02004         nxOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l02005"></a>02005         nyOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l02006"></a>02006         nzOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l02007"></a>02007         xminOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - ((double)(nxOLD-1)*hxOLD)/2.0;
<a name="l02008"></a>02008         xmaxOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + ((double)(nxOLD-1)*hxOLD)/2.0;
<a name="l02009"></a>02009         yminOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - ((double)(nyOLD-1)*hyOLD)/2.0;
<a name="l02010"></a>02010         ymaxOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + ((double)(nyOLD-1)*hyOLD)/2.0;
<a name="l02011"></a>02011         zminOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - ((double)(nzOLD-1)*hzOLD)/2.0;
<a name="l02012"></a>02012         zmaxOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + ((double)(nzOLD-1)*hzOLD)/2.0;
<a name="l02013"></a>02013 
<a name="l02014"></a>02014         data = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l02015"></a>02015     }<span class="keywordflow">else</span>{
<a name="l02016"></a>02016         <span class="comment">/* Relevant old problem parameters */</span>
<a name="l02017"></a>02017         hxOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l02018"></a>02018         hyOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l02019"></a>02019         hzOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l02020"></a>02020         nxOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l02021"></a>02021         nyOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l02022"></a>02022         nzOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l02023"></a>02023         xminOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l02024"></a>02024         xmaxOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l02025"></a>02025         yminOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l02026"></a>02026         ymaxOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l02027"></a>02027         zminOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l02028"></a>02028         zmaxOLD = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l02029"></a>02029 
<a name="l02030"></a>02030         data = thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l02031"></a>02031     }
<a name="l02032"></a>02032     <span class="comment">/* BOUNDARY CONDITION SETUP FOR POINTS OFF OLD MESH:</span>
<a name="l02033"></a>02033 <span class="comment">     * For each &quot;atom&quot; (only one for bcfl=1), we use the following formula to</span>
<a name="l02034"></a>02034 <span class="comment">     * calculate the boundary conditions:</span>
<a name="l02035"></a>02035 <span class="comment">     *    g(x) = \frac{q e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l02036"></a>02036 <span class="comment">     *          * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l02037"></a>02037 <span class="comment">     *          * 1/d</span>
<a name="l02038"></a>02038 <span class="comment">     * where d = ||x - x_0|| (in m) and a is the size of the atom (in m).</span>
<a name="l02039"></a>02039 <span class="comment">     * We only need to evaluate some of these prefactors once:</span>
<a name="l02040"></a>02040 <span class="comment">     *    pre1 = \frac{e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l02041"></a>02041 <span class="comment">     * which gives the potential as</span>
<a name="l02042"></a>02042 <span class="comment">     *    g(x) = pre1 * q/d * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l02043"></a>02043 <span class="comment">     */</span>
<a name="l02044"></a>02044     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l02045"></a>02045     eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l02046"></a>02046     T = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe);               <span class="comment">/* K             */</span>
<a name="l02047"></a>02047     pre1 = (<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*eps_w*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T);
<a name="l02048"></a>02048 
<a name="l02049"></a>02049     <span class="comment">/* Finally, if we convert keep xkappa in A^{-1} and scale pre1 by</span>
<a name="l02050"></a>02050 <span class="comment">     * m/A, then we will only need to deal with distances and sizes in</span>
<a name="l02051"></a>02051 <span class="comment">     * Angstroms rather than meters.                                       */</span>
<a name="l02052"></a>02052     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);              <span class="comment">/* A^{-1}        */</span>
<a name="l02053"></a>02053     pre1 = pre1*(1.0e10);
<a name="l02054"></a>02054     size = <a class="code" href="group___vpbe.html#gabc3d4ee6a7571b191b583e2b49d1742a" title="Get sphere radius which bounds biomolecule.">Vpbe_getSoluteRadius</a>(pbe);
<a name="l02055"></a>02055     apos = <a class="code" href="group___vpbe.html#ga8003268df05a845c934fa8be679f834c" title="Get coordinates of solute center.">Vpbe_getSoluteCenter</a>(pbe);
<a name="l02056"></a>02056     charge = <a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*<a class="code" href="group___vpbe.html#ga01c5a2b2f1401b1ca4ec1918a50e255f" title="Get total solute charge.">Vpbe_getSoluteCharge</a>(pbe);
<a name="l02057"></a>02057 
<a name="l02058"></a>02058     <span class="comment">/* Check for rounding error */</span>
<a name="l02059"></a>02059     <span class="keywordflow">if</span> (VABS(xminOLD-xminNEW) &lt; VSMALL) xminNEW = xminOLD;
<a name="l02060"></a>02060     <span class="keywordflow">if</span> (VABS(xmaxOLD-xmaxNEW) &lt; VSMALL) xmaxNEW = xmaxOLD;
<a name="l02061"></a>02061     <span class="keywordflow">if</span> (VABS(yminOLD-yminNEW) &lt; VSMALL) yminNEW = yminOLD;
<a name="l02062"></a>02062     <span class="keywordflow">if</span> (VABS(ymaxOLD-ymaxNEW) &lt; VSMALL) ymaxNEW = ymaxOLD;
<a name="l02063"></a>02063     <span class="keywordflow">if</span> (VABS(zminOLD-zminNEW) &lt; VSMALL) zminNEW = zminOLD;
<a name="l02064"></a>02064     <span class="keywordflow">if</span> (VABS(zmaxOLD-zmaxNEW) &lt; VSMALL) zmaxNEW = zmaxOLD;
<a name="l02065"></a>02065 
<a name="l02066"></a>02066 
<a name="l02067"></a>02067     <span class="comment">/* Sanity check: make sure we&#39;re within the old mesh */</span>
<a name="l02068"></a>02068     Vnm_print(0, <span class="stringliteral">&quot;VPMG::focusFillBound -- New mesh mins = %g, %g, %g\n&quot;</span>,
<a name="l02069"></a>02069               xminNEW, yminNEW, zminNEW);
<a name="l02070"></a>02070     Vnm_print(0, <span class="stringliteral">&quot;VPMG::focusFillBound -- New mesh maxs = %g, %g, %g\n&quot;</span>,
<a name="l02071"></a>02071               xmaxNEW, ymaxNEW, zmaxNEW);
<a name="l02072"></a>02072     Vnm_print(0, <span class="stringliteral">&quot;VPMG::focusFillBound -- Old mesh mins = %g, %g, %g\n&quot;</span>,
<a name="l02073"></a>02073               xminOLD, yminOLD, zminOLD);
<a name="l02074"></a>02074     Vnm_print(0, <span class="stringliteral">&quot;VPMG::focusFillBound -- Old mesh maxs = %g, %g, %g\n&quot;</span>,
<a name="l02075"></a>02075               xmaxOLD, ymaxOLD, zmaxOLD);
<a name="l02076"></a>02076 
<a name="l02077"></a>02077     <span class="comment">/* The following is obsolete; we&#39;ll substitute analytical boundary</span>
<a name="l02078"></a>02078 <span class="comment">     * condition values when the new mesh falls outside the old */</span>
<a name="l02079"></a>02079     <span class="keywordflow">if</span> ((xmaxNEW&gt;xmaxOLD) || (ymaxNEW&gt;ymaxOLD) || (zmaxNEW&gt;zmaxOLD) ||
<a name="l02080"></a>02080         (xminOLD&gt;xminNEW) || (yminOLD&gt;yminNEW) || (zminOLD&gt;zminNEW)) {
<a name="l02081"></a>02081 
<a name="l02082"></a>02082         Vnm_print(2, <span class="stringliteral">&quot;Vpmg::focusFillBound -- new mesh not contained in old!\n&quot;</span>);
<a name="l02083"></a>02083         Vnm_print(2, <span class="stringliteral">&quot;Vpmg::focusFillBound -- old mesh min = (%g, %g, %g)\n&quot;</span>,
<a name="l02084"></a>02084                   xminOLD, yminOLD, zminOLD);
<a name="l02085"></a>02085         Vnm_print(2, <span class="stringliteral">&quot;Vpmg::focusFillBound -- old mesh max = (%g, %g, %g)\n&quot;</span>,
<a name="l02086"></a>02086                   xmaxOLD, ymaxOLD, zmaxOLD);
<a name="l02087"></a>02087         Vnm_print(2, <span class="stringliteral">&quot;Vpmg::focusFillBound -- new mesh min = (%g, %g, %g)\n&quot;</span>,
<a name="l02088"></a>02088                   xminNEW, yminNEW, zminNEW);
<a name="l02089"></a>02089         Vnm_print(2, <span class="stringliteral">&quot;Vpmg::focusFillBound -- new mesh max = (%g, %g, %g)\n&quot;</span>,
<a name="l02090"></a>02090                   xmaxNEW, ymaxNEW, zmaxNEW);
<a name="l02091"></a>02091         fflush(stderr);
<a name="l02092"></a>02092         VASSERT(0);
<a name="l02093"></a>02093     }
<a name="l02094"></a>02094 
<a name="l02095"></a>02095     uvalMin = <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>;
<a name="l02096"></a>02096     uvalMax = -<a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>;
<a name="l02097"></a>02097 
<a name="l02098"></a>02098     <span class="comment">/* Fill the &quot;i&quot; boundaries (dirichlet) */</span>
<a name="l02099"></a>02099     <span class="keywordflow">for</span> (k=0; k&lt;nzNEW; k++) {
<a name="l02100"></a>02100         <span class="keywordflow">for</span> (j=0; j&lt;nyNEW; j++) {
<a name="l02101"></a>02101             <span class="comment">/* Low X face */</span>
<a name="l02102"></a>02102             x = xminNEW;
<a name="l02103"></a>02103             y = yminNEW + j*hyNEW;
<a name="l02104"></a>02104             z = zminNEW + k*hzNEW;
<a name="l02105"></a>02105             <span class="keywordflow">if</span> ((x &gt;= (xminOLD-VSMALL)) &amp;&amp; (y &gt;= (yminOLD-VSMALL)) &amp;&amp; (z &gt;= (zminOLD-VSMALL)) &amp;&amp;
<a name="l02106"></a>02106                 (x &lt;= (xmaxOLD+VSMALL)) &amp;&amp; (y &lt;= (ymaxOLD+VSMALL)) &amp;&amp; (z &lt;= (zmaxOLD+VSMALL))) {
<a name="l02107"></a>02107                 ifloat = (x - xminOLD)/hxOLD;
<a name="l02108"></a>02108                 jfloat = (y - yminOLD)/hyOLD;
<a name="l02109"></a>02109                 kfloat = (z - zminOLD)/hzOLD;
<a name="l02110"></a>02110                 ihi = (int)ceil(ifloat);
<a name="l02111"></a>02111                 <span class="keywordflow">if</span> (ihi &gt; (nxOLD-1)) ihi = nxOLD-1;
<a name="l02112"></a>02112                 ilo = (int)floor(ifloat);
<a name="l02113"></a>02113                 <span class="keywordflow">if</span> (ilo &lt; 0) ilo = 0;
<a name="l02114"></a>02114                 jhi = (int)ceil(jfloat);
<a name="l02115"></a>02115                 <span class="keywordflow">if</span> (jhi &gt; (nyOLD-1)) jhi = nyOLD-1;
<a name="l02116"></a>02116                 jlo = (int)floor(jfloat);
<a name="l02117"></a>02117                 <span class="keywordflow">if</span> (jlo &lt; 0) jlo = 0;
<a name="l02118"></a>02118                 khi = (int)ceil(kfloat);
<a name="l02119"></a>02119                 <span class="keywordflow">if</span> (khi &gt; (nzOLD-1)) khi = nzOLD-1;
<a name="l02120"></a>02120                 klo = (int)floor(kfloat);
<a name="l02121"></a>02121                 <span class="keywordflow">if</span> (klo &lt; 0) klo = 0;
<a name="l02122"></a>02122                 dx = ifloat - (double)(ilo);
<a name="l02123"></a>02123                 dy = jfloat - (double)(jlo);
<a name="l02124"></a>02124                 dz = kfloat - (double)(klo);
<a name="l02125"></a>02125                 nx = nxOLD; ny = nyOLD; nz = nzOLD;
<a name="l02126"></a>02126                 uval =  dx*dy*dz*(data[IJK(ihi,jhi,khi)])
<a name="l02127"></a>02127                 + dx*(1.0-dy)*dz*(data[IJK(ihi,jlo,khi)])
<a name="l02128"></a>02128                 + dx*dy*(1.0-dz)*(data[IJK(ihi,jhi,klo)])
<a name="l02129"></a>02129                 + dx*(1.0-dy)*(1.0-dz)*(data[IJK(ihi,jlo,klo)])
<a name="l02130"></a>02130                 + (1.0-dx)*dy*dz*(data[IJK(ilo,jhi,khi)])
<a name="l02131"></a>02131                 + (1.0-dx)*(1.0-dy)*dz*(data[IJK(ilo,jlo,khi)])
<a name="l02132"></a>02132                 + (1.0-dx)*dy*(1.0-dz)*(data[IJK(ilo,jhi,klo)])
<a name="l02133"></a>02133                 + (1.0-dx)*(1.0-dy)*(1.0-dz)*(data[IJK(ilo,jlo,klo)]);
<a name="l02134"></a>02134                 nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02135"></a>02135             } <span class="keywordflow">else</span> {
<a name="l02136"></a>02136                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  Off old mesh at %g, %g \</span>
<a name="l02137"></a>02137 <span class="stringliteral">                          %g!\n&quot;</span>, __FILE__, __LINE__, x, y, z);
<a name="l02138"></a>02138                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh lower corner at \</span>
<a name="l02139"></a>02139 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xminOLD, yminOLD, zminOLD);
<a name="l02140"></a>02140                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh upper corner at \</span>
<a name="l02141"></a>02141 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xmaxOLD, ymaxOLD, zmaxOLD);
<a name="l02142"></a>02142                 VASSERT(0);
<a name="l02143"></a>02143             }
<a name="l02144"></a>02144             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02145"></a>02145             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,0)] = uval;
<a name="l02146"></a>02146             <span class="keywordflow">if</span>(uval &lt; uvalMin) uvalMin = uval;
<a name="l02147"></a>02147             <span class="keywordflow">if</span>(uval &gt; uvalMax) uvalMax = uval;
<a name="l02148"></a>02148 
<a name="l02149"></a>02149             <span class="comment">/* High X face */</span>
<a name="l02150"></a>02150             x = xmaxNEW;
<a name="l02151"></a>02151             <span class="keywordflow">if</span> ((x &gt;= (xminOLD-VSMALL)) &amp;&amp; (y &gt;= (yminOLD-VSMALL)) &amp;&amp; (z &gt;= (zminOLD-VSMALL)) &amp;&amp;
<a name="l02152"></a>02152                 (x &lt;= (xmaxOLD+VSMALL)) &amp;&amp; (y &lt;= (ymaxOLD+VSMALL)) &amp;&amp; (z &lt;= (zmaxOLD+VSMALL))) {
<a name="l02153"></a>02153                 ifloat = (x - xminOLD)/hxOLD;
<a name="l02154"></a>02154                 jfloat = (y - yminOLD)/hyOLD;
<a name="l02155"></a>02155                 kfloat = (z - zminOLD)/hzOLD;
<a name="l02156"></a>02156                 ihi = (int)ceil(ifloat);
<a name="l02157"></a>02157                 <span class="keywordflow">if</span> (ihi &gt; (nxOLD-1)) ihi = nxOLD-1;
<a name="l02158"></a>02158                 ilo = (int)floor(ifloat);
<a name="l02159"></a>02159                 <span class="keywordflow">if</span> (ilo &lt; 0) ilo = 0;
<a name="l02160"></a>02160                 jhi = (int)ceil(jfloat);
<a name="l02161"></a>02161                 <span class="keywordflow">if</span> (jhi &gt; (nyOLD-1)) jhi = nyOLD-1;
<a name="l02162"></a>02162                 jlo = (int)floor(jfloat);
<a name="l02163"></a>02163                 <span class="keywordflow">if</span> (jlo &lt; 0) jlo = 0;
<a name="l02164"></a>02164                 khi = (int)ceil(kfloat);
<a name="l02165"></a>02165                 <span class="keywordflow">if</span> (khi &gt; (nzOLD-1)) khi = nzOLD-1;
<a name="l02166"></a>02166                 klo = (int)floor(kfloat);
<a name="l02167"></a>02167                 <span class="keywordflow">if</span> (klo &lt; 0) klo = 0;
<a name="l02168"></a>02168                 dx = ifloat - (double)(ilo);
<a name="l02169"></a>02169                 dy = jfloat - (double)(jlo);
<a name="l02170"></a>02170                 dz = kfloat - (double)(klo);
<a name="l02171"></a>02171                 nx = nxOLD; ny = nyOLD; nz = nzOLD;
<a name="l02172"></a>02172                 uval =  dx*dy*dz*(data[IJK(ihi,jhi,khi)])
<a name="l02173"></a>02173                 + dx*(1.0-dy)*dz*(data[IJK(ihi,jlo,khi)])
<a name="l02174"></a>02174                 + dx*dy*(1.0-dz)*(data[IJK(ihi,jhi,klo)])
<a name="l02175"></a>02175                 + dx*(1.0-dy)*(1.0-dz)*(data[IJK(ihi,jlo,klo)])
<a name="l02176"></a>02176                 + (1.0-dx)*dy*dz*(data[IJK(ilo,jhi,khi)])
<a name="l02177"></a>02177                 + (1.0-dx)*(1.0-dy)*dz*(data[IJK(ilo,jlo,khi)])
<a name="l02178"></a>02178                 + (1.0-dx)*dy*(1.0-dz)*(data[IJK(ilo,jhi,klo)])
<a name="l02179"></a>02179                 + (1.0-dx)*(1.0-dy)*(1.0-dz)*(data[IJK(ilo,jlo,klo)]);
<a name="l02180"></a>02180                 nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02181"></a>02181             } <span class="keywordflow">else</span> {
<a name="l02182"></a>02182                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  Off old mesh at %g, %g \</span>
<a name="l02183"></a>02183 <span class="stringliteral">                          %g!\n&quot;</span>, __FILE__, __LINE__, x, y, z);
<a name="l02184"></a>02184                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh lower corner at \</span>
<a name="l02185"></a>02185 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xminOLD, yminOLD, zminOLD);
<a name="l02186"></a>02186                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh upper corner at \</span>
<a name="l02187"></a>02187 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xmaxOLD, ymaxOLD, zmaxOLD);
<a name="l02188"></a>02188                 VASSERT(0);
<a name="l02189"></a>02189             }
<a name="l02190"></a>02190             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02191"></a>02191             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,1)] = uval;
<a name="l02192"></a>02192             <span class="keywordflow">if</span>(uval &lt; uvalMin) uvalMin = uval;
<a name="l02193"></a>02193             <span class="keywordflow">if</span>(uval &gt; uvalMax) uvalMax = uval;
<a name="l02194"></a>02194 
<a name="l02195"></a>02195             <span class="comment">/* Zero Neumann conditions */</span>
<a name="l02196"></a>02196             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02197"></a>02197             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,2)] = 0.0;
<a name="l02198"></a>02198             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02199"></a>02199             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,3)] = 0.0;
<a name="l02200"></a>02200         }
<a name="l02201"></a>02201     }
<a name="l02202"></a>02202 
<a name="l02203"></a>02203     <span class="comment">/* Fill the &quot;j&quot; boundaries (dirichlet) */</span>
<a name="l02204"></a>02204     <span class="keywordflow">for</span> (k=0; k&lt;nzNEW; k++) {
<a name="l02205"></a>02205         <span class="keywordflow">for</span> (i=0; i&lt;nxNEW; i++) {
<a name="l02206"></a>02206             <span class="comment">/* Low Y face */</span>
<a name="l02207"></a>02207             x = xminNEW + i*hxNEW;
<a name="l02208"></a>02208             y = yminNEW;
<a name="l02209"></a>02209             z = zminNEW + k*hzNEW;
<a name="l02210"></a>02210             <span class="keywordflow">if</span> ((x &gt;= (xminOLD-VSMALL)) &amp;&amp; (y &gt;= (yminOLD-VSMALL)) &amp;&amp; (z &gt;= (zminOLD-VSMALL)) &amp;&amp;
<a name="l02211"></a>02211                 (x &lt;= (xmaxOLD+VSMALL)) &amp;&amp; (y &lt;= (ymaxOLD+VSMALL)) &amp;&amp; (z &lt;= (zmaxOLD+VSMALL))) {
<a name="l02212"></a>02212                 ifloat = (x - xminOLD)/hxOLD;
<a name="l02213"></a>02213                 jfloat = (y - yminOLD)/hyOLD;
<a name="l02214"></a>02214                 kfloat = (z - zminOLD)/hzOLD;
<a name="l02215"></a>02215                 ihi = (int)ceil(ifloat);
<a name="l02216"></a>02216                 <span class="keywordflow">if</span> (ihi &gt; (nxOLD-1)) ihi = nxOLD-1;
<a name="l02217"></a>02217                 ilo = (int)floor(ifloat);
<a name="l02218"></a>02218                 <span class="keywordflow">if</span> (ilo &lt; 0) ilo = 0;
<a name="l02219"></a>02219                 jhi = (int)ceil(jfloat);
<a name="l02220"></a>02220                 <span class="keywordflow">if</span> (jhi &gt; (nyOLD-1)) jhi = nyOLD-1;
<a name="l02221"></a>02221                 jlo = (int)floor(jfloat);
<a name="l02222"></a>02222                 <span class="keywordflow">if</span> (jlo &lt; 0) jlo = 0;
<a name="l02223"></a>02223                 khi = (int)ceil(kfloat);
<a name="l02224"></a>02224                 <span class="keywordflow">if</span> (khi &gt; (nzOLD-1)) khi = nzOLD-1;
<a name="l02225"></a>02225                 klo = (int)floor(kfloat);
<a name="l02226"></a>02226                 <span class="keywordflow">if</span> (klo &lt; 0) klo = 0;
<a name="l02227"></a>02227                 dx = ifloat - (double)(ilo);
<a name="l02228"></a>02228                 dy = jfloat - (double)(jlo);
<a name="l02229"></a>02229                 dz = kfloat - (double)(klo);
<a name="l02230"></a>02230                 nx = nxOLD; ny = nyOLD; nz = nzOLD;
<a name="l02231"></a>02231                 uval =  dx*dy*dz*(data[IJK(ihi,jhi,khi)])
<a name="l02232"></a>02232                 + dx*(1.0-dy)*dz*(data[IJK(ihi,jlo,khi)])
<a name="l02233"></a>02233                 + dx*dy*(1.0-dz)*(data[IJK(ihi,jhi,klo)])
<a name="l02234"></a>02234                 + dx*(1.0-dy)*(1.0-dz)*(data[IJK(ihi,jlo,klo)])
<a name="l02235"></a>02235                 + (1.0-dx)*dy*dz*(data[IJK(ilo,jhi,khi)])
<a name="l02236"></a>02236                 + (1.0-dx)*(1.0-dy)*dz*(data[IJK(ilo,jlo,khi)])
<a name="l02237"></a>02237                 + (1.0-dx)*dy*(1.0-dz)*(data[IJK(ilo,jhi,klo)])
<a name="l02238"></a>02238                 + (1.0-dx)*(1.0-dy)*(1.0-dz)*(data[IJK(ilo,jlo,klo)]);
<a name="l02239"></a>02239                 nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02240"></a>02240             } <span class="keywordflow">else</span> {
<a name="l02241"></a>02241                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  Off old mesh at %g, %g \</span>
<a name="l02242"></a>02242 <span class="stringliteral">                          %g!\n&quot;</span>, __FILE__, __LINE__, x, y, z);
<a name="l02243"></a>02243                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh lower corner at \</span>
<a name="l02244"></a>02244 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xminOLD, yminOLD, zminOLD);
<a name="l02245"></a>02245                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh upper corner at \</span>
<a name="l02246"></a>02246 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xmaxOLD, ymaxOLD, zmaxOLD);
<a name="l02247"></a>02247                 VASSERT(0);
<a name="l02248"></a>02248             }
<a name="l02249"></a>02249             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02250"></a>02250             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,0)] = uval;
<a name="l02251"></a>02251             <span class="keywordflow">if</span>(uval &lt; uvalMin) uvalMin = uval;
<a name="l02252"></a>02252             <span class="keywordflow">if</span>(uval &gt; uvalMax) uvalMax = uval;
<a name="l02253"></a>02253 
<a name="l02254"></a>02254             <span class="comment">/* High Y face */</span>
<a name="l02255"></a>02255             y = ymaxNEW;
<a name="l02256"></a>02256             <span class="keywordflow">if</span> ((x &gt;= (xminOLD-VSMALL)) &amp;&amp; (y &gt;= (yminOLD-VSMALL)) &amp;&amp; (z &gt;= (zminOLD-VSMALL)) &amp;&amp;
<a name="l02257"></a>02257                 (x &lt;= (xmaxOLD+VSMALL)) &amp;&amp; (y &lt;= (ymaxOLD+VSMALL)) &amp;&amp; (z &lt;= (zmaxOLD+VSMALL))) {
<a name="l02258"></a>02258                 ifloat = (x - xminOLD)/hxOLD;
<a name="l02259"></a>02259                 jfloat = (y - yminOLD)/hyOLD;
<a name="l02260"></a>02260                 kfloat = (z - zminOLD)/hzOLD;
<a name="l02261"></a>02261                 ihi = (int)ceil(ifloat);
<a name="l02262"></a>02262                 <span class="keywordflow">if</span> (ihi &gt; (nxOLD-1)) ihi = nxOLD-1;
<a name="l02263"></a>02263                 ilo = (int)floor(ifloat);
<a name="l02264"></a>02264                 <span class="keywordflow">if</span> (ilo &lt; 0) ilo = 0;
<a name="l02265"></a>02265                 jhi = (int)ceil(jfloat);
<a name="l02266"></a>02266                 <span class="keywordflow">if</span> (jhi &gt; (nyOLD-1)) jhi = nyOLD-1;
<a name="l02267"></a>02267                 jlo = (int)floor(jfloat);
<a name="l02268"></a>02268                 <span class="keywordflow">if</span> (jlo &lt; 0) jlo = 0;
<a name="l02269"></a>02269                 khi = (int)ceil(kfloat);
<a name="l02270"></a>02270                 <span class="keywordflow">if</span> (khi &gt; (nzOLD-1)) khi = nzOLD-1;
<a name="l02271"></a>02271                 klo = (int)floor(kfloat);
<a name="l02272"></a>02272                 <span class="keywordflow">if</span> (klo &lt; 0) klo = 0;
<a name="l02273"></a>02273                 dx = ifloat - (double)(ilo);
<a name="l02274"></a>02274                 dy = jfloat - (double)(jlo);
<a name="l02275"></a>02275                 dz = kfloat - (double)(klo);
<a name="l02276"></a>02276                 nx = nxOLD; ny = nyOLD; nz = nzOLD;
<a name="l02277"></a>02277                 uval =  dx*dy*dz*(data[IJK(ihi,jhi,khi)])
<a name="l02278"></a>02278                 + dx*(1.0-dy)*dz*(data[IJK(ihi,jlo,khi)])
<a name="l02279"></a>02279                 + dx*dy*(1.0-dz)*(data[IJK(ihi,jhi,klo)])
<a name="l02280"></a>02280                 + dx*(1.0-dy)*(1.0-dz)*(data[IJK(ihi,jlo,klo)])
<a name="l02281"></a>02281                 + (1.0-dx)*dy*dz*(data[IJK(ilo,jhi,khi)])
<a name="l02282"></a>02282                 + (1.0-dx)*(1.0-dy)*dz*(data[IJK(ilo,jlo,khi)])
<a name="l02283"></a>02283                 + (1.0-dx)*dy*(1.0-dz)*(data[IJK(ilo,jhi,klo)])
<a name="l02284"></a>02284                 + (1.0-dx)*(1.0-dy)*(1.0-dz)*(data[IJK(ilo,jlo,klo)]);
<a name="l02285"></a>02285                 nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02286"></a>02286             } <span class="keywordflow">else</span> {
<a name="l02287"></a>02287                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  Off old mesh at %g, %g \</span>
<a name="l02288"></a>02288 <span class="stringliteral">                          %g!\n&quot;</span>, __FILE__, __LINE__, x, y, z);
<a name="l02289"></a>02289                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh lower corner at \</span>
<a name="l02290"></a>02290 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xminOLD, yminOLD, zminOLD);
<a name="l02291"></a>02291                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh upper corner at \</span>
<a name="l02292"></a>02292 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xmaxOLD, ymaxOLD, zmaxOLD);
<a name="l02293"></a>02293                 VASSERT(0);
<a name="l02294"></a>02294             }
<a name="l02295"></a>02295             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02296"></a>02296             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,1)] = uval;
<a name="l02297"></a>02297             <span class="keywordflow">if</span>(uval &lt; uvalMin) uvalMin = uval;
<a name="l02298"></a>02298             <span class="keywordflow">if</span>(uval &gt; uvalMax) uvalMax = uval;
<a name="l02299"></a>02299 
<a name="l02300"></a>02300             <span class="comment">/* Zero Neumann conditions */</span>
<a name="l02301"></a>02301             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02302"></a>02302             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,2)] = 0.0;
<a name="l02303"></a>02303             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02304"></a>02304             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,3)] = 0.0;
<a name="l02305"></a>02305         }
<a name="l02306"></a>02306     }
<a name="l02307"></a>02307 
<a name="l02308"></a>02308     <span class="comment">/* Fill the &quot;k&quot; boundaries (dirichlet) */</span>
<a name="l02309"></a>02309     <span class="keywordflow">for</span> (j=0; j&lt;nyNEW; j++) {
<a name="l02310"></a>02310         <span class="keywordflow">for</span> (i=0; i&lt;nxNEW; i++) {
<a name="l02311"></a>02311             <span class="comment">/* Low Z face */</span>
<a name="l02312"></a>02312             x = xminNEW + i*hxNEW;
<a name="l02313"></a>02313             y = yminNEW + j*hyNEW;
<a name="l02314"></a>02314             z = zminNEW;
<a name="l02315"></a>02315             <span class="keywordflow">if</span> ((x &gt;= (xminOLD-VSMALL)) &amp;&amp; (y &gt;= (yminOLD-VSMALL)) &amp;&amp; (z &gt;= (zminOLD-VSMALL)) &amp;&amp;
<a name="l02316"></a>02316                 (x &lt;= (xmaxOLD+VSMALL)) &amp;&amp; (y &lt;= (ymaxOLD+VSMALL)) &amp;&amp; (z &lt;= (zmaxOLD+VSMALL))) {
<a name="l02317"></a>02317                 ifloat = (x - xminOLD)/hxOLD;
<a name="l02318"></a>02318                 jfloat = (y - yminOLD)/hyOLD;
<a name="l02319"></a>02319                 kfloat = (z - zminOLD)/hzOLD;
<a name="l02320"></a>02320                 ihi = (int)ceil(ifloat);
<a name="l02321"></a>02321                 <span class="keywordflow">if</span> (ihi &gt; (nxOLD-1)) ihi = nxOLD-1;
<a name="l02322"></a>02322                 ilo = (int)floor(ifloat);
<a name="l02323"></a>02323                 <span class="keywordflow">if</span> (ilo &lt; 0) ilo = 0;
<a name="l02324"></a>02324                 jhi = (int)ceil(jfloat);
<a name="l02325"></a>02325                 <span class="keywordflow">if</span> (jhi &gt; (nyOLD-1)) jhi = nyOLD-1;
<a name="l02326"></a>02326                 jlo = (int)floor(jfloat);
<a name="l02327"></a>02327                 <span class="keywordflow">if</span> (jlo &lt; 0) jlo = 0;
<a name="l02328"></a>02328                 khi = (int)ceil(kfloat);
<a name="l02329"></a>02329                 <span class="keywordflow">if</span> (khi &gt; (nzOLD-1)) khi = nzOLD-1;
<a name="l02330"></a>02330                 klo = (int)floor(kfloat);
<a name="l02331"></a>02331                 <span class="keywordflow">if</span> (klo &lt; 0) klo = 0;
<a name="l02332"></a>02332                 dx = ifloat - (double)(ilo);
<a name="l02333"></a>02333                 dy = jfloat - (double)(jlo);
<a name="l02334"></a>02334                 dz = kfloat - (double)(klo);
<a name="l02335"></a>02335                 nx = nxOLD; ny = nyOLD; nz = nzOLD;
<a name="l02336"></a>02336                 uval =  dx*dy*dz*(data[IJK(ihi,jhi,khi)])
<a name="l02337"></a>02337                 + dx*(1.0-dy)*dz*(data[IJK(ihi,jlo,khi)])
<a name="l02338"></a>02338                 + dx*dy*(1.0-dz)*(data[IJK(ihi,jhi,klo)])
<a name="l02339"></a>02339                 + dx*(1.0-dy)*(1.0-dz)*(data[IJK(ihi,jlo,klo)])
<a name="l02340"></a>02340                 + (1.0-dx)*dy*dz*(data[IJK(ilo,jhi,khi)])
<a name="l02341"></a>02341                 + (1.0-dx)*(1.0-dy)*dz*(data[IJK(ilo,jlo,khi)])
<a name="l02342"></a>02342                 + (1.0-dx)*dy*(1.0-dz)*(data[IJK(ilo,jhi,klo)])
<a name="l02343"></a>02343                 + (1.0-dx)*(1.0-dy)*(1.0-dz)*(data[IJK(ilo,jlo,klo)]);
<a name="l02344"></a>02344                 nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02345"></a>02345             } <span class="keywordflow">else</span> {
<a name="l02346"></a>02346                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  Off old mesh at %g, %g \</span>
<a name="l02347"></a>02347 <span class="stringliteral">                          %g!\n&quot;</span>, __FILE__, __LINE__, x, y, z);
<a name="l02348"></a>02348                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh lower corner at \</span>
<a name="l02349"></a>02349 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xminOLD, yminOLD, zminOLD);
<a name="l02350"></a>02350                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh upper corner at \</span>
<a name="l02351"></a>02351 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xmaxOLD, ymaxOLD, zmaxOLD);
<a name="l02352"></a>02352                 VASSERT(0);
<a name="l02353"></a>02353             }
<a name="l02354"></a>02354             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02355"></a>02355             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,0)] = uval;
<a name="l02356"></a>02356             <span class="keywordflow">if</span>(uval &lt; uvalMin) uvalMin = uval;
<a name="l02357"></a>02357             <span class="keywordflow">if</span>(uval &gt; uvalMax) uvalMax = uval;
<a name="l02358"></a>02358 
<a name="l02359"></a>02359             <span class="comment">/* High Z face */</span>
<a name="l02360"></a>02360             z = zmaxNEW;
<a name="l02361"></a>02361             <span class="keywordflow">if</span> ((x &gt;= (xminOLD-VSMALL)) &amp;&amp; (y &gt;= (yminOLD-VSMALL)) &amp;&amp; (z &gt;= (zminOLD-VSMALL)) &amp;&amp;
<a name="l02362"></a>02362                 (x &lt;= (xmaxOLD+VSMALL)) &amp;&amp; (y &lt;= (ymaxOLD+VSMALL)) &amp;&amp; (z &lt;= (zmaxOLD+VSMALL))) {
<a name="l02363"></a>02363                 ifloat = (x - xminOLD)/hxOLD;
<a name="l02364"></a>02364                 jfloat = (y - yminOLD)/hyOLD;
<a name="l02365"></a>02365                 kfloat = (z - zminOLD)/hzOLD;
<a name="l02366"></a>02366                 ihi = (int)ceil(ifloat);
<a name="l02367"></a>02367                 <span class="keywordflow">if</span> (ihi &gt; (nxOLD-1)) ihi = nxOLD-1;
<a name="l02368"></a>02368                 ilo = (int)floor(ifloat);
<a name="l02369"></a>02369                 <span class="keywordflow">if</span> (ilo &lt; 0) ilo = 0;
<a name="l02370"></a>02370                 jhi = (int)ceil(jfloat);
<a name="l02371"></a>02371                 <span class="keywordflow">if</span> (jhi &gt; (nyOLD-1)) jhi = nyOLD-1;
<a name="l02372"></a>02372                 jlo = (int)floor(jfloat);
<a name="l02373"></a>02373                 <span class="keywordflow">if</span> (jlo &lt; 0) jlo = 0;
<a name="l02374"></a>02374                 khi = (int)ceil(kfloat);
<a name="l02375"></a>02375                 <span class="keywordflow">if</span> (khi &gt; (nzOLD-1)) khi = nzOLD-1;
<a name="l02376"></a>02376                 klo = (int)floor(kfloat);
<a name="l02377"></a>02377                 <span class="keywordflow">if</span> (klo &lt; 0) klo = 0;
<a name="l02378"></a>02378                 dx = ifloat - (double)(ilo);
<a name="l02379"></a>02379                 dy = jfloat - (double)(jlo);
<a name="l02380"></a>02380                 dz = kfloat - (double)(klo);
<a name="l02381"></a>02381                 nx = nxOLD; ny = nyOLD; nz = nzOLD;
<a name="l02382"></a>02382                 uval =  dx*dy*dz*(data[IJK(ihi,jhi,khi)])
<a name="l02383"></a>02383                 + dx*(1.0-dy)*dz*(data[IJK(ihi,jlo,khi)])
<a name="l02384"></a>02384                 + dx*dy*(1.0-dz)*(data[IJK(ihi,jhi,klo)])
<a name="l02385"></a>02385                 + dx*(1.0-dy)*(1.0-dz)*(data[IJK(ihi,jlo,klo)])
<a name="l02386"></a>02386                 + (1.0-dx)*dy*dz*(data[IJK(ilo,jhi,khi)])
<a name="l02387"></a>02387                 + (1.0-dx)*(1.0-dy)*dz*(data[IJK(ilo,jlo,khi)])
<a name="l02388"></a>02388                 + (1.0-dx)*dy*(1.0-dz)*(data[IJK(ilo,jhi,klo)])
<a name="l02389"></a>02389                 + (1.0-dx)*(1.0-dy)*(1.0-dz)*(data[IJK(ilo,jlo,klo)]);
<a name="l02390"></a>02390                 nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02391"></a>02391             } <span class="keywordflow">else</span> {
<a name="l02392"></a>02392                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  Off old mesh at %g, %g \</span>
<a name="l02393"></a>02393 <span class="stringliteral">                          %g!\n&quot;</span>, __FILE__, __LINE__, x, y, z);
<a name="l02394"></a>02394                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh lower corner at \</span>
<a name="l02395"></a>02395 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xminOLD, yminOLD, zminOLD);
<a name="l02396"></a>02396                 Vnm_print(2, <span class="stringliteral">&quot;focusFillBound (%s, %d):  old mesh upper corner at \</span>
<a name="l02397"></a>02397 <span class="stringliteral">                          %g %g %g.\n&quot;</span>, __FILE__, __LINE__, xmaxOLD, ymaxOLD, zmaxOLD);
<a name="l02398"></a>02398                 VASSERT(0);
<a name="l02399"></a>02399             }
<a name="l02400"></a>02400             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02401"></a>02401             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,1)] = uval;
<a name="l02402"></a>02402             <span class="keywordflow">if</span>(uval &lt; uvalMin) uvalMin = uval;
<a name="l02403"></a>02403             <span class="keywordflow">if</span>(uval &gt; uvalMax) uvalMax = uval;
<a name="l02404"></a>02404 
<a name="l02405"></a>02405             <span class="comment">/* Zero Neumann conditions */</span>
<a name="l02406"></a>02406             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02407"></a>02407             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,2)] = 0.0;
<a name="l02408"></a>02408             nx = nxNEW; ny = nyNEW; nz = nzNEW;
<a name="l02409"></a>02409             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,3)] = 0.0;
<a name="l02410"></a>02410         }
<a name="l02411"></a>02411     }
<a name="l02412"></a>02412 
<a name="l02413"></a>02413     VWARN_MSG0(
<a name="l02414"></a>02414         uvalMin &gt;= <a class="code" href="group___vhal.html#ga2bf4abc739a18443a047ccab0d4ee8df" title="Used to set the min values acceptable for sinh chopping.">SINH_MIN</a> &amp;&amp; uvalMax &lt;= <a class="code" href="group___vhal.html#ga2400b9d421a5356e700fc35a5e60c8aa" title="Used to set the max values acceptable for sinh chopping.">SINH_MAX</a>,
<a name="l02415"></a>02415         <span class="stringliteral">&quot;Unusually large potential values\n&quot;</span>
<a name="l02416"></a>02416         <span class="stringliteral">&quot;    detected on the focusing boundary!\n&quot;</span>
<a name="l02417"></a>02417         <span class="stringliteral">&quot;    Convergence not guaranteed for NPBE/NRPBE calculations!&quot;</span>
<a name="l02418"></a>02418         );
<a name="l02419"></a>02419 }
<a name="l02420"></a>02420 
<a name="l02421"></a>02421 VPRIVATE <span class="keywordtype">void</span> extEnergy(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *pmgOLD, <a class="code" href="group___p_b_eparm.html#ga8cc295f42b2029944d85402f93190603" title="Define ePBEparm_calcEnergy enumeration as PBEparm_calcEnergy.">PBEparm_calcEnergy</a> extFlag,
<a name="l02422"></a>02422                         <span class="keywordtype">double</span> partMin[3], <span class="keywordtype">double</span> partMax[3], <span class="keywordtype">int</span> bflags[6]) {
<a name="l02423"></a>02423 
<a name="l02424"></a>02424     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l02425"></a>02425     <span class="keywordtype">double</span> hxNEW, hyNEW, hzNEW;
<a name="l02426"></a>02426     <span class="keywordtype">double</span> lowerCorner[3], upperCorner[3];
<a name="l02427"></a>02427     <span class="keywordtype">int</span> nxNEW, nyNEW, nzNEW;
<a name="l02428"></a>02428     <span class="keywordtype">int</span> nxOLD, nyOLD, nzOLD;
<a name="l02429"></a>02429     <span class="keywordtype">int</span> i,j,k;
<a name="l02430"></a>02430     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax;
<a name="l02431"></a>02431     <span class="keywordtype">double</span> hxOLD, hyOLD, hzOLD;
<a name="l02432"></a>02432     <span class="keywordtype">double</span> xval, yval, zval;
<a name="l02433"></a>02433     <span class="keywordtype">double</span> x,y,z;
<a name="l02434"></a>02434     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l02435"></a>02435 
<a name="l02436"></a>02436     <span class="comment">/* Set the new external energy contribution to zero.  Any external</span>
<a name="l02437"></a>02437 <span class="comment">     * contributions from higher levels will be included in the appropriate</span>
<a name="l02438"></a>02438 <span class="comment">     * energy function call. */</span>
<a name="l02439"></a>02439     thee-&gt;<a class="code" href="structs_vpmg.html#ab19b8dec8f40e3ceacb5d8f864c5dd3a">extQmEnergy</a> = 0;
<a name="l02440"></a>02440     thee-&gt;<a class="code" href="structs_vpmg.html#aefba7183c581d5dd81a716f5c65687dd">extQfEnergy</a> = 0;
<a name="l02441"></a>02441     thee-&gt;<a class="code" href="structs_vpmg.html#a76aee83486bc3b4a9f6352668d25d463">extDiEnergy</a> = 0;
<a name="l02442"></a>02442 
<a name="l02443"></a>02443     <span class="comment">/* New problem dimensions */</span>
<a name="l02444"></a>02444     hxNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l02445"></a>02445     hyNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l02446"></a>02446     hzNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l02447"></a>02447     nxNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l02448"></a>02448     nyNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l02449"></a>02449     nzNEW = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l02450"></a>02450     lowerCorner[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - ((double)(nxNEW-1)*hxNEW)/2.0;
<a name="l02451"></a>02451     upperCorner[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + ((double)(nxNEW-1)*hxNEW)/2.0;
<a name="l02452"></a>02452     lowerCorner[1] = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - ((double)(nyNEW-1)*hyNEW)/2.0;
<a name="l02453"></a>02453     upperCorner[1] = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + ((double)(nyNEW-1)*hyNEW)/2.0;
<a name="l02454"></a>02454     lowerCorner[2] = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - ((double)(nzNEW-1)*hzNEW)/2.0;
<a name="l02455"></a>02455     upperCorner[2] = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + ((double)(nzNEW-1)*hzNEW)/2.0;
<a name="l02456"></a>02456 
<a name="l02457"></a>02457     Vnm_print(0, <span class="stringliteral">&quot;VPMG::extEnergy:  energy flag = %d\n&quot;</span>, extFlag);
<a name="l02458"></a>02458 
<a name="l02459"></a>02459     <span class="comment">/* Old problem dimensions */</span>
<a name="l02460"></a>02460     nxOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l02461"></a>02461     nyOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l02462"></a>02462     nzOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l02463"></a>02463 
<a name="l02464"></a>02464     <span class="comment">/* Create a partition based on the new problem dimensions */</span>
<a name="l02465"></a>02465     <span class="comment">/* Vnm_print(1, &quot;DEBUG (%s, %d):  extEnergy calling Vpmg_setPart for old PMG.\n&quot;,</span>
<a name="l02466"></a>02466 <span class="comment">     __FILE__, __LINE__); */</span>
<a name="l02467"></a>02467     <a class="code" href="group___vpmg.html#gafe4fbd069927d516936116a417a256c1" title="Set partition information which restricts the calculation of observables to a (rectangular) subset of...">Vpmg_setPart</a>(pmgOLD, lowerCorner, upperCorner, bflags);
<a name="l02468"></a>02468 
<a name="l02469"></a>02469 
<a name="l02470"></a>02470     Vnm_print(0,<span class="stringliteral">&quot;VPMG::extEnergy:   Finding extEnergy dimensions...\n&quot;</span>);
<a name="l02471"></a>02471     Vnm_print(0,<span class="stringliteral">&quot;VPMG::extEnergy    Disj part lower corner = (%g, %g, %g)\n&quot;</span>,
<a name="l02472"></a>02472               partMin[0], partMin[1], partMin[2]);
<a name="l02473"></a>02473     Vnm_print(0,<span class="stringliteral">&quot;VPMG::extEnergy    Disj part upper corner = (%g, %g, %g)\n&quot;</span>,
<a name="l02474"></a>02474               partMax[0], partMax[1], partMax[2]);
<a name="l02475"></a>02475 
<a name="l02476"></a>02476     <span class="comment">/* Find the old dimensions */</span>
<a name="l02477"></a>02477 
<a name="l02478"></a>02478     hxOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l02479"></a>02479     hyOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l02480"></a>02480     hzOLD = pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l02481"></a>02481     xmin =  pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - 0.5*hxOLD*(nxOLD-1);
<a name="l02482"></a>02482     ymin =  pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - 0.5*hyOLD*(nyOLD-1);
<a name="l02483"></a>02483     zmin =  pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - 0.5*hzOLD*(nzOLD-1);
<a name="l02484"></a>02484     xmax =  xmin+hxOLD*(nxOLD-1);
<a name="l02485"></a>02485     ymax =  ymin+hyOLD*(nyOLD-1);
<a name="l02486"></a>02486     zmax =  zmin+hzOLD*(nzOLD-1);
<a name="l02487"></a>02487 
<a name="l02488"></a>02488     Vnm_print(0,<span class="stringliteral">&quot;VPMG::extEnergy    Old lower corner = (%g, %g, %g)\n&quot;</span>,
<a name="l02489"></a>02489               xmin, ymin, zmin);
<a name="l02490"></a>02490     Vnm_print(0,<span class="stringliteral">&quot;VPMG::extEnergy    Old upper corner = (%g, %g, %g)\n&quot;</span>,
<a name="l02491"></a>02491               xmax, ymax, zmax);
<a name="l02492"></a>02492 
<a name="l02493"></a>02493     <span class="comment">/* Flip the partition, but do not include any points that will</span>
<a name="l02494"></a>02494 <span class="comment">     be included by another processor */</span>
<a name="l02495"></a>02495 
<a name="l02496"></a>02496     nx = nxOLD;
<a name="l02497"></a>02497     ny = nyOLD;
<a name="l02498"></a>02498     nz = nzOLD;
<a name="l02499"></a>02499 
<a name="l02500"></a>02500     <span class="keywordflow">for</span>(i=0; i&lt;nx; i++) {
<a name="l02501"></a>02501         xval = 1;
<a name="l02502"></a>02502         x = i*hxOLD + xmin;
<a name="l02503"></a>02503         <span class="keywordflow">if</span> (x &lt; partMin[0] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga798032036c9c60fc5f471c6b7d2b7db6" title="Face definition for a volume.">VAPBS_LEFT</a>] == 1) xval = 0;
<a name="l02504"></a>02504         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &gt; partMax[0] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga8f2dde497bc361d93ca1ddb94dae77d3" title="Face definition for a volume.">VAPBS_RIGHT</a>] == 1) xval = 0;
<a name="l02505"></a>02505 
<a name="l02506"></a>02506         <span class="keywordflow">for</span>(j=0; j&lt;ny; j++) {
<a name="l02507"></a>02507             yval = 1;
<a name="l02508"></a>02508             y = j*hyOLD + ymin;
<a name="l02509"></a>02509             <span class="keywordflow">if</span> (y &lt; partMin[1] &amp;&amp; bflags[<a class="code" href="group___vhal.html#gaf4e4333b48f727631b092261d9f92c81" title="Face definition for a volume.">VAPBS_BACK</a>] == 1) yval = 0;
<a name="l02510"></a>02510             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (y &gt; partMax[1] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga448448d313ecbdf83a7f93434f0a584a" title="Face definition for a volume.">VAPBS_FRONT</a>] == 1) yval = 0;
<a name="l02511"></a>02511 
<a name="l02512"></a>02512             <span class="keywordflow">for</span>(k=0; k&lt;nz; k++) {
<a name="l02513"></a>02513                 zval = 1;
<a name="l02514"></a>02514                 z = k*hzOLD + zmin;
<a name="l02515"></a>02515                 <span class="keywordflow">if</span> (z &lt; partMin[2] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga57969092add9d0a00e8552a6e8995bcf" title="Face definition for a volume.">VAPBS_DOWN</a>] == 1) zval = 0;
<a name="l02516"></a>02516                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (z &gt; partMax[2] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga26162951b2540e56cf9b7e0cd0ed9caa" title="Face definition for a volume.">VAPBS_UP</a>] == 1) zval = 0;
<a name="l02517"></a>02517 
<a name="l02518"></a>02518                 <span class="keywordflow">if</span> (pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)] &gt; VSMALL) pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)] = 1.0;
<a name="l02519"></a>02519                 pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)] = (1 - (pmgOLD-&gt;<a class="code" href="structs_vpmg.html#a80c3b3ffd7d7889d39168aa8a6c6c9e2">pvec</a>[IJK(i,j,k)])) * (xval*yval*zval);
<a name="l02520"></a>02520             }
<a name="l02521"></a>02521         }
<a name="l02522"></a>02522     }
<a name="l02523"></a>02523 
<a name="l02524"></a>02524     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>); i++) {
<a name="l02525"></a>02525         xval=1;
<a name="l02526"></a>02526         yval=1;
<a name="l02527"></a>02527         zval=1;
<a name="l02528"></a>02528         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, i);
<a name="l02529"></a>02529         x = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0];
<a name="l02530"></a>02530         y = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1];
<a name="l02531"></a>02531         z = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2];
<a name="l02532"></a>02532         <span class="keywordflow">if</span> (x &lt; partMin[0] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga798032036c9c60fc5f471c6b7d2b7db6" title="Face definition for a volume.">VAPBS_LEFT</a>] == 1) xval = 0;
<a name="l02533"></a>02533         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &gt; partMax[0] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga8f2dde497bc361d93ca1ddb94dae77d3" title="Face definition for a volume.">VAPBS_RIGHT</a>] == 1) xval = 0;
<a name="l02534"></a>02534         <span class="keywordflow">if</span> (y &lt; partMin[1] &amp;&amp; bflags[<a class="code" href="group___vhal.html#gaf4e4333b48f727631b092261d9f92c81" title="Face definition for a volume.">VAPBS_BACK</a>] == 1) yval = 0;
<a name="l02535"></a>02535         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (y &gt; partMax[1] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga448448d313ecbdf83a7f93434f0a584a" title="Face definition for a volume.">VAPBS_FRONT</a>] == 1) yval = 0;
<a name="l02536"></a>02536         <span class="keywordflow">if</span> (z &lt; partMin[2] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga57969092add9d0a00e8552a6e8995bcf" title="Face definition for a volume.">VAPBS_DOWN</a>] == 1) zval = 0;
<a name="l02537"></a>02537         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (z &gt; partMax[2] &amp;&amp; bflags[<a class="code" href="group___vhal.html#ga26162951b2540e56cf9b7e0cd0ed9caa" title="Face definition for a volume.">VAPBS_UP</a>] == 1) zval = 0;
<a name="l02538"></a>02538         <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> &gt; VSMALL) atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> = 1.0;
<a name="l02539"></a>02539         atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> = (1 - atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a>) * (xval*yval*zval);
<a name="l02540"></a>02540     }
<a name="l02541"></a>02541 
<a name="l02542"></a>02542     <span class="comment">/* Now calculate the energy on inverted subset of the domain */</span>
<a name="l02543"></a>02543     thee-&gt;<a class="code" href="structs_vpmg.html#ab19b8dec8f40e3ceacb5d8f864c5dd3a">extQmEnergy</a> = <a class="code" href="group___vpmg.html#gaa742b2c423bcb09628a84833a5f1e7ae" title="Get the &quot;mobile charge&quot; contribution to the electrostatic energy.">Vpmg_qmEnergy</a>(pmgOLD, 1);
<a name="l02544"></a>02544     Vnm_print(0, <span class="stringliteral">&quot;VPMG::extEnergy: extQmEnergy = %g kT\n&quot;</span>, thee-&gt;<a class="code" href="structs_vpmg.html#ab19b8dec8f40e3ceacb5d8f864c5dd3a">extQmEnergy</a>);
<a name="l02545"></a>02545     thee-&gt;<a class="code" href="structs_vpmg.html#aefba7183c581d5dd81a716f5c65687dd">extQfEnergy</a> = <a class="code" href="group___vpmg.html#gad1a07a9d24211983ddcbcbf67267fbfb" title="Get the &quot;fixed charge&quot; contribution to the electrostatic energy.">Vpmg_qfEnergy</a>(pmgOLD, 1);
<a name="l02546"></a>02546     Vnm_print(0, <span class="stringliteral">&quot;VPMG::extEnergy: extQfEnergy = %g kT\n&quot;</span>, thee-&gt;<a class="code" href="structs_vpmg.html#aefba7183c581d5dd81a716f5c65687dd">extQfEnergy</a>);
<a name="l02547"></a>02547     thee-&gt;<a class="code" href="structs_vpmg.html#a76aee83486bc3b4a9f6352668d25d463">extDiEnergy</a> = <a class="code" href="group___vpmg.html#ga855098121480f53fffc85f15b97cb88c" title="Get the &quot;polarization&quot; contribution to the electrostatic energy.">Vpmg_dielEnergy</a>(pmgOLD, 1);
<a name="l02548"></a>02548     Vnm_print(0, <span class="stringliteral">&quot;VPMG::extEnergy: extDiEnergy = %g kT\n&quot;</span>, thee-&gt;<a class="code" href="structs_vpmg.html#a76aee83486bc3b4a9f6352668d25d463">extDiEnergy</a>);
<a name="l02549"></a>02549     <a class="code" href="group___vpmg.html#gafc90a96505e0bddd5cc15b69f3c7613c" title="Remove partition restrictions.">Vpmg_unsetPart</a>(pmgOLD);
<a name="l02550"></a>02550 }
<a name="l02551"></a>02551 
<a name="l02552"></a>02552 VPRIVATE <span class="keywordtype">double</span> bcfl1sp(<span class="keywordtype">double</span> size, <span class="keywordtype">double</span> *apos, <span class="keywordtype">double</span> charge,
<a name="l02553"></a>02553                         <span class="keywordtype">double</span> xkappa, <span class="keywordtype">double</span> pre1, <span class="keywordtype">double</span> *pos) {
<a name="l02554"></a>02554 
<a name="l02555"></a>02555     <span class="keywordtype">double</span> dist, val;
<a name="l02556"></a>02556 
<a name="l02557"></a>02557     dist = VSQRT(VSQR(pos[0]-apos[0]) + VSQR(pos[1]-apos[1])
<a name="l02558"></a>02558                  + VSQR(pos[2]-apos[2]));
<a name="l02559"></a>02559     <span class="keywordflow">if</span> (xkappa &gt; VSMALL) {
<a name="l02560"></a>02560         val = pre1*(charge/dist)*VEXP(-xkappa*(dist-size))
<a name="l02561"></a>02561         / (1+xkappa*size);
<a name="l02562"></a>02562     } <span class="keywordflow">else</span> {
<a name="l02563"></a>02563         val = pre1*(charge/dist);
<a name="l02564"></a>02564     }
<a name="l02565"></a>02565 
<a name="l02566"></a>02566     <span class="keywordflow">return</span> val;
<a name="l02567"></a>02567 }
<a name="l02568"></a>02568 
<a name="l02569"></a><a class="code" href="vpmg_8h.html#a787e4bcc6b7ec8a87aed577535268eb3">02569</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a787e4bcc6b7ec8a87aed577535268eb3" title="Increment all boundary points by pre1*(charge/d)*(exp(-xkappa*(d-size))/(1+xkappa*size) to add the ef...">bcfl1</a>(<span class="keywordtype">double</span> size, <span class="keywordtype">double</span> *apos, <span class="keywordtype">double</span> charge,
<a name="l02570"></a>02570                     <span class="keywordtype">double</span> xkappa, <span class="keywordtype">double</span> pre1, <span class="keywordtype">double</span> *gxcf, <span class="keywordtype">double</span> *gycf, <span class="keywordtype">double</span> *gzcf,
<a name="l02571"></a>02571                     <span class="keywordtype">double</span> *xf, <span class="keywordtype">double</span> *yf, <span class="keywordtype">double</span> *zf, <span class="keywordtype">int</span> nx, <span class="keywordtype">int</span> ny, <span class="keywordtype">int</span> nz) {
<a name="l02572"></a>02572 
<a name="l02573"></a>02573     <span class="keywordtype">int</span> i, j, k;
<a name="l02574"></a>02574     <span class="keywordtype">double</span> dist, val;
<a name="l02575"></a>02575     <span class="keywordtype">double</span> gpos[3];
<a name="l02576"></a>02576 
<a name="l02577"></a>02577     <span class="comment">/* the &quot;i&quot; boundaries (dirichlet) */</span>
<a name="l02578"></a>02578     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l02579"></a>02579         gpos[2] = zf[k];
<a name="l02580"></a>02580         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l02581"></a>02581             gpos[1] = yf[j];
<a name="l02582"></a>02582             gpos[0] = xf[0];
<a name="l02583"></a>02583             dist = VSQRT(VSQR(gpos[0]-apos[0]) + VSQR(gpos[1]-apos[1])
<a name="l02584"></a>02584                          + VSQR(gpos[2]-apos[2]));
<a name="l02585"></a>02585             <span class="keywordflow">if</span> (xkappa &gt; VSMALL) {
<a name="l02586"></a>02586                 val = pre1*(charge/dist)*VEXP(-xkappa*(dist-size))
<a name="l02587"></a>02587                 / (1+xkappa*size);
<a name="l02588"></a>02588             } <span class="keywordflow">else</span> {
<a name="l02589"></a>02589                 val = pre1*(charge/dist);
<a name="l02590"></a>02590             }
<a name="l02591"></a>02591             gxcf[IJKx(j,k,0)] += val;
<a name="l02592"></a>02592             gpos[0] = xf[nx-1];
<a name="l02593"></a>02593             dist = VSQRT(VSQR(gpos[0]-apos[0]) + VSQR(gpos[1]-apos[1])
<a name="l02594"></a>02594                          + VSQR(gpos[2]-apos[2]));
<a name="l02595"></a>02595             <span class="keywordflow">if</span> (xkappa &gt; VSMALL) {
<a name="l02596"></a>02596                 val = pre1*(charge/dist)*VEXP(-xkappa*(dist-size))
<a name="l02597"></a>02597                 / (1+xkappa*size);
<a name="l02598"></a>02598             } <span class="keywordflow">else</span> {
<a name="l02599"></a>02599                 val = pre1*(charge/dist);
<a name="l02600"></a>02600             }
<a name="l02601"></a>02601             gxcf[IJKx(j,k,1)] += val;
<a name="l02602"></a>02602         }
<a name="l02603"></a>02603     }
<a name="l02604"></a>02604 
<a name="l02605"></a>02605     <span class="comment">/* the &quot;j&quot; boundaries (dirichlet) */</span>
<a name="l02606"></a>02606     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l02607"></a>02607         gpos[2] = zf[k];
<a name="l02608"></a>02608         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l02609"></a>02609             gpos[0] = xf[i];
<a name="l02610"></a>02610             gpos[1] = yf[0];
<a name="l02611"></a>02611             dist = VSQRT(VSQR(gpos[0]-apos[0]) + VSQR(gpos[1]-apos[1])
<a name="l02612"></a>02612                          + VSQR(gpos[2]-apos[2]));
<a name="l02613"></a>02613             <span class="keywordflow">if</span> (xkappa &gt; VSMALL) {
<a name="l02614"></a>02614                 val = pre1*(charge/dist)*VEXP(-xkappa*(dist-size))
<a name="l02615"></a>02615                 / (1+xkappa*size);
<a name="l02616"></a>02616             } <span class="keywordflow">else</span> {
<a name="l02617"></a>02617                 val = pre1*(charge/dist);
<a name="l02618"></a>02618             }
<a name="l02619"></a>02619             gycf[IJKy(i,k,0)] += val;
<a name="l02620"></a>02620             gpos[1] = yf[ny-1];
<a name="l02621"></a>02621             dist = VSQRT(VSQR(gpos[0]-apos[0]) + VSQR(gpos[1]-apos[1])
<a name="l02622"></a>02622                          + VSQR(gpos[2]-apos[2]));
<a name="l02623"></a>02623             <span class="keywordflow">if</span> (xkappa &gt; VSMALL) {
<a name="l02624"></a>02624                 val = pre1*(charge/dist)*VEXP(-xkappa*(dist-size))
<a name="l02625"></a>02625                 / (1+xkappa*size);
<a name="l02626"></a>02626             } <span class="keywordflow">else</span> {
<a name="l02627"></a>02627                 val = pre1*(charge/dist);
<a name="l02628"></a>02628             }
<a name="l02629"></a>02629             gycf[IJKy(i,k,1)] += val;
<a name="l02630"></a>02630         }
<a name="l02631"></a>02631     }
<a name="l02632"></a>02632 
<a name="l02633"></a>02633     <span class="comment">/* the &quot;k&quot; boundaries (dirichlet) */</span>
<a name="l02634"></a>02634     <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l02635"></a>02635         gpos[1] = yf[j];
<a name="l02636"></a>02636         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l02637"></a>02637             gpos[0] = xf[i];
<a name="l02638"></a>02638             gpos[2] = zf[0];
<a name="l02639"></a>02639             dist = VSQRT(VSQR(gpos[0]-apos[0]) + VSQR(gpos[1]-apos[1])
<a name="l02640"></a>02640                          + VSQR(gpos[2]-apos[2]));
<a name="l02641"></a>02641             <span class="keywordflow">if</span> (xkappa &gt; VSMALL) {
<a name="l02642"></a>02642                 val = pre1*(charge/dist)*VEXP(-xkappa*(dist-size))
<a name="l02643"></a>02643                 / (1+xkappa*size);
<a name="l02644"></a>02644             } <span class="keywordflow">else</span> {
<a name="l02645"></a>02645                 val = pre1*(charge/dist);
<a name="l02646"></a>02646             }
<a name="l02647"></a>02647             gzcf[IJKz(i,j,0)] += val;
<a name="l02648"></a>02648             gpos[2] = zf[nz-1];
<a name="l02649"></a>02649             dist = VSQRT(VSQR(gpos[0]-apos[0]) + VSQR(gpos[1]-apos[1])
<a name="l02650"></a>02650                          + VSQR(gpos[2]-apos[2]));
<a name="l02651"></a>02651             <span class="keywordflow">if</span> (xkappa &gt; VSMALL) {
<a name="l02652"></a>02652                 val = pre1*(charge/dist)*VEXP(-xkappa*(dist-size))
<a name="l02653"></a>02653                 / (1+xkappa*size);
<a name="l02654"></a>02654             } <span class="keywordflow">else</span> {
<a name="l02655"></a>02655                 val = pre1*(charge/dist);
<a name="l02656"></a>02656             }
<a name="l02657"></a>02657             gzcf[IJKz(i,j,1)] += val;
<a name="l02658"></a>02658         }
<a name="l02659"></a>02659     }
<a name="l02660"></a>02660 }
<a name="l02661"></a>02661 
<a name="l02662"></a>02662 VPRIVATE <span class="keywordtype">void</span> bcfl2(<span class="keywordtype">double</span> size, <span class="keywordtype">double</span> *apos,
<a name="l02663"></a>02663                     <span class="keywordtype">double</span> charge, <span class="keywordtype">double</span> *dipole, <span class="keywordtype">double</span> *quad,
<a name="l02664"></a>02664                     <span class="keywordtype">double</span> xkappa, <span class="keywordtype">double</span> eps_p, <span class="keywordtype">double</span> eps_w, <span class="keywordtype">double</span> T,
<a name="l02665"></a>02665                     <span class="keywordtype">double</span> *gxcf, <span class="keywordtype">double</span> *gycf, <span class="keywordtype">double</span> *gzcf,
<a name="l02666"></a>02666                     <span class="keywordtype">double</span> *xf, <span class="keywordtype">double</span> *yf, <span class="keywordtype">double</span> *zf,
<a name="l02667"></a>02667                     <span class="keywordtype">int</span> nx, <span class="keywordtype">int</span> ny, <span class="keywordtype">int</span> nz) {
<a name="l02668"></a>02668 
<a name="l02669"></a>02669     <span class="keywordtype">int</span> i, j, k;
<a name="l02670"></a>02670     <span class="keywordtype">double</span> val;
<a name="l02671"></a>02671     <span class="keywordtype">double</span> gpos[3],tensor[3];
<a name="l02672"></a>02672     <span class="keywordtype">double</span> ux,uy,uz,xr,yr,zr;
<a name="l02673"></a>02673     <span class="keywordtype">double</span> qxx,qxy,qxz,qyx,qyy,qyz,qzx,qzy,qzz;
<a name="l02674"></a>02674     <span class="keywordtype">double</span> dist, pre;
<a name="l02675"></a>02675 
<a name="l02676"></a>02676     VASSERT(dipole != VNULL);
<a name="l02677"></a>02677     ux = dipole[0];
<a name="l02678"></a>02678     uy = dipole[1];
<a name="l02679"></a>02679     uz = dipole[2];
<a name="l02680"></a>02680     <span class="keywordflow">if</span> (quad != VNULL) {
<a name="l02681"></a>02681         <span class="comment">/* The factor of 1/3 results from using a</span>
<a name="l02682"></a>02682 <span class="comment">         traceless quadrupole definition. See, for example,</span>
<a name="l02683"></a>02683 <span class="comment">         &quot;The Theory of Intermolecular Forces&quot; by A.J. Stone,</span>
<a name="l02684"></a>02684 <span class="comment">         Chapter 3. */</span>
<a name="l02685"></a>02685         qxx = quad[0] / 3.0;
<a name="l02686"></a>02686         qxy = quad[1] / 3.0;
<a name="l02687"></a>02687         qxz = quad[2] / 3.0;
<a name="l02688"></a>02688         qyx = quad[3] / 3.0;
<a name="l02689"></a>02689         qyy = quad[4] / 3.0;
<a name="l02690"></a>02690         qyz = quad[5] / 3.0;
<a name="l02691"></a>02691         qzx = quad[6] / 3.0;
<a name="l02692"></a>02692         qzy = quad[7] / 3.0;
<a name="l02693"></a>02693         qzz = quad[8] / 3.0;
<a name="l02694"></a>02694     } <span class="keywordflow">else</span> {
<a name="l02695"></a>02695         qxx = 0.0;
<a name="l02696"></a>02696         qxy = 0.0;
<a name="l02697"></a>02697         qxz = 0.0;
<a name="l02698"></a>02698         qyx = 0.0;
<a name="l02699"></a>02699         qyy = 0.0;
<a name="l02700"></a>02700         qyz = 0.0;
<a name="l02701"></a>02701         qzx = 0.0;
<a name="l02702"></a>02702         qzy = 0.0;
<a name="l02703"></a>02703         qzz = 0.0;
<a name="l02704"></a>02704     }
<a name="l02705"></a>02705 
<a name="l02706"></a>02706     pre = (<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T);
<a name="l02707"></a>02707     pre = pre*(1.0e10);
<a name="l02708"></a>02708 
<a name="l02709"></a>02709     <span class="comment">/* the &quot;i&quot; boundaries (dirichlet) */</span>
<a name="l02710"></a>02710     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l02711"></a>02711         gpos[2] = zf[k];
<a name="l02712"></a>02712         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l02713"></a>02713             gpos[1] = yf[j];
<a name="l02714"></a>02714             gpos[0] = xf[0];
<a name="l02715"></a>02715             xr = gpos[0] - apos[0];
<a name="l02716"></a>02716             yr = gpos[1] - apos[1];
<a name="l02717"></a>02717             zr = gpos[2] - apos[2];
<a name="l02718"></a>02718             dist = VSQRT(VSQR(xr) + VSQR(yr) + VSQR(zr));
<a name="l02719"></a>02719             <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(dist, xkappa, eps_p, eps_w, size, tensor);
<a name="l02720"></a>02720             val = pre*charge*tensor[0];
<a name="l02721"></a>02721             val -= pre*ux*xr*tensor[1];
<a name="l02722"></a>02722             val -= pre*uy*yr*tensor[1];
<a name="l02723"></a>02723             val -= pre*uz*zr*tensor[1];
<a name="l02724"></a>02724             val += pre*qxx*xr*xr*tensor[2];
<a name="l02725"></a>02725             val += pre*qyy*yr*yr*tensor[2];
<a name="l02726"></a>02726             val += pre*qzz*zr*zr*tensor[2];
<a name="l02727"></a>02727             val += pre*2.0*qxy*xr*yr*tensor[2];
<a name="l02728"></a>02728             val += pre*2.0*qxz*xr*zr*tensor[2];
<a name="l02729"></a>02729             val += pre*2.0*qyz*yr*zr*tensor[2];
<a name="l02730"></a>02730             gxcf[IJKx(j,k,0)] += val;
<a name="l02731"></a>02731 
<a name="l02732"></a>02732             gpos[0] = xf[nx-1];
<a name="l02733"></a>02733             xr = gpos[0] - apos[0];
<a name="l02734"></a>02734             dist = VSQRT(VSQR(xr) + VSQR(yr) + VSQR(zr));
<a name="l02735"></a>02735             <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(dist, xkappa, eps_p, eps_w, size, tensor);
<a name="l02736"></a>02736             val = pre*charge*tensor[0];
<a name="l02737"></a>02737             val -= pre*ux*xr*tensor[1];
<a name="l02738"></a>02738             val -= pre*uy*yr*tensor[1];
<a name="l02739"></a>02739             val -= pre*uz*zr*tensor[1];
<a name="l02740"></a>02740             val += pre*qxx*xr*xr*tensor[2];
<a name="l02741"></a>02741             val += pre*qyy*yr*yr*tensor[2];
<a name="l02742"></a>02742             val += pre*qzz*zr*zr*tensor[2];
<a name="l02743"></a>02743             val += pre*2.0*qxy*xr*yr*tensor[2];
<a name="l02744"></a>02744             val += pre*2.0*qxz*xr*zr*tensor[2];
<a name="l02745"></a>02745             val += pre*2.0*qyz*yr*zr*tensor[2];
<a name="l02746"></a>02746             gxcf[IJKx(j,k,1)] += val;
<a name="l02747"></a>02747         }
<a name="l02748"></a>02748     }
<a name="l02749"></a>02749 
<a name="l02750"></a>02750     <span class="comment">/* the &quot;j&quot; boundaries (dirichlet) */</span>
<a name="l02751"></a>02751     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l02752"></a>02752         gpos[2] = zf[k];
<a name="l02753"></a>02753         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l02754"></a>02754             gpos[0] = xf[i];
<a name="l02755"></a>02755             gpos[1] = yf[0];
<a name="l02756"></a>02756             xr = gpos[0] - apos[0];
<a name="l02757"></a>02757             yr = gpos[1] - apos[1];
<a name="l02758"></a>02758             zr = gpos[2] - apos[2];
<a name="l02759"></a>02759             dist = VSQRT(VSQR(xr) + VSQR(yr) + VSQR(zr));
<a name="l02760"></a>02760             <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(dist, xkappa, eps_p, eps_w, size, tensor);
<a name="l02761"></a>02761             val = pre*charge*tensor[0];
<a name="l02762"></a>02762             val -= pre*ux*xr*tensor[1];
<a name="l02763"></a>02763             val -= pre*uy*yr*tensor[1];
<a name="l02764"></a>02764             val -= pre*uz*zr*tensor[1];
<a name="l02765"></a>02765             val += pre*qxx*xr*xr*tensor[2];
<a name="l02766"></a>02766             val += pre*qyy*yr*yr*tensor[2];
<a name="l02767"></a>02767             val += pre*qzz*zr*zr*tensor[2];
<a name="l02768"></a>02768             val += pre*2.0*qxy*xr*yr*tensor[2];
<a name="l02769"></a>02769             val += pre*2.0*qxz*xr*zr*tensor[2];
<a name="l02770"></a>02770             val += pre*2.0*qyz*yr*zr*tensor[2];
<a name="l02771"></a>02771             gycf[IJKy(i,k,0)] += val;
<a name="l02772"></a>02772 
<a name="l02773"></a>02773             gpos[1] = yf[ny-1];
<a name="l02774"></a>02774             yr = gpos[1] - apos[1];
<a name="l02775"></a>02775             dist = VSQRT(VSQR(xr) + VSQR(yr) + VSQR(zr));
<a name="l02776"></a>02776             <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(dist, xkappa, eps_p, eps_w, size, tensor);
<a name="l02777"></a>02777             val = pre*charge*tensor[0];
<a name="l02778"></a>02778             val -= pre*ux*xr*tensor[1];
<a name="l02779"></a>02779             val -= pre*uy*yr*tensor[1];
<a name="l02780"></a>02780             val -= pre*uz*zr*tensor[1];
<a name="l02781"></a>02781             val += pre*qxx*xr*xr*tensor[2];
<a name="l02782"></a>02782             val += pre*qyy*yr*yr*tensor[2];
<a name="l02783"></a>02783             val += pre*qzz*zr*zr*tensor[2];
<a name="l02784"></a>02784             val += pre*2.0*qxy*xr*yr*tensor[2];
<a name="l02785"></a>02785             val += pre*2.0*qxz*xr*zr*tensor[2];
<a name="l02786"></a>02786             val += pre*2.0*qyz*yr*zr*tensor[2];
<a name="l02787"></a>02787             gycf[IJKy(i,k,1)] += val;
<a name="l02788"></a>02788         }
<a name="l02789"></a>02789     }
<a name="l02790"></a>02790 
<a name="l02791"></a>02791     <span class="comment">/* the &quot;k&quot; boundaries (dirichlet) */</span>
<a name="l02792"></a>02792     <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l02793"></a>02793         gpos[1] = yf[j];
<a name="l02794"></a>02794         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l02795"></a>02795             gpos[0] = xf[i];
<a name="l02796"></a>02796             gpos[2] = zf[0];
<a name="l02797"></a>02797             xr = gpos[0] - apos[0];
<a name="l02798"></a>02798             yr = gpos[1] - apos[1];
<a name="l02799"></a>02799             zr = gpos[2] - apos[2];
<a name="l02800"></a>02800             dist = VSQRT(VSQR(xr) + VSQR(yr) + VSQR(zr));
<a name="l02801"></a>02801             <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(dist, xkappa, eps_p, eps_w, size, tensor);
<a name="l02802"></a>02802             val = pre*charge*tensor[0];
<a name="l02803"></a>02803             val -= pre*ux*xr*tensor[1];
<a name="l02804"></a>02804             val -= pre*uy*yr*tensor[1];
<a name="l02805"></a>02805             val -= pre*uz*zr*tensor[1];
<a name="l02806"></a>02806             val += pre*qxx*xr*xr*tensor[2];
<a name="l02807"></a>02807             val += pre*qyy*yr*yr*tensor[2];
<a name="l02808"></a>02808             val += pre*qzz*zr*zr*tensor[2];
<a name="l02809"></a>02809             val += pre*2.0*qxy*xr*yr*tensor[2];
<a name="l02810"></a>02810             val += pre*2.0*qxz*xr*zr*tensor[2];
<a name="l02811"></a>02811             val += pre*2.0*qyz*yr*zr*tensor[2];
<a name="l02812"></a>02812             gzcf[IJKz(i,j,0)] += val;
<a name="l02813"></a>02813 
<a name="l02814"></a>02814             gpos[2] = zf[nz-1];
<a name="l02815"></a>02815             zr = gpos[2] - apos[2];
<a name="l02816"></a>02816             dist = VSQRT(VSQR(xr) + VSQR(yr) + VSQR(zr));
<a name="l02817"></a>02817             <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(dist, xkappa, eps_p, eps_w, size, tensor);
<a name="l02818"></a>02818             val = pre*charge*tensor[0];
<a name="l02819"></a>02819             val -= pre*ux*xr*tensor[1];
<a name="l02820"></a>02820             val -= pre*uy*yr*tensor[1];
<a name="l02821"></a>02821             val -= pre*uz*zr*tensor[1];
<a name="l02822"></a>02822             val += pre*qxx*xr*xr*tensor[2];
<a name="l02823"></a>02823             val += pre*qyy*yr*yr*tensor[2];
<a name="l02824"></a>02824             val += pre*qzz*zr*zr*tensor[2];
<a name="l02825"></a>02825             val += pre*2.0*qxy*xr*yr*tensor[2];
<a name="l02826"></a>02826             val += pre*2.0*qxz*xr*zr*tensor[2];
<a name="l02827"></a>02827             val += pre*2.0*qyz*yr*zr*tensor[2];
<a name="l02828"></a>02828             gzcf[IJKz(i,j,1)] += val;
<a name="l02829"></a>02829         }
<a name="l02830"></a>02830     }
<a name="l02831"></a>02831 }
<a name="l02832"></a>02832 
<a name="l02833"></a>02833 VPRIVATE <span class="keywordtype">void</span> bcCalcOrig(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l02834"></a>02834 
<a name="l02835"></a>02835     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l02836"></a>02836     <span class="keywordtype">double</span> size, *position, charge, xkappa, eps_w, T, pre1;
<a name="l02837"></a>02837     <span class="keywordtype">double</span> *dipole, *quadrupole, debye, eps_p;
<a name="l02838"></a>02838     <span class="keywordtype">double</span> xr,yr,zr,qave,*apos;
<a name="l02839"></a>02839     <span class="keywordtype">double</span> sdhcharge, sdhdipole[3], traced[9], sdhquadrupole[9];
<a name="l02840"></a>02840     <span class="keywordtype">int</span> i, j, k, iatom;
<a name="l02841"></a>02841     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l02842"></a>02842     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l02843"></a>02843     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l02844"></a>02844 
<a name="l02845"></a>02845     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l02846"></a>02846     alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l02847"></a>02847     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l02848"></a>02848     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l02849"></a>02849     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l02850"></a>02850 
<a name="l02851"></a>02851     <span class="comment">/* Zero out the boundaries */</span>
<a name="l02852"></a>02852     <span class="comment">/* the &quot;i&quot; boundaries (dirichlet) */</span>
<a name="l02853"></a>02853     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l02854"></a>02854         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l02855"></a>02855             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,0)] = 0.0;
<a name="l02856"></a>02856             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,1)] = 0.0;
<a name="l02857"></a>02857             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,2)] = 0.0;
<a name="l02858"></a>02858             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,3)] = 0.0;
<a name="l02859"></a>02859         }
<a name="l02860"></a>02860     }
<a name="l02861"></a>02861 
<a name="l02862"></a>02862     <span class="comment">/* the &quot;j&quot; boundaries (dirichlet) */</span>
<a name="l02863"></a>02863     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l02864"></a>02864         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l02865"></a>02865             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,0)] = 0.0;
<a name="l02866"></a>02866             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,1)] = 0.0;
<a name="l02867"></a>02867             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,2)] = 0.0;
<a name="l02868"></a>02868             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,3)] = 0.0;
<a name="l02869"></a>02869         }
<a name="l02870"></a>02870     }
<a name="l02871"></a>02871 
<a name="l02872"></a>02872     <span class="comment">/* the &quot;k&quot; boundaries (dirichlet) */</span>
<a name="l02873"></a>02873     <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l02874"></a>02874         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l02875"></a>02875             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,0)] = 0.0;
<a name="l02876"></a>02876             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,1)] = 0.0;
<a name="l02877"></a>02877             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,2)] = 0.0;
<a name="l02878"></a>02878             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,3)] = 0.0;
<a name="l02879"></a>02879         }
<a name="l02880"></a>02880     }
<a name="l02881"></a>02881 
<a name="l02882"></a>02882     <span class="comment">/* For each &quot;atom&quot; (only one for bcfl=1), we use the following formula to</span>
<a name="l02883"></a>02883 <span class="comment">    * calculate the boundary conditions:</span>
<a name="l02884"></a>02884 <span class="comment">    *    g(x) = \frac{q e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l02885"></a>02885 <span class="comment">    *          * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l02886"></a>02886 <span class="comment">    *          * 1/d</span>
<a name="l02887"></a>02887 <span class="comment">    * where d = ||x - x_0|| (in m) and a is the size of the atom (in m).</span>
<a name="l02888"></a>02888 <span class="comment">    * We only need to evaluate some of these prefactors once:</span>
<a name="l02889"></a>02889 <span class="comment">    *    pre1 = \frac{e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l02890"></a>02890 <span class="comment">    * which gives the potential as</span>
<a name="l02891"></a>02891 <span class="comment">    *    g(x) = pre1 * q/d * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l02892"></a>02892 <span class="comment">    */</span>
<a name="l02893"></a>02893     eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l02894"></a>02894     eps_p = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l02895"></a>02895     T = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe);               <span class="comment">/* K             */</span>
<a name="l02896"></a>02896     pre1 = (<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*eps_w*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T);
<a name="l02897"></a>02897 
<a name="l02898"></a>02898     <span class="comment">/* Finally, if we convert keep xkappa in A^{-1} and scale pre1 by</span>
<a name="l02899"></a>02899 <span class="comment">        * m/A, then we will only need to deal with distances and sizes in</span>
<a name="l02900"></a>02900 <span class="comment">        * Angstroms rather than meters.                                       */</span>
<a name="l02901"></a>02901     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);              <span class="comment">/* A^{-1}        */</span>
<a name="l02902"></a>02902     pre1 = pre1*(1.0e10);
<a name="l02903"></a>02903 
<a name="l02904"></a>02904     <span class="keywordflow">switch</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a>) {
<a name="l02905"></a>02905         <span class="comment">/*  If we have zero boundary conditions, we&#39;re done */</span>
<a name="l02906"></a>02906         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a938886846c2d77f2f01352f17628692f">BCFL_ZERO</a>:
<a name="l02907"></a>02907             <span class="keywordflow">return</span>;
<a name="l02908"></a>02908 
<a name="l02909"></a>02909             <span class="comment">/*  For single DH sphere BC&#39;s, we only have one &quot;atom&quot; to deal with;</span>
<a name="l02910"></a>02910 <span class="comment">            *  get its information and */</span>
<a name="l02911"></a>02911         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a5b0fd9934f32bb7255ed6ebc373a6ad4">BCFL_SDH</a>:
<a name="l02912"></a>02912             size = <a class="code" href="group___vpbe.html#gabc3d4ee6a7571b191b583e2b49d1742a" title="Get sphere radius which bounds biomolecule.">Vpbe_getSoluteRadius</a>(pbe);
<a name="l02913"></a>02913             position = <a class="code" href="group___vpbe.html#ga8003268df05a845c934fa8be679f834c" title="Get coordinates of solute center.">Vpbe_getSoluteCenter</a>(pbe);
<a name="l02914"></a>02914 
<a name="l02915"></a>02915             <span class="comment">/*</span>
<a name="l02916"></a>02916 <span class="comment">             For AMOEBA SDH boundary conditions, we need to find the</span>
<a name="l02917"></a>02917 <span class="comment">             total monopole, dipole and traceless quadrupole moments</span>
<a name="l02918"></a>02918 <span class="comment">             of either the permanent multipoles, induced dipoles or</span>
<a name="l02919"></a>02919 <span class="comment">             non-local induced dipoles.</span>
<a name="l02920"></a>02920 <span class="comment">             */</span>
<a name="l02921"></a>02921 
<a name="l02922"></a>02922             sdhcharge = 0.0;
<a name="l02923"></a>02923             <span class="keywordflow">for</span> (i=0; i&lt;3; i++) sdhdipole[i] = 0.0;
<a name="l02924"></a>02924             <span class="keywordflow">for</span> (i=0; i&lt;9; i++) sdhquadrupole[i] = 0.0;
<a name="l02925"></a>02925 
<a name="l02926"></a>02926             <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l02927"></a>02927                 atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l02928"></a>02928                 apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l02929"></a>02929                 xr = apos[0] - position[0];
<a name="l02930"></a>02930                 yr = apos[1] - position[1];
<a name="l02931"></a>02931                 zr = apos[2] - position[2];
<a name="l02932"></a>02932                 <span class="keywordflow">switch</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a311ed24e465040d2095273159d497995">chargeSrc</a>) {
<a name="l02933"></a>02933                     <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4daf34ddd788f7709bb1093266ae397826d">VCM_CHARGE</a>:
<a name="l02934"></a>02934                         charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l02935"></a>02935                         sdhcharge += charge;
<a name="l02936"></a>02936                         sdhdipole[0] += xr * charge;
<a name="l02937"></a>02937                         sdhdipole[1] += yr * charge;
<a name="l02938"></a>02938                         sdhdipole[2] += zr * charge;
<a name="l02939"></a>02939                         traced[0] = xr*xr*charge;
<a name="l02940"></a>02940                         traced[1] = xr*yr*charge;
<a name="l02941"></a>02941                         traced[2] = xr*zr*charge;
<a name="l02942"></a>02942                         traced[3] = yr*xr*charge;
<a name="l02943"></a>02943                         traced[4] = yr*yr*charge;
<a name="l02944"></a>02944                         traced[5] = yr*zr*charge;
<a name="l02945"></a>02945                         traced[6] = zr*xr*charge;
<a name="l02946"></a>02946                         traced[7] = zr*yr*charge;
<a name="l02947"></a>02947                         traced[8] = zr*zr*charge;
<a name="l02948"></a>02948                         qave = (traced[0] + traced[4] + traced[8]) / 3.0;
<a name="l02949"></a>02949                         sdhquadrupole[0] += 1.5*(traced[0] - qave);
<a name="l02950"></a>02950                         sdhquadrupole[1] += 1.5*(traced[1]);
<a name="l02951"></a>02951                         sdhquadrupole[2] += 1.5*(traced[2]);
<a name="l02952"></a>02952                         sdhquadrupole[3] += 1.5*(traced[3]);
<a name="l02953"></a>02953                         sdhquadrupole[4] += 1.5*(traced[4] - qave);
<a name="l02954"></a>02954                         sdhquadrupole[5] += 1.5*(traced[5]);
<a name="l02955"></a>02955                         sdhquadrupole[6] += 1.5*(traced[6]);
<a name="l02956"></a>02956                         sdhquadrupole[7] += 1.5*(traced[7]);
<a name="l02957"></a>02957                         sdhquadrupole[8] += 1.5*(traced[8] - qave);
<a name="l02958"></a>02958 <span class="preprocessor">#if defined(WITH_TINKER)</span>
<a name="l02959"></a>02959 <span class="preprocessor"></span>                    <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4dac6801535dedee5a72c8a91f5872731aa">VCM_PERMANENT</a>:
<a name="l02960"></a>02960                         charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l02961"></a>02961                         dipole = Vatom_getDipole(atom);
<a name="l02962"></a>02962                         quadrupole = Vatom_getQuadrupole(atom);
<a name="l02963"></a>02963                         sdhcharge += charge;
<a name="l02964"></a>02964                         sdhdipole[0] += xr * charge;
<a name="l02965"></a>02965                         sdhdipole[1] += yr * charge;
<a name="l02966"></a>02966                         sdhdipole[2] += zr * charge;
<a name="l02967"></a>02967                         traced[0] = xr*xr*charge;
<a name="l02968"></a>02968                         traced[1] = xr*yr*charge;
<a name="l02969"></a>02969                         traced[2] = xr*zr*charge;
<a name="l02970"></a>02970                         traced[3] = yr*xr*charge;
<a name="l02971"></a>02971                         traced[4] = yr*yr*charge;
<a name="l02972"></a>02972                         traced[5] = yr*zr*charge;
<a name="l02973"></a>02973                         traced[6] = zr*xr*charge;
<a name="l02974"></a>02974                         traced[7] = zr*yr*charge;
<a name="l02975"></a>02975                         traced[8] = zr*zr*charge;
<a name="l02976"></a>02976                         sdhdipole[0] += dipole[0];
<a name="l02977"></a>02977                         sdhdipole[1] += dipole[1];
<a name="l02978"></a>02978                         sdhdipole[2] += dipole[2];
<a name="l02979"></a>02979                         traced[0] += 2.0*xr*dipole[0];
<a name="l02980"></a>02980                         traced[1] += xr*dipole[1] + yr*dipole[0];
<a name="l02981"></a>02981                         traced[2] += xr*dipole[2] + zr*dipole[0];
<a name="l02982"></a>02982                         traced[3] += yr*dipole[0] + xr*dipole[1];
<a name="l02983"></a>02983                         traced[4] += 2.0*yr*dipole[1];
<a name="l02984"></a>02984                         traced[5] += yr*dipole[2] + zr*dipole[1];
<a name="l02985"></a>02985                         traced[6] += zr*dipole[0] + xr*dipole[2];
<a name="l02986"></a>02986                         traced[7] += zr*dipole[1] + yr*dipole[2];
<a name="l02987"></a>02987                         traced[8] += 2.0*zr*dipole[2];
<a name="l02988"></a>02988                         qave = (traced[0] + traced[4] + traced[8]) / 3.0;
<a name="l02989"></a>02989                         sdhquadrupole[0] += 1.5*(traced[0] - qave);
<a name="l02990"></a>02990                         sdhquadrupole[1] += 1.5*(traced[1]);
<a name="l02991"></a>02991                         sdhquadrupole[2] += 1.5*(traced[2]);
<a name="l02992"></a>02992                         sdhquadrupole[3] += 1.5*(traced[3]);
<a name="l02993"></a>02993                         sdhquadrupole[4] += 1.5*(traced[4] - qave);
<a name="l02994"></a>02994                         sdhquadrupole[5] += 1.5*(traced[5]);
<a name="l02995"></a>02995                         sdhquadrupole[6] += 1.5*(traced[6]);
<a name="l02996"></a>02996                         sdhquadrupole[7] += 1.5*(traced[7]);
<a name="l02997"></a>02997                         sdhquadrupole[8] += 1.5*(traced[8] - qave);
<a name="l02998"></a>02998                         sdhquadrupole[0] += quadrupole[0];
<a name="l02999"></a>02999                         sdhquadrupole[1] += quadrupole[1];
<a name="l03000"></a>03000                         sdhquadrupole[2] += quadrupole[2];
<a name="l03001"></a>03001                         sdhquadrupole[3] += quadrupole[3];
<a name="l03002"></a>03002                         sdhquadrupole[4] += quadrupole[4];
<a name="l03003"></a>03003                         sdhquadrupole[5] += quadrupole[5];
<a name="l03004"></a>03004                         sdhquadrupole[6] += quadrupole[6];
<a name="l03005"></a>03005                         sdhquadrupole[7] += quadrupole[7];
<a name="l03006"></a>03006                         sdhquadrupole[8] += quadrupole[8];
<a name="l03007"></a>03007                     <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da92d27a9c40417842c09da484ab798a03">VCM_INDUCED</a>:
<a name="l03008"></a>03008                         dipole = Vatom_getInducedDipole(atom);
<a name="l03009"></a>03009                         sdhdipole[0] += dipole[0];
<a name="l03010"></a>03010                         sdhdipole[1] += dipole[1];
<a name="l03011"></a>03011                         sdhdipole[2] += dipole[2];
<a name="l03012"></a>03012                         traced[0] = 2.0*xr*dipole[0];
<a name="l03013"></a>03013                         traced[1] = xr*dipole[1] + yr*dipole[0];
<a name="l03014"></a>03014                         traced[2] = xr*dipole[2] + zr*dipole[0];
<a name="l03015"></a>03015                         traced[3] = yr*dipole[0] + xr*dipole[1];
<a name="l03016"></a>03016                         traced[4] = 2.0*yr*dipole[1];
<a name="l03017"></a>03017                         traced[5] = yr*dipole[2] + zr*dipole[1];
<a name="l03018"></a>03018                         traced[6] = zr*dipole[0] + xr*dipole[2];
<a name="l03019"></a>03019                         traced[7] = zr*dipole[1] + yr*dipole[2];
<a name="l03020"></a>03020                         traced[8] = 2.0*zr*dipole[2];
<a name="l03021"></a>03021                         qave = (traced[0] + traced[4] + traced[8]) / 3.0;
<a name="l03022"></a>03022                         sdhquadrupole[0] += 1.5*(traced[0] - qave);
<a name="l03023"></a>03023                         sdhquadrupole[1] += 1.5*(traced[1]);
<a name="l03024"></a>03024                         sdhquadrupole[2] += 1.5*(traced[2]);
<a name="l03025"></a>03025                         sdhquadrupole[3] += 1.5*(traced[3]);
<a name="l03026"></a>03026                         sdhquadrupole[4] += 1.5*(traced[4] - qave);
<a name="l03027"></a>03027                         sdhquadrupole[5] += 1.5*(traced[5]);
<a name="l03028"></a>03028                         sdhquadrupole[6] += 1.5*(traced[6]);
<a name="l03029"></a>03029                         sdhquadrupole[7] += 1.5*(traced[7]);
<a name="l03030"></a>03030                         sdhquadrupole[8] += 1.5*(traced[8] - qave);
<a name="l03031"></a>03031                     <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da0380d67590db2e7662a896e98521dcbf">VCM_NLINDUCED</a>:
<a name="l03032"></a>03032                         dipole = Vatom_getNLInducedDipole(atom);
<a name="l03033"></a>03033                         sdhdipole[0] += dipole[0];
<a name="l03034"></a>03034                         sdhdipole[1] += dipole[1];
<a name="l03035"></a>03035                         sdhdipole[2] += dipole[2];
<a name="l03036"></a>03036                         traced[0] = 2.0*xr*dipole[0];
<a name="l03037"></a>03037                         traced[1] = xr*dipole[1] + yr*dipole[0];
<a name="l03038"></a>03038                         traced[2] = xr*dipole[2] + zr*dipole[0];
<a name="l03039"></a>03039                         traced[3] = yr*dipole[0] + xr*dipole[1];
<a name="l03040"></a>03040                         traced[4] = 2.0*yr*dipole[1];
<a name="l03041"></a>03041                         traced[5] = yr*dipole[2] + zr*dipole[1];
<a name="l03042"></a>03042                         traced[6] = zr*dipole[0] + xr*dipole[2];
<a name="l03043"></a>03043                         traced[7] = zr*dipole[1] + yr*dipole[2];
<a name="l03044"></a>03044                         traced[8] = 2.0*zr*dipole[2];
<a name="l03045"></a>03045                         qave = (traced[0] + traced[4] + traced[8]) / 3.0;
<a name="l03046"></a>03046                         sdhquadrupole[0] += 1.5*(traced[0] - qave);
<a name="l03047"></a>03047                         sdhquadrupole[1] += 1.5*(traced[1]);
<a name="l03048"></a>03048                         sdhquadrupole[2] += 1.5*(traced[2]);
<a name="l03049"></a>03049                         sdhquadrupole[3] += 1.5*(traced[3]);
<a name="l03050"></a>03050                         sdhquadrupole[4] += 1.5*(traced[4] - qave);
<a name="l03051"></a>03051                         sdhquadrupole[5] += 1.5*(traced[5]);
<a name="l03052"></a>03052                         sdhquadrupole[6] += 1.5*(traced[6]);
<a name="l03053"></a>03053                         sdhquadrupole[7] += 1.5*(traced[7]);
<a name="l03054"></a>03054                         sdhquadrupole[8] += 1.5*(traced[8] - qave);
<a name="l03055"></a>03055 <span class="preprocessor">#endif </span><span class="comment">/* if defined(WITH_TINKER) */</span>
<a name="l03056"></a>03056                 }
<a name="l03057"></a>03057             }
<a name="l03058"></a>03058             <span class="comment">/* SDH dipole and traceless quadrupole values</span>
<a name="l03059"></a>03059 <span class="comment">             were checked against similar routines in TINKER</span>
<a name="l03060"></a>03060 <span class="comment">             for large proteins.</span>
<a name="l03061"></a>03061 <span class="comment"></span>
<a name="l03062"></a>03062 <span class="comment">             debye=4.8033324;</span>
<a name="l03063"></a>03063 <span class="comment">             printf(&quot;%6.3f, %6.3f, %6.3f\n&quot;, sdhdipole[0]*debye,</span>
<a name="l03064"></a>03064 <span class="comment">             sdhdipole[1]*debye, sdhdipole[2]*debye);</span>
<a name="l03065"></a>03065 <span class="comment">             printf(&quot;%6.3f\n&quot;, sdhquadrupole[0]*debye);</span>
<a name="l03066"></a>03066 <span class="comment">             printf(&quot;%6.3f %6.3f\n&quot;, sdhquadrupole[3]*debye,</span>
<a name="l03067"></a>03067 <span class="comment">             sdhquadrupole[4]*debye);</span>
<a name="l03068"></a>03068 <span class="comment">             printf(&quot;%6.3f %6.3f %6.3f\n&quot;, sdhquadrupole[6]*debye,</span>
<a name="l03069"></a>03069 <span class="comment">             sdhquadrupole[7]*debye, sdhquadrupole[8]*debye);</span>
<a name="l03070"></a>03070 <span class="comment">             */</span>
<a name="l03071"></a>03071 
<a name="l03072"></a>03072             bcfl2(size, position, sdhcharge, sdhdipole, sdhquadrupole,
<a name="l03073"></a>03073                   xkappa, eps_p, eps_w, T, thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>,
<a name="l03074"></a>03074                   thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>, nx, ny, nz);
<a name="l03075"></a>03075             <span class="keywordflow">break</span>;
<a name="l03076"></a>03076 
<a name="l03077"></a>03077         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a27a9bff27804c87341c57807c4be7a67">BCFL_MDH</a>:
<a name="l03078"></a>03078             <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l03079"></a>03079                 atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l03080"></a>03080                 position = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l03081"></a>03081                 charge = <a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*<a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l03082"></a>03082                 dipole = VNULL;
<a name="l03083"></a>03083                 quadrupole = VNULL;
<a name="l03084"></a>03084                 size = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l03085"></a>03085                 <span class="keywordflow">switch</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a311ed24e465040d2095273159d497995">chargeSrc</a>)
<a name="l03086"></a>03086                 {
<a name="l03087"></a>03087                     <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4daf34ddd788f7709bb1093266ae397826d">VCM_CHARGE</a>:
<a name="l03088"></a>03088                         ;
<a name="l03089"></a>03089 <span class="preprocessor">#if  defined(WITH_TINKER)</span>
<a name="l03090"></a>03090 <span class="preprocessor"></span>                    <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4dac6801535dedee5a72c8a91f5872731aa">VCM_PERMANENT</a>:
<a name="l03091"></a>03091                         dipole = Vatom_getDipole(atom);
<a name="l03092"></a>03092                         quadrupole = Vatom_getQuadrupole(atom);
<a name="l03093"></a>03093 
<a name="l03094"></a>03094                     <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da92d27a9c40417842c09da484ab798a03">VCM_INDUCED</a>:
<a name="l03095"></a>03095                         dipole = Vatom_getInducedDipole(atom);
<a name="l03096"></a>03096 
<a name="l03097"></a>03097                     <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da0380d67590db2e7662a896e98521dcbf">VCM_NLINDUCED</a>:
<a name="l03098"></a>03098                         dipole = Vatom_getNLInducedDipole(atom);
<a name="l03099"></a>03099 <span class="preprocessor">#endif</span>
<a name="l03100"></a>03100 <span class="preprocessor"></span>                }
<a name="l03101"></a>03101                 <a class="code" href="vpmg_8c.html#a787e4bcc6b7ec8a87aed577535268eb3" title="Increment all boundary points by pre1*(charge/d)*(exp(-xkappa*(d-size))/(1+xkappa*size) to add the ef...">bcfl1</a>(size, position, charge, xkappa, pre1,
<a name="l03102"></a>03102                       thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>,
<a name="l03103"></a>03103                       thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>, nx, ny, nz);
<a name="l03104"></a>03104             }
<a name="l03105"></a>03105             <span class="keywordflow">break</span>;
<a name="l03106"></a>03106 
<a name="l03107"></a>03107         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a4220be78e81865a755b75866cf05277f">BCFL_UNUSED</a>:
<a name="l03108"></a>03108             Vnm_print(2, <span class="stringliteral">&quot;bcCalc:  Invalid bcfl (%d)!\n&quot;</span>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a>);
<a name="l03109"></a>03109             VASSERT(0);
<a name="l03110"></a>03110 
<a name="l03111"></a>03111         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>:
<a name="l03112"></a>03112             Vnm_print(2, <span class="stringliteral">&quot;VPMG::bcCalc -- not appropriate for focusing!\n&quot;</span>);
<a name="l03113"></a>03113             VASSERT(0);
<a name="l03114"></a>03114 
<a name="l03115"></a>03115         <span class="keywordflow">default</span>:
<a name="l03116"></a>03116             Vnm_print(2, <span class="stringliteral">&quot;VPMG::bcCalc -- invalid boundary condition \</span>
<a name="l03117"></a>03117 <span class="stringliteral">flag (%d)!\n&quot;</span>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a>);
<a name="l03118"></a>03118             VASSERT(0);
<a name="l03119"></a>03119     }
<a name="l03120"></a>03120 }
<a name="l03121"></a>03121 
<a name="l03122"></a>03122 <span class="comment">/*</span>
<a name="l03123"></a>03123 <span class="comment"> Used by bcflnew</span>
<a name="l03124"></a>03124 <span class="comment"> */</span>
<a name="l03125"></a>03125 VPRIVATE <span class="keywordtype">int</span> gridPointIsValid(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> nx, <span class="keywordtype">int</span> ny, <span class="keywordtype">int</span> nz){
<a name="l03126"></a>03126 
<a name="l03127"></a>03127     <span class="keywordtype">int</span> isValid = 0;
<a name="l03128"></a>03128 
<a name="l03129"></a>03129     <span class="keywordflow">if</span>((k==0) || (k==nz-1)){
<a name="l03130"></a>03130         isValid = 1;
<a name="l03131"></a>03131     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>((j==0) || (j==ny-1)){
<a name="l03132"></a>03132         isValid = 1;
<a name="l03133"></a>03133     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>((i==0) || (i==nx-1)){
<a name="l03134"></a>03134         isValid = 1;
<a name="l03135"></a>03135     }
<a name="l03136"></a>03136 
<a name="l03137"></a>03137     <span class="keywordflow">return</span> isValid;
<a name="l03138"></a>03138 }
<a name="l03139"></a>03139 
<a name="l03140"></a>03140 <span class="comment">/*</span>
<a name="l03141"></a>03141 <span class="comment"> Used by bcflnew</span>
<a name="l03142"></a>03142 <span class="comment"> */</span>
<a name="l03143"></a>03143 <span class="preprocessor">#ifdef DEBUG_MAC_OSX_OCL</span>
<a name="l03144"></a>03144 <span class="preprocessor"></span><span class="preprocessor">#include &quot;mach_chud.h&quot;</span>
<a name="l03145"></a>03145 VPRIVATE <span class="keywordtype">void</span> packAtomsOpenCL(<span class="keywordtype">float</span> *ax, <span class="keywordtype">float</span> *ay, <span class="keywordtype">float</span> *az,
<a name="l03146"></a>03146                         <span class="keywordtype">float</span> *charge, <span class="keywordtype">float</span> *size, <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l03147"></a>03147 
<a name="l03148"></a>03148     <span class="keywordtype">int</span> i;
<a name="l03149"></a>03149     <span class="keywordtype">int</span> natoms;
<a name="l03150"></a>03150 
<a name="l03151"></a>03151     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom = VNULL;
<a name="l03152"></a>03152     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist = VNULL;
<a name="l03153"></a>03153 
<a name="l03154"></a>03154     alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l03155"></a>03155     natoms = <a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist);
<a name="l03156"></a>03156 
<a name="l03157"></a>03157     <span class="keywordflow">for</span>(i=0;i&lt;natoms;i++){
<a name="l03158"></a>03158         atom = &amp;(alist-&gt;<a class="code" href="structs_valist.html#abcf7d483565ac8ac342a6dd0af8ee18d">atoms</a>[i]);
<a name="l03159"></a>03159         charge[i] = <a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*atom-&gt;<a class="code" href="structs_vatom.html#ab3eb30b2f3f9c5ff812ea037220be570">charge</a>;
<a name="l03160"></a>03160         ax[i] = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0];
<a name="l03161"></a>03161         ay[i] = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1];
<a name="l03162"></a>03162         az[i] = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2];
<a name="l03163"></a>03163         size[i] = atom-&gt;<a class="code" href="structs_vatom.html#a3f67c53b80389c5f53961936edba04c9">radius</a>;
<a name="l03164"></a>03164     }
<a name="l03165"></a>03165 }
<a name="l03166"></a>03166 
<a name="l03167"></a>03167 <span class="comment">/*</span>
<a name="l03168"></a>03168 <span class="comment"> Used by bcflnew</span>
<a name="l03169"></a>03169 <span class="comment"> */</span>
<a name="l03170"></a>03170 VPRIVATE <span class="keywordtype">void</span> packUnpackOpenCL(<span class="keywordtype">int</span> nx, <span class="keywordtype">int</span> ny, <span class="keywordtype">int</span> nz, <span class="keywordtype">int</span> ngrid,
<a name="l03171"></a>03171                          <span class="keywordtype">float</span> *gx, <span class="keywordtype">float</span> *gy, <span class="keywordtype">float</span> *gz, <span class="keywordtype">float</span> *value,
<a name="l03172"></a>03172                          <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">int</span> pack){
<a name="l03173"></a>03173 
<a name="l03174"></a>03174     <span class="keywordtype">int</span> i,j,k,igrid;
<a name="l03175"></a>03175     <span class="keywordtype">int</span> x0,x1,y0,y1,z0,z1;
<a name="l03176"></a>03176 
<a name="l03177"></a>03177     <span class="keywordtype">float</span> gpos[3];
<a name="l03178"></a>03178     <span class="keywordtype">double</span> *xf, *yf, *zf;
<a name="l03179"></a>03179     <span class="keywordtype">double</span> *gxcf, *gycf, *gzcf;
<a name="l03180"></a>03180 
<a name="l03181"></a>03181     xf = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>;
<a name="l03182"></a>03182     yf = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>;
<a name="l03183"></a>03183     zf = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>;
<a name="l03184"></a>03184 
<a name="l03185"></a>03185     gxcf = thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>;
<a name="l03186"></a>03186     gycf = thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>;
<a name="l03187"></a>03187     gzcf = thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>;
<a name="l03188"></a>03188 
<a name="l03189"></a>03189     igrid = 0;
<a name="l03190"></a>03190     <span class="keywordflow">for</span>(k=0;k&lt;nz;k++){
<a name="l03191"></a>03191         gpos[2] = zf[k];
<a name="l03192"></a>03192         <span class="keywordflow">for</span>(j=0;j&lt;ny;j++){
<a name="l03193"></a>03193             gpos[1] = yf[j];
<a name="l03194"></a>03194             <span class="keywordflow">for</span>(i=0;i&lt;nx;i++){
<a name="l03195"></a>03195                 gpos[0] = xf[i];
<a name="l03196"></a>03196                 <span class="keywordflow">if</span>(gridPointIsValid(i, j, k, nx, ny, nz)){
<a name="l03197"></a>03197                     <span class="keywordflow">if</span>(pack != 0){
<a name="l03198"></a>03198                         gx[igrid] = gpos[0];
<a name="l03199"></a>03199                         gy[igrid] = gpos[1];
<a name="l03200"></a>03200                         gz[igrid] = gpos[2];
<a name="l03201"></a>03201 
<a name="l03202"></a>03202                         value[igrid] = 0.0;
<a name="l03203"></a>03203                     }<span class="keywordflow">else</span>{
<a name="l03204"></a>03204                         x0 = IJKx(j,k,0);
<a name="l03205"></a>03205                         x1 = IJKx(j,k,1);
<a name="l03206"></a>03206                         y0 = IJKy(i,k,0);
<a name="l03207"></a>03207                         y1 = IJKy(i,k,1);
<a name="l03208"></a>03208                         z0 = IJKz(i,j,0);
<a name="l03209"></a>03209                         z1 = IJKz(i,j,1);
<a name="l03210"></a>03210 
<a name="l03211"></a>03211                         <span class="keywordflow">if</span>(i==0){
<a name="l03212"></a>03212                             gxcf[x0] += value[igrid];
<a name="l03213"></a>03213                         }
<a name="l03214"></a>03214                         <span class="keywordflow">if</span>(i==nx-1){
<a name="l03215"></a>03215                             gxcf[x1] += value[igrid];
<a name="l03216"></a>03216                         }
<a name="l03217"></a>03217                         <span class="keywordflow">if</span>(j==0){
<a name="l03218"></a>03218                             gycf[y0] += value[igrid];
<a name="l03219"></a>03219                         }
<a name="l03220"></a>03220                         <span class="keywordflow">if</span>(j==ny-1){
<a name="l03221"></a>03221                             gycf[y1] += value[igrid];
<a name="l03222"></a>03222                         }
<a name="l03223"></a>03223                         <span class="keywordflow">if</span>(k==0){
<a name="l03224"></a>03224                             gzcf[z0] += value[igrid];
<a name="l03225"></a>03225                         }
<a name="l03226"></a>03226                         <span class="keywordflow">if</span>(k==nz-1){
<a name="l03227"></a>03227                             gzcf[z1] += value[igrid];
<a name="l03228"></a>03228                         }
<a name="l03229"></a>03229                     }
<a name="l03230"></a>03230 
<a name="l03231"></a>03231                     igrid++;
<a name="l03232"></a>03232                 } <span class="comment">//end is valid point</span>
<a name="l03233"></a>03233             } <span class="comment">//end i</span>
<a name="l03234"></a>03234         } <span class="comment">//end j</span>
<a name="l03235"></a>03235     } <span class="comment">//end k</span>
<a name="l03236"></a>03236 
<a name="l03237"></a>03237 }
<a name="l03238"></a>03238 
<a name="l03239"></a>03239 <span class="comment">/*</span>
<a name="l03240"></a>03240 <span class="comment"> bcflnew is an optimized replacement for bcfl1. bcfl1 is still used when TINKER</span>
<a name="l03241"></a>03241 <span class="comment"> support is compiled in.</span>
<a name="l03242"></a>03242 <span class="comment"> bcflnew uses: packUnpack, packAtoms, gridPointIsValid</span>
<a name="l03243"></a>03243 <span class="comment"> */</span>
<a name="l03244"></a>03244 VPRIVATE <span class="keywordtype">void</span> bcflnewOpenCL(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l03245"></a>03245 
<a name="l03246"></a>03246     <span class="keywordtype">int</span> i,j,k, iatom, igrid;
<a name="l03247"></a>03247     <span class="keywordtype">int</span> x0, x1, y0, y1, z0, z1;
<a name="l03248"></a>03248 
<a name="l03249"></a>03249     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l03250"></a>03250     <span class="keywordtype">int</span> natoms, ngrid, ngadj;
<a name="l03251"></a>03251 
<a name="l03252"></a>03252     <span class="keywordtype">float</span> dist, pre1, eps_w, eps_p, T, xkappa;
<a name="l03253"></a>03253 
<a name="l03254"></a>03254     <span class="keywordtype">float</span> *ax, *ay, *az;
<a name="l03255"></a>03255     <span class="keywordtype">float</span> *charge, *size, *val;
<a name="l03256"></a>03256 
<a name="l03257"></a>03257     <span class="keywordtype">float</span> *gx, *gy, *gz;
<a name="l03258"></a>03258 
<a name="l03259"></a>03259     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l03260"></a>03260 
<a name="l03261"></a>03261     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l03262"></a>03262     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l03263"></a>03263     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l03264"></a>03264 
<a name="l03265"></a>03265     eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l03266"></a>03266     eps_p = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l03267"></a>03267     T = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe);               <span class="comment">/* K             */</span>
<a name="l03268"></a>03268     pre1 = ((<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*eps_w*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T))*(1.0e10);
<a name="l03269"></a>03269     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);
<a name="l03270"></a>03270 
<a name="l03271"></a>03271     natoms = <a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>);
<a name="l03272"></a>03272     ngrid = 2*((nx*ny) + (ny*nz) + (nx*nz));
<a name="l03273"></a>03273     ngadj = ngrid + (512 - (ngrid &amp; 511));
<a name="l03274"></a>03274 
<a name="l03275"></a>03275     ax = (<span class="keywordtype">float</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03276"></a>03276     ay = (<span class="keywordtype">float</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03277"></a>03277     az = (<span class="keywordtype">float</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03278"></a>03278 
<a name="l03279"></a>03279     charge = (<span class="keywordtype">float</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03280"></a>03280     size = (<span class="keywordtype">float</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03281"></a>03281 
<a name="l03282"></a>03282     gx = (<span class="keywordtype">float</span>*)malloc(ngrid * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03283"></a>03283     gy = (<span class="keywordtype">float</span>*)malloc(ngrid * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03284"></a>03284     gz = (<span class="keywordtype">float</span>*)malloc(ngrid * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03285"></a>03285 
<a name="l03286"></a>03286     val = (<span class="keywordtype">float</span>*)malloc(ngrid * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l03287"></a>03287 
<a name="l03288"></a>03288     packAtomsOpenCL(ax,ay,az,charge,size,thee);
<a name="l03289"></a>03289     packUnpackOpenCL(nx,ny,nz,ngrid,gx,gy,gz,val,thee,1);
<a name="l03290"></a>03290 
<a name="l03291"></a>03291     runMDHCL(ngrid,natoms,ngadj,ax,ay,az,gx,gy,gz,charge,size,xkappa,pre1,val);
<a name="l03292"></a>03292 
<a name="l03293"></a>03293     packUnpackOpenCL(nx,ny,nz,ngrid,gx,gy,gz,val,thee,0);
<a name="l03294"></a>03294 
<a name="l03295"></a>03295     free(ax);
<a name="l03296"></a>03296     free(ay);
<a name="l03297"></a>03297     free(az);
<a name="l03298"></a>03298     free(charge);
<a name="l03299"></a>03299     free(size);
<a name="l03300"></a>03300 
<a name="l03301"></a>03301     free(gx);
<a name="l03302"></a>03302     free(gy);
<a name="l03303"></a>03303     free(gz);
<a name="l03304"></a>03304     free(val);
<a name="l03305"></a>03305 }
<a name="l03306"></a>03306 <span class="preprocessor">#endif</span>
<a name="l03307"></a>03307 <span class="preprocessor"></span>
<a name="l03308"></a>03308 VPRIVATE <span class="keywordtype">void</span> packAtoms(<span class="keywordtype">double</span> *ax, <span class="keywordtype">double</span> *ay, <span class="keywordtype">double</span> *az,
<a name="l03309"></a>03309                         <span class="keywordtype">double</span> *charge, <span class="keywordtype">double</span> *size, <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l03310"></a>03310 
<a name="l03311"></a>03311     <span class="keywordtype">int</span> i;
<a name="l03312"></a>03312     <span class="keywordtype">int</span> natoms;
<a name="l03313"></a>03313 
<a name="l03314"></a>03314     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom = VNULL;
<a name="l03315"></a>03315     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist = VNULL;
<a name="l03316"></a>03316 
<a name="l03317"></a>03317     alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l03318"></a>03318     natoms = <a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist);
<a name="l03319"></a>03319 
<a name="l03320"></a>03320     <span class="keywordflow">for</span>(i=0;i&lt;natoms;i++){
<a name="l03321"></a>03321         atom = &amp;(alist-&gt;<a class="code" href="structs_valist.html#abcf7d483565ac8ac342a6dd0af8ee18d">atoms</a>[i]);
<a name="l03322"></a>03322         charge[i] = <a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*atom-&gt;<a class="code" href="structs_vatom.html#ab3eb30b2f3f9c5ff812ea037220be570">charge</a>;
<a name="l03323"></a>03323         ax[i] = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[0];
<a name="l03324"></a>03324         ay[i] = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[1];
<a name="l03325"></a>03325         az[i] = atom-&gt;<a class="code" href="structs_vatom.html#ab2bf41ca00e31fce6d10a4494db3d515">position</a>[2];
<a name="l03326"></a>03326         size[i] = atom-&gt;<a class="code" href="structs_vatom.html#a3f67c53b80389c5f53961936edba04c9">radius</a>;
<a name="l03327"></a>03327     }
<a name="l03328"></a>03328 }
<a name="l03329"></a>03329 
<a name="l03330"></a>03330 <span class="comment">/*</span>
<a name="l03331"></a>03331 <span class="comment"> Used by bcflnew</span>
<a name="l03332"></a>03332 <span class="comment"> */</span>
<a name="l03333"></a>03333 VPRIVATE <span class="keywordtype">void</span> packUnpack(<span class="keywordtype">int</span> nx, <span class="keywordtype">int</span> ny, <span class="keywordtype">int</span> nz, <span class="keywordtype">int</span> ngrid,
<a name="l03334"></a>03334                          <span class="keywordtype">double</span> *gx, <span class="keywordtype">double</span> *gy, <span class="keywordtype">double</span> *gz, <span class="keywordtype">double</span> *value,
<a name="l03335"></a>03335                          <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">int</span> pack){
<a name="l03336"></a>03336 
<a name="l03337"></a>03337     <span class="keywordtype">int</span> i,j,k,igrid;
<a name="l03338"></a>03338     <span class="keywordtype">int</span> x0,x1,y0,y1,z0,z1;
<a name="l03339"></a>03339 
<a name="l03340"></a>03340     <span class="keywordtype">double</span> gpos[3];
<a name="l03341"></a>03341     <span class="keywordtype">double</span> *xf, *yf, *zf;
<a name="l03342"></a>03342     <span class="keywordtype">double</span> *gxcf, *gycf, *gzcf;
<a name="l03343"></a>03343 
<a name="l03344"></a>03344     xf = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>;
<a name="l03345"></a>03345     yf = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>;
<a name="l03346"></a>03346     zf = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>;
<a name="l03347"></a>03347 
<a name="l03348"></a>03348     gxcf = thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>;
<a name="l03349"></a>03349     gycf = thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>;
<a name="l03350"></a>03350     gzcf = thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>;
<a name="l03351"></a>03351 
<a name="l03352"></a>03352     igrid = 0;
<a name="l03353"></a>03353     <span class="keywordflow">for</span>(k=0;k&lt;nz;k++){
<a name="l03354"></a>03354         gpos[2] = zf[k];
<a name="l03355"></a>03355         <span class="keywordflow">for</span>(j=0;j&lt;ny;j++){
<a name="l03356"></a>03356             gpos[1] = yf[j];
<a name="l03357"></a>03357             <span class="keywordflow">for</span>(i=0;i&lt;nx;i++){
<a name="l03358"></a>03358                 gpos[0] = xf[i];
<a name="l03359"></a>03359                 <span class="keywordflow">if</span>(gridPointIsValid(i, j, k, nx, ny, nz)){
<a name="l03360"></a>03360                     <span class="keywordflow">if</span>(pack != 0){
<a name="l03361"></a>03361                         gx[igrid] = gpos[0];
<a name="l03362"></a>03362                         gy[igrid] = gpos[1];
<a name="l03363"></a>03363                         gz[igrid] = gpos[2];
<a name="l03364"></a>03364 
<a name="l03365"></a>03365                         value[igrid] = 0.0;
<a name="l03366"></a>03366                     }<span class="keywordflow">else</span>{
<a name="l03367"></a>03367                         x0 = IJKx(j,k,0);
<a name="l03368"></a>03368                         x1 = IJKx(j,k,1);
<a name="l03369"></a>03369                         y0 = IJKy(i,k,0);
<a name="l03370"></a>03370                         y1 = IJKy(i,k,1);
<a name="l03371"></a>03371                         z0 = IJKz(i,j,0);
<a name="l03372"></a>03372                         z1 = IJKz(i,j,1);
<a name="l03373"></a>03373 
<a name="l03374"></a>03374                         <span class="keywordflow">if</span>(i==0){
<a name="l03375"></a>03375                             gxcf[x0] += value[igrid];
<a name="l03376"></a>03376                         }
<a name="l03377"></a>03377                         <span class="keywordflow">if</span>(i==nx-1){
<a name="l03378"></a>03378                             gxcf[x1] += value[igrid];
<a name="l03379"></a>03379                         }
<a name="l03380"></a>03380                         <span class="keywordflow">if</span>(j==0){
<a name="l03381"></a>03381                             gycf[y0] += value[igrid];
<a name="l03382"></a>03382                         }
<a name="l03383"></a>03383                         <span class="keywordflow">if</span>(j==ny-1){
<a name="l03384"></a>03384                             gycf[y1] += value[igrid];
<a name="l03385"></a>03385                         }
<a name="l03386"></a>03386                         <span class="keywordflow">if</span>(k==0){
<a name="l03387"></a>03387                             gzcf[z0] += value[igrid];
<a name="l03388"></a>03388                         }
<a name="l03389"></a>03389                         <span class="keywordflow">if</span>(k==nz-1){
<a name="l03390"></a>03390                             gzcf[z1] += value[igrid];
<a name="l03391"></a>03391                         }
<a name="l03392"></a>03392                     }
<a name="l03393"></a>03393 
<a name="l03394"></a>03394                     igrid++;
<a name="l03395"></a>03395                 } <span class="comment">//end is valid point</span>
<a name="l03396"></a>03396             } <span class="comment">//end i</span>
<a name="l03397"></a>03397         } <span class="comment">//end j</span>
<a name="l03398"></a>03398     } <span class="comment">//end k</span>
<a name="l03399"></a>03399 
<a name="l03400"></a>03400 }
<a name="l03401"></a>03401 
<a name="l03402"></a>03402 VPRIVATE <span class="keywordtype">void</span> bcflnew(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l03403"></a>03403 
<a name="l03404"></a>03404     <span class="keywordtype">int</span> i,j,k, iatom, igrid;
<a name="l03405"></a>03405     <span class="keywordtype">int</span> x0, x1, y0, y1, z0, z1;
<a name="l03406"></a>03406 
<a name="l03407"></a>03407     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l03408"></a>03408     <span class="keywordtype">int</span> natoms, ngrid;
<a name="l03409"></a>03409 
<a name="l03410"></a>03410     <span class="keywordtype">double</span> dist, pre1, eps_w, eps_p, T, xkappa;
<a name="l03411"></a>03411 
<a name="l03412"></a>03412     <span class="keywordtype">double</span> *ax, *ay, *az;
<a name="l03413"></a>03413     <span class="keywordtype">double</span> *charge, *size, *val;
<a name="l03414"></a>03414 
<a name="l03415"></a>03415     <span class="keywordtype">double</span> *gx, *gy, *gz;
<a name="l03416"></a>03416 
<a name="l03417"></a>03417     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l03418"></a>03418 
<a name="l03419"></a>03419     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l03420"></a>03420     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l03421"></a>03421     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l03422"></a>03422 
<a name="l03423"></a>03423     eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l03424"></a>03424     eps_p = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l03425"></a>03425     T = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe);               <span class="comment">/* K             */</span>
<a name="l03426"></a>03426     pre1 = ((<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*eps_w*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T))*(1.0e10);
<a name="l03427"></a>03427     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);
<a name="l03428"></a>03428 
<a name="l03429"></a>03429     natoms = <a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>);
<a name="l03430"></a>03430     ngrid = 2*((nx*ny) + (ny*nz) + (nx*nz));
<a name="l03431"></a>03431 
<a name="l03432"></a>03432     ax = (<span class="keywordtype">double</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03433"></a>03433     ay = (<span class="keywordtype">double</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03434"></a>03434     az = (<span class="keywordtype">double</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03435"></a>03435 
<a name="l03436"></a>03436     charge = (<span class="keywordtype">double</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03437"></a>03437     size = (<span class="keywordtype">double</span>*)malloc(natoms * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03438"></a>03438 
<a name="l03439"></a>03439     gx = (<span class="keywordtype">double</span>*)malloc(ngrid * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03440"></a>03440     gy = (<span class="keywordtype">double</span>*)malloc(ngrid * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03441"></a>03441     gz = (<span class="keywordtype">double</span>*)malloc(ngrid * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03442"></a>03442 
<a name="l03443"></a>03443     val = (<span class="keywordtype">double</span>*)malloc(ngrid * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03444"></a>03444 
<a name="l03445"></a>03445     packAtoms(ax,ay,az,charge,size,thee);
<a name="l03446"></a>03446     packUnpack(nx,ny,nz,ngrid,gx,gy,gz,val,thee,1);
<a name="l03447"></a>03447 
<a name="l03448"></a>03448     <span class="keywordflow">if</span>(xkappa &gt; VSMALL){
<a name="l03449"></a>03449 <span class="preprocessor">#pragma omp parallel for default(shared) private(igrid,iatom,dist)</span>
<a name="l03450"></a>03450 <span class="preprocessor"></span>        <span class="keywordflow">for</span>(igrid=0;igrid&lt;ngrid;igrid++){
<a name="l03451"></a>03451             <span class="keywordflow">for</span>(iatom=0; iatom&lt;natoms; iatom++){
<a name="l03452"></a>03452                 dist = VSQRT(VSQR(gx[igrid]-ax[iatom]) + VSQR(gy[igrid]-ay[iatom])
<a name="l03453"></a>03453                              + VSQR(gz[igrid]-az[iatom]));
<a name="l03454"></a>03454                 val[igrid] += pre1*(charge[iatom]/dist)*VEXP(-xkappa*(dist-size[iatom]))
<a name="l03455"></a>03455                 / (1+xkappa*size[iatom]);
<a name="l03456"></a>03456             }
<a name="l03457"></a>03457         }
<a name="l03458"></a>03458     }<span class="keywordflow">else</span>{
<a name="l03459"></a>03459 <span class="preprocessor">#pragma omp parallel for default(shared) private(igrid,iatom,dist)</span>
<a name="l03460"></a>03460 <span class="preprocessor"></span>        <span class="keywordflow">for</span>(igrid=0;igrid&lt;ngrid;igrid++){
<a name="l03461"></a>03461             <span class="keywordflow">for</span>(iatom=0; iatom&lt;natoms; iatom++){
<a name="l03462"></a>03462                 dist = VSQRT(VSQR(gx[igrid]-ax[iatom]) + VSQR(gy[igrid]-ay[iatom])
<a name="l03463"></a>03463                              + VSQR(gz[igrid]-az[iatom]));
<a name="l03464"></a>03464                 val[igrid] += pre1*(charge[iatom]/dist);
<a name="l03465"></a>03465             }
<a name="l03466"></a>03466         }
<a name="l03467"></a>03467     }
<a name="l03468"></a>03468     packUnpack(nx,ny,nz,ngrid,gx,gy,gz,val,thee,0);
<a name="l03469"></a>03469 
<a name="l03470"></a>03470     free(ax);
<a name="l03471"></a>03471     free(ay);
<a name="l03472"></a>03472     free(az);
<a name="l03473"></a>03473     free(charge);
<a name="l03474"></a>03474     free(size);
<a name="l03475"></a>03475 
<a name="l03476"></a>03476     free(gx);
<a name="l03477"></a>03477     free(gy);
<a name="l03478"></a>03478     free(gz);
<a name="l03479"></a>03479     free(val);
<a name="l03480"></a>03480 }
<a name="l03481"></a>03481 
<a name="l03482"></a><a class="code" href="vpmg_8h.html#a0f71bb1c4fe48352092a82c88c5eac3e">03482</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(<span class="keywordtype">double</span> r, <span class="keywordtype">double</span> kappa, <span class="keywordtype">double</span> eps_p,
<a name="l03483"></a>03483                           <span class="keywordtype">double</span> eps_w, <span class="keywordtype">double</span> rad, <span class="keywordtype">double</span> tsr[3]) {
<a name="l03484"></a>03484     <span class="keywordtype">double</span> r2,r3,r5;
<a name="l03485"></a>03485     <span class="keywordtype">double</span> eps_r;
<a name="l03486"></a>03486     <span class="keywordtype">double</span> ka,ka2,ka3;
<a name="l03487"></a>03487     <span class="keywordtype">double</span> kr,kr2,kr3;
<a name="l03488"></a>03488 
<a name="l03489"></a>03489     <span class="comment">/*</span>
<a name="l03490"></a>03490 <span class="comment">     Below an attempt is made to explain the potential outside of a</span>
<a name="l03491"></a>03491 <span class="comment">     multipole located at the center of spherical cavity of dieletric</span>
<a name="l03492"></a>03492 <span class="comment">     eps_p, with dielectric eps_w outside (and possibly kappa &gt; 0).</span>
<a name="l03493"></a>03493 <span class="comment"></span>
<a name="l03494"></a>03494 <span class="comment"></span>
<a name="l03495"></a>03495 <span class="comment">     First, eps_p = 1.0</span>
<a name="l03496"></a>03496 <span class="comment">     eps_w = 1.0</span>
<a name="l03497"></a>03497 <span class="comment">     kappa = 0.0</span>
<a name="l03498"></a>03498 <span class="comment"></span>
<a name="l03499"></a>03499 <span class="comment">     The general form for the potential of a traceless multipole tensor</span>
<a name="l03500"></a>03500 <span class="comment">     of rank n in vacuum is:</span>
<a name="l03501"></a>03501 <span class="comment"></span>
<a name="l03502"></a>03502 <span class="comment">     V(r) = (-1)^n * u . n . Del^n (1/r)</span>
<a name="l03503"></a>03503 <span class="comment"></span>
<a name="l03504"></a>03504 <span class="comment">     where</span>
<a name="l03505"></a>03505 <span class="comment">     u                     is a multipole of order n (3^n components)</span>
<a name="l03506"></a>03506 <span class="comment">     u . n. Del^n (1/r)    is the contraction of u with the nth</span>
<a name="l03507"></a>03507 <span class="comment">     derivative of 1/r</span>
<a name="l03508"></a>03508 <span class="comment"></span>
<a name="l03509"></a>03509 <span class="comment">     for example, if n = 1, the dipole potential is</span>
<a name="l03510"></a>03510 <span class="comment">     V_vac(r) = (-1)*[ux*x + uy*y + uz*z]/r^3</span>
<a name="l03511"></a>03511 <span class="comment"></span>
<a name="l03512"></a>03512 <span class="comment">     This function returns the parts of V(r) for multipoles of</span>
<a name="l03513"></a>03513 <span class="comment">     order 0, 1 and 2 that are independent of the contraction.</span>
<a name="l03514"></a>03514 <span class="comment"></span>
<a name="l03515"></a>03515 <span class="comment">     For the vacuum example, this would be 1/r, -1/r^3 and 3/r^5</span>
<a name="l03516"></a>03516 <span class="comment">     respectively.</span>
<a name="l03517"></a>03517 <span class="comment"></span>
<a name="l03518"></a>03518 <span class="comment">     *** Note that this requires that the quadrupole is</span>
<a name="l03519"></a>03519 <span class="comment">     traceless. If not, the diagonal quadrupole potential changes</span>
<a name="l03520"></a>03520 <span class="comment">     from</span>
<a name="l03521"></a>03521 <span class="comment">     qaa *  3*a^2/r^5</span>
<a name="l03522"></a>03522 <span class="comment">     to</span>
<a name="l03523"></a>03523 <span class="comment">     qaa * (3*a^2/r^5 - 1/r^3a )</span>
<a name="l03524"></a>03524 <span class="comment">     where we sum over the trace; a = x, y and z.</span>
<a name="l03525"></a>03525 <span class="comment"></span>
<a name="l03526"></a>03526 <span class="comment">     (In other words, the -1/r^3 term cancels for a traceless quadrupole.</span>
<a name="l03527"></a>03527 <span class="comment">     qxx + qyy + qzz = 0</span>
<a name="l03528"></a>03528 <span class="comment">     such that</span>
<a name="l03529"></a>03529 <span class="comment">     -(qxx + qyy + qzz)/r^3 = 0</span>
<a name="l03530"></a>03530 <span class="comment"></span>
<a name="l03531"></a>03531 <span class="comment">     For quadrupole with trace:</span>
<a name="l03532"></a>03532 <span class="comment">     qxx + qyy + qzz != 0</span>
<a name="l03533"></a>03533 <span class="comment">     such that</span>
<a name="l03534"></a>03534 <span class="comment">     -(qxx + qyy + qzz)/r^3 != 0</span>
<a name="l03535"></a>03535 <span class="comment">     )</span>
<a name="l03536"></a>03536 <span class="comment"></span>
<a name="l03537"></a>03537 <span class="comment">     ========================================================================</span>
<a name="l03538"></a>03538 <span class="comment"></span>
<a name="l03539"></a>03539 <span class="comment">     eps_p != 1 or eps_w != 1</span>
<a name="l03540"></a>03540 <span class="comment">     kappa = 0.0</span>
<a name="l03541"></a>03541 <span class="comment"></span>
<a name="l03542"></a>03542 <span class="comment">     If the multipole is placed at the center of a sphere with</span>
<a name="l03543"></a>03543 <span class="comment">     dieletric eps_p in a solvent of dielectric eps_w, the potential</span>
<a name="l03544"></a>03544 <span class="comment">     outside the sphere is the solution to the Laplace equation:</span>
<a name="l03545"></a>03545 <span class="comment"></span>
<a name="l03546"></a>03546 <span class="comment">     V(r) = 1/eps_w * (2*n+1)*eps_r/(n+(n+1)*eps_r)</span>
<a name="l03547"></a>03547 <span class="comment">     * (-1)^n * u . n . Del^n (1/r)</span>
<a name="l03548"></a>03548 <span class="comment">     where</span>
<a name="l03549"></a>03549 <span class="comment">     eps_r = eps_w / eps_p</span>
<a name="l03550"></a>03550 <span class="comment">     is the ratio of solvent to solute dielectric</span>
<a name="l03551"></a>03551 <span class="comment"></span>
<a name="l03552"></a>03552 <span class="comment">     ========================================================================</span>
<a name="l03553"></a>03553 <span class="comment"></span>
<a name="l03554"></a>03554 <span class="comment">     kappa &gt; 0</span>
<a name="l03555"></a>03555 <span class="comment"></span>
<a name="l03556"></a>03556 <span class="comment">     Finally, if the region outside the sphere is treated by the linearized</span>
<a name="l03557"></a>03557 <span class="comment">     PB equation with Debye-Huckel parameter kappa, the solution is:</span>
<a name="l03558"></a>03558 <span class="comment"></span>
<a name="l03559"></a>03559 <span class="comment">     V(r) = kappa/eps_w * alpha_n(kappa*a) * K_n(kappa*r) * r^(n+1)/a^n</span>
<a name="l03560"></a>03560 <span class="comment">     * (-1)^n * u . n . Del^n (1/r)</span>
<a name="l03561"></a>03561 <span class="comment">     where</span>
<a name="l03562"></a>03562 <span class="comment">     alpha_n(x) is [(2n + 1) / x] / [(n*K_n(x)/eps_r) - x*K_n&#39;(x)]</span>
<a name="l03563"></a>03563 <span class="comment">     K_n(x) are modified spherical Bessel functions of the third kind.</span>
<a name="l03564"></a>03564 <span class="comment">     K_n&#39;(x) is the derivative of K_n(x)</span>
<a name="l03565"></a>03565 <span class="comment">     */</span>
<a name="l03566"></a>03566 
<a name="l03567"></a>03567     eps_r = eps_w/eps_p;
<a name="l03568"></a>03568     r2 = r*r;
<a name="l03569"></a>03569     r3 = r2*r;
<a name="l03570"></a>03570     r5 = r3*r2;
<a name="l03571"></a>03571     tsr[0] = (1.0/eps_w)/r;
<a name="l03572"></a>03572     tsr[1] = (1.0/eps_w)*(-1.0)/r3;
<a name="l03573"></a>03573     tsr[2] = (1.0/eps_w)*(3.0)/r5;
<a name="l03574"></a>03574     <span class="keywordflow">if</span> (kappa &lt; VSMALL) {
<a name="l03575"></a>03575         tsr[1] = (3.0*eps_r)/(1.0 + 2.0*eps_r)*tsr[1];
<a name="l03576"></a>03576         tsr[2] = (5.0*eps_r)/(2.0 + 3.0*eps_r)*tsr[2];
<a name="l03577"></a>03577     } <span class="keywordflow">else</span> {
<a name="l03578"></a>03578         ka = kappa*rad;
<a name="l03579"></a>03579         ka2 = ka*ka;
<a name="l03580"></a>03580         ka3 = ka2*ka;
<a name="l03581"></a>03581         kr = kappa*r;
<a name="l03582"></a>03582         kr2 = kr*kr;
<a name="l03583"></a>03583         kr3 = kr2*kr;
<a name="l03584"></a>03584         tsr[0] = exp(ka-kr) / (1.0 + ka) * tsr[0];
<a name="l03585"></a>03585         tsr[1] = 3.0*eps_r*exp(ka-kr)*(1.0 + kr) * tsr[1];
<a name="l03586"></a>03586         tsr[1] = tsr[1] / (1.0 + ka + eps_r*(2.0 + 2.0*ka + ka2));
<a name="l03587"></a>03587         tsr[2] = 5.0*eps_r*exp(ka-kr)*(3.0 + 3.0*kr + kr2) * tsr[2];
<a name="l03588"></a>03588         tsr[2] = tsr[2]/(6.0+6.0*ka+2.0*ka2+eps_r*(9.0+9.0*ka+4.0*ka2+ka3));
<a name="l03589"></a>03589     }
<a name="l03590"></a>03590 }
<a name="l03591"></a>03591 
<a name="l03592"></a>03592 VPRIVATE <span class="keywordtype">void</span> bcfl_sdh(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l03593"></a>03593 
<a name="l03594"></a>03594     <span class="keywordtype">int</span> i,j,k,iatom;
<a name="l03595"></a>03595     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l03596"></a>03596 
<a name="l03597"></a>03597     <span class="keywordtype">double</span> size, *position, charge, xkappa, eps_w, eps_p, T, pre, dist;
<a name="l03598"></a>03598     <span class="keywordtype">double</span> sdhcharge, sdhdipole[3], traced[9], sdhquadrupole[9];
<a name="l03599"></a>03599     <span class="keywordtype">double</span> *dipole, *quadrupole;
<a name="l03600"></a>03600 
<a name="l03601"></a>03601     <span class="keywordtype">double</span> val, *apos, gpos[3], tensor[3], qave;
<a name="l03602"></a>03602     <span class="keywordtype">double</span> ux, uy, uz, xr, yr, zr;
<a name="l03603"></a>03603     <span class="keywordtype">double</span> qxx,qxy,qxz,qyx,qyy,qyz,qzx,qzy,qzz;
<a name="l03604"></a>03604 
<a name="l03605"></a>03605     <span class="keywordtype">double</span> *xf, *yf, *zf;
<a name="l03606"></a>03606     <span class="keywordtype">double</span> *gxcf, *gycf, *gzcf;
<a name="l03607"></a>03607 
<a name="l03608"></a>03608     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l03609"></a>03609     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l03610"></a>03610     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l03611"></a>03611 
<a name="l03612"></a>03612     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l03613"></a>03613     alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l03614"></a>03614     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l03615"></a>03615     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l03616"></a>03616     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l03617"></a>03617 
<a name="l03618"></a>03618     xf = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>;
<a name="l03619"></a>03619     yf = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>;
<a name="l03620"></a>03620     zf = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>;
<a name="l03621"></a>03621 
<a name="l03622"></a>03622     gxcf = thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>;
<a name="l03623"></a>03623     gycf = thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>;
<a name="l03624"></a>03624     gzcf = thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>;
<a name="l03625"></a>03625 
<a name="l03626"></a>03626     <span class="comment">/* For each &quot;atom&quot; (only one for bcfl=1), we use the following formula to</span>
<a name="l03627"></a>03627 <span class="comment">     * calculate the boundary conditions:</span>
<a name="l03628"></a>03628 <span class="comment">     *    g(x) = \frac{q e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l03629"></a>03629 <span class="comment">     *          * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l03630"></a>03630 <span class="comment">     *          * 1/d</span>
<a name="l03631"></a>03631 <span class="comment">     * where d = ||x - x_0|| (in m) and a is the size of the atom (in m).</span>
<a name="l03632"></a>03632 <span class="comment">     * We only need to evaluate some of these prefactors once:</span>
<a name="l03633"></a>03633 <span class="comment">     *    pre1 = \frac{e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l03634"></a>03634 <span class="comment">     * which gives the potential as</span>
<a name="l03635"></a>03635 <span class="comment">     *    g(x) = pre1 * q/d * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l03636"></a>03636 <span class="comment">     */</span>
<a name="l03637"></a>03637     eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l03638"></a>03638     eps_p = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l03639"></a>03639     T = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe);               <span class="comment">/* K             */</span>
<a name="l03640"></a>03640 
<a name="l03641"></a>03641     pre = (<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T);
<a name="l03642"></a>03642     pre = pre*(1.0e10);
<a name="l03643"></a>03643 
<a name="l03644"></a>03644     <span class="comment">/* Finally, if we convert keep xkappa in A^{-1} and scale pre1 by</span>
<a name="l03645"></a>03645 <span class="comment">     * m/A, then we will only need to deal with distances and sizes in</span>
<a name="l03646"></a>03646 <span class="comment">     * Angstroms rather than meters.                                       */</span>
<a name="l03647"></a>03647     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);              <span class="comment">/* A^{-1}        */</span>
<a name="l03648"></a>03648 
<a name="l03649"></a>03649     <span class="comment">/* Solute size and position */</span>
<a name="l03650"></a>03650     size = <a class="code" href="group___vpbe.html#gabc3d4ee6a7571b191b583e2b49d1742a" title="Get sphere radius which bounds biomolecule.">Vpbe_getSoluteRadius</a>(pbe);
<a name="l03651"></a>03651     position = <a class="code" href="group___vpbe.html#ga8003268df05a845c934fa8be679f834c" title="Get coordinates of solute center.">Vpbe_getSoluteCenter</a>(pbe);
<a name="l03652"></a>03652 
<a name="l03653"></a>03653     sdhcharge = 0.0;
<a name="l03654"></a>03654     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) sdhdipole[i] = 0.0;
<a name="l03655"></a>03655     <span class="keywordflow">for</span> (i=0; i&lt;9; i++) sdhquadrupole[i] = 0.0;
<a name="l03656"></a>03656 
<a name="l03657"></a>03657     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l03658"></a>03658         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l03659"></a>03659         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l03660"></a>03660         xr = apos[0] - position[0];
<a name="l03661"></a>03661         yr = apos[1] - position[1];
<a name="l03662"></a>03662         zr = apos[2] - position[2];
<a name="l03663"></a>03663         <span class="keywordflow">switch</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a311ed24e465040d2095273159d497995">chargeSrc</a>) {
<a name="l03664"></a>03664             <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4daf34ddd788f7709bb1093266ae397826d">VCM_CHARGE</a>:
<a name="l03665"></a>03665                 charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l03666"></a>03666                 sdhcharge += charge;
<a name="l03667"></a>03667                 sdhdipole[0] += xr * charge;
<a name="l03668"></a>03668                 sdhdipole[1] += yr * charge;
<a name="l03669"></a>03669                 sdhdipole[2] += zr * charge;
<a name="l03670"></a>03670                 traced[0] = xr*xr*charge;
<a name="l03671"></a>03671                 traced[1] = xr*yr*charge;
<a name="l03672"></a>03672                 traced[2] = xr*zr*charge;
<a name="l03673"></a>03673                 traced[3] = yr*xr*charge;
<a name="l03674"></a>03674                 traced[4] = yr*yr*charge;
<a name="l03675"></a>03675                 traced[5] = yr*zr*charge;
<a name="l03676"></a>03676                 traced[6] = zr*xr*charge;
<a name="l03677"></a>03677                 traced[7] = zr*yr*charge;
<a name="l03678"></a>03678                 traced[8] = zr*zr*charge;
<a name="l03679"></a>03679                 qave = (traced[0] + traced[4] + traced[8]) / 3.0;
<a name="l03680"></a>03680                 sdhquadrupole[0] += 1.5*(traced[0] - qave);
<a name="l03681"></a>03681                 sdhquadrupole[1] += 1.5*(traced[1]);
<a name="l03682"></a>03682                 sdhquadrupole[2] += 1.5*(traced[2]);
<a name="l03683"></a>03683                 sdhquadrupole[3] += 1.5*(traced[3]);
<a name="l03684"></a>03684                 sdhquadrupole[4] += 1.5*(traced[4] - qave);
<a name="l03685"></a>03685                 sdhquadrupole[5] += 1.5*(traced[5]);
<a name="l03686"></a>03686                 sdhquadrupole[6] += 1.5*(traced[6]);
<a name="l03687"></a>03687                 sdhquadrupole[7] += 1.5*(traced[7]);
<a name="l03688"></a>03688                 sdhquadrupole[8] += 1.5*(traced[8] - qave);
<a name="l03689"></a>03689 <span class="preprocessor">#if defined(WITH_TINKER)</span>
<a name="l03690"></a>03690 <span class="preprocessor"></span>            <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4dac6801535dedee5a72c8a91f5872731aa">VCM_PERMANENT</a>:
<a name="l03691"></a>03691                 charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l03692"></a>03692                 dipole = Vatom_getDipole(atom);
<a name="l03693"></a>03693                 quadrupole = Vatom_getQuadrupole(atom);
<a name="l03694"></a>03694                 sdhcharge += charge;
<a name="l03695"></a>03695                 sdhdipole[0] += xr * charge;
<a name="l03696"></a>03696                 sdhdipole[1] += yr * charge;
<a name="l03697"></a>03697                 sdhdipole[2] += zr * charge;
<a name="l03698"></a>03698                 traced[0] = xr*xr*charge;
<a name="l03699"></a>03699                 traced[1] = xr*yr*charge;
<a name="l03700"></a>03700                 traced[2] = xr*zr*charge;
<a name="l03701"></a>03701                 traced[3] = yr*xr*charge;
<a name="l03702"></a>03702                 traced[4] = yr*yr*charge;
<a name="l03703"></a>03703                 traced[5] = yr*zr*charge;
<a name="l03704"></a>03704                 traced[6] = zr*xr*charge;
<a name="l03705"></a>03705                 traced[7] = zr*yr*charge;
<a name="l03706"></a>03706                 traced[8] = zr*zr*charge;
<a name="l03707"></a>03707                 sdhdipole[0] += dipole[0];
<a name="l03708"></a>03708                 sdhdipole[1] += dipole[1];
<a name="l03709"></a>03709                 sdhdipole[2] += dipole[2];
<a name="l03710"></a>03710                 traced[0] += 2.0*xr*dipole[0];
<a name="l03711"></a>03711                 traced[1] += xr*dipole[1] + yr*dipole[0];
<a name="l03712"></a>03712                 traced[2] += xr*dipole[2] + zr*dipole[0];
<a name="l03713"></a>03713                 traced[3] += yr*dipole[0] + xr*dipole[1];
<a name="l03714"></a>03714                 traced[4] += 2.0*yr*dipole[1];
<a name="l03715"></a>03715                 traced[5] += yr*dipole[2] + zr*dipole[1];
<a name="l03716"></a>03716                 traced[6] += zr*dipole[0] + xr*dipole[2];
<a name="l03717"></a>03717                 traced[7] += zr*dipole[1] + yr*dipole[2];
<a name="l03718"></a>03718                 traced[8] += 2.0*zr*dipole[2];
<a name="l03719"></a>03719                 qave = (traced[0] + traced[4] + traced[8]) / 3.0;
<a name="l03720"></a>03720                 sdhquadrupole[0] += 1.5*(traced[0] - qave);
<a name="l03721"></a>03721                 sdhquadrupole[1] += 1.5*(traced[1]);
<a name="l03722"></a>03722                 sdhquadrupole[2] += 1.5*(traced[2]);
<a name="l03723"></a>03723                 sdhquadrupole[3] += 1.5*(traced[3]);
<a name="l03724"></a>03724                 sdhquadrupole[4] += 1.5*(traced[4] - qave);
<a name="l03725"></a>03725                 sdhquadrupole[5] += 1.5*(traced[5]);
<a name="l03726"></a>03726                 sdhquadrupole[6] += 1.5*(traced[6]);
<a name="l03727"></a>03727                 sdhquadrupole[7] += 1.5*(traced[7]);
<a name="l03728"></a>03728                 sdhquadrupole[8] += 1.5*(traced[8] - qave);
<a name="l03729"></a>03729                 sdhquadrupole[0] += quadrupole[0];
<a name="l03730"></a>03730                 sdhquadrupole[1] += quadrupole[1];
<a name="l03731"></a>03731                 sdhquadrupole[2] += quadrupole[2];
<a name="l03732"></a>03732                 sdhquadrupole[3] += quadrupole[3];
<a name="l03733"></a>03733                 sdhquadrupole[4] += quadrupole[4];
<a name="l03734"></a>03734                 sdhquadrupole[5] += quadrupole[5];
<a name="l03735"></a>03735                 sdhquadrupole[6] += quadrupole[6];
<a name="l03736"></a>03736                 sdhquadrupole[7] += quadrupole[7];
<a name="l03737"></a>03737                 sdhquadrupole[8] += quadrupole[8];
<a name="l03738"></a>03738             <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da92d27a9c40417842c09da484ab798a03">VCM_INDUCED</a>:
<a name="l03739"></a>03739                 dipole = Vatom_getInducedDipole(atom);
<a name="l03740"></a>03740                 sdhdipole[0] += dipole[0];
<a name="l03741"></a>03741                 sdhdipole[1] += dipole[1];
<a name="l03742"></a>03742                 sdhdipole[2] += dipole[2];
<a name="l03743"></a>03743                 traced[0] = 2.0*xr*dipole[0];
<a name="l03744"></a>03744                 traced[1] = xr*dipole[1] + yr*dipole[0];
<a name="l03745"></a>03745                 traced[2] = xr*dipole[2] + zr*dipole[0];
<a name="l03746"></a>03746                 traced[3] = yr*dipole[0] + xr*dipole[1];
<a name="l03747"></a>03747                 traced[4] = 2.0*yr*dipole[1];
<a name="l03748"></a>03748                 traced[5] = yr*dipole[2] + zr*dipole[1];
<a name="l03749"></a>03749                 traced[6] = zr*dipole[0] + xr*dipole[2];
<a name="l03750"></a>03750                 traced[7] = zr*dipole[1] + yr*dipole[2];
<a name="l03751"></a>03751                 traced[8] = 2.0*zr*dipole[2];
<a name="l03752"></a>03752                 qave = (traced[0] + traced[4] + traced[8]) / 3.0;
<a name="l03753"></a>03753                 sdhquadrupole[0] += 1.5*(traced[0] - qave);
<a name="l03754"></a>03754                 sdhquadrupole[1] += 1.5*(traced[1]);
<a name="l03755"></a>03755                 sdhquadrupole[2] += 1.5*(traced[2]);
<a name="l03756"></a>03756                 sdhquadrupole[3] += 1.5*(traced[3]);
<a name="l03757"></a>03757                 sdhquadrupole[4] += 1.5*(traced[4] - qave);
<a name="l03758"></a>03758                 sdhquadrupole[5] += 1.5*(traced[5]);
<a name="l03759"></a>03759                 sdhquadrupole[6] += 1.5*(traced[6]);
<a name="l03760"></a>03760                 sdhquadrupole[7] += 1.5*(traced[7]);
<a name="l03761"></a>03761                 sdhquadrupole[8] += 1.5*(traced[8] - qave);
<a name="l03762"></a>03762             <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da0380d67590db2e7662a896e98521dcbf">VCM_NLINDUCED</a>:
<a name="l03763"></a>03763                 dipole = Vatom_getNLInducedDipole(atom);
<a name="l03764"></a>03764                 sdhdipole[0] += dipole[0];
<a name="l03765"></a>03765                 sdhdipole[1] += dipole[1];
<a name="l03766"></a>03766                 sdhdipole[2] += dipole[2];
<a name="l03767"></a>03767                 traced[0] = 2.0*xr*dipole[0];
<a name="l03768"></a>03768                 traced[1] = xr*dipole[1] + yr*dipole[0];
<a name="l03769"></a>03769                 traced[2] = xr*dipole[2] + zr*dipole[0];
<a name="l03770"></a>03770                 traced[3] = yr*dipole[0] + xr*dipole[1];
<a name="l03771"></a>03771                 traced[4] = 2.0*yr*dipole[1];
<a name="l03772"></a>03772                 traced[5] = yr*dipole[2] + zr*dipole[1];
<a name="l03773"></a>03773                 traced[6] = zr*dipole[0] + xr*dipole[2];
<a name="l03774"></a>03774                 traced[7] = zr*dipole[1] + yr*dipole[2];
<a name="l03775"></a>03775                 traced[8] = 2.0*zr*dipole[2];
<a name="l03776"></a>03776                 qave = (traced[0] + traced[4] + traced[8]) / 3.0;
<a name="l03777"></a>03777                 sdhquadrupole[0] += 1.5*(traced[0] - qave);
<a name="l03778"></a>03778                 sdhquadrupole[1] += 1.5*(traced[1]);
<a name="l03779"></a>03779                 sdhquadrupole[2] += 1.5*(traced[2]);
<a name="l03780"></a>03780                 sdhquadrupole[3] += 1.5*(traced[3]);
<a name="l03781"></a>03781                 sdhquadrupole[4] += 1.5*(traced[4] - qave);
<a name="l03782"></a>03782                 sdhquadrupole[5] += 1.5*(traced[5]);
<a name="l03783"></a>03783                 sdhquadrupole[6] += 1.5*(traced[6]);
<a name="l03784"></a>03784                 sdhquadrupole[7] += 1.5*(traced[7]);
<a name="l03785"></a>03785                 sdhquadrupole[8] += 1.5*(traced[8] - qave);
<a name="l03786"></a>03786 <span class="preprocessor">#endif </span><span class="comment">/* if defined(WITH_TINKER) */</span>
<a name="l03787"></a>03787         }
<a name="l03788"></a>03788     }
<a name="l03789"></a>03789 
<a name="l03790"></a>03790     ux = sdhdipole[0];
<a name="l03791"></a>03791     uy = sdhdipole[1];
<a name="l03792"></a>03792     uz = sdhdipole[2];
<a name="l03793"></a>03793 
<a name="l03794"></a>03794     <span class="comment">/* The factor of 1/3 results from using a</span>
<a name="l03795"></a>03795 <span class="comment">     traceless quadrupole definition. See, for example,</span>
<a name="l03796"></a>03796 <span class="comment">     &quot;The Theory of Intermolecular Forces&quot; by A.J. Stone,</span>
<a name="l03797"></a>03797 <span class="comment">     Chapter 3. */</span>
<a name="l03798"></a>03798     qxx = sdhquadrupole[0] / 3.0;
<a name="l03799"></a>03799     qxy = sdhquadrupole[1] / 3.0;
<a name="l03800"></a>03800     qxz = sdhquadrupole[2] / 3.0;
<a name="l03801"></a>03801     qyx = sdhquadrupole[3] / 3.0;
<a name="l03802"></a>03802     qyy = sdhquadrupole[4] / 3.0;
<a name="l03803"></a>03803     qyz = sdhquadrupole[5] / 3.0;
<a name="l03804"></a>03804     qzx = sdhquadrupole[6] / 3.0;
<a name="l03805"></a>03805     qzy = sdhquadrupole[7] / 3.0;
<a name="l03806"></a>03806     qzz = sdhquadrupole[8] / 3.0;
<a name="l03807"></a>03807 
<a name="l03808"></a>03808     <span class="keywordflow">for</span>(k=0;k&lt;nz;k++){
<a name="l03809"></a>03809         gpos[2] = zf[k];
<a name="l03810"></a>03810         <span class="keywordflow">for</span>(j=0;j&lt;ny;j++){
<a name="l03811"></a>03811             gpos[1] = yf[j];
<a name="l03812"></a>03812             <span class="keywordflow">for</span>(i=0;i&lt;nx;i++){
<a name="l03813"></a>03813                 gpos[0] = xf[i];
<a name="l03814"></a>03814                 <span class="keywordflow">if</span>(gridPointIsValid(i, j, k, nx, ny, nz)){
<a name="l03815"></a>03815                     xr = gpos[0] - position[0];
<a name="l03816"></a>03816                     yr = gpos[1] - position[1];
<a name="l03817"></a>03817                     zr = gpos[2] - position[2];
<a name="l03818"></a>03818 
<a name="l03819"></a>03819                     dist = VSQRT(VSQR(xr) + VSQR(yr) + VSQR(zr));
<a name="l03820"></a>03820                     <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(dist, xkappa, eps_p, eps_w, size, tensor);
<a name="l03821"></a>03821 
<a name="l03822"></a>03822                     val = pre*sdhcharge*tensor[0];
<a name="l03823"></a>03823                     val -= pre*ux*xr*tensor[1];
<a name="l03824"></a>03824                     val -= pre*uy*yr*tensor[1];
<a name="l03825"></a>03825                     val -= pre*uz*zr*tensor[1];
<a name="l03826"></a>03826                     val += pre*qxx*xr*xr*tensor[2];
<a name="l03827"></a>03827                     val += pre*qyy*yr*yr*tensor[2];
<a name="l03828"></a>03828                     val += pre*qzz*zr*zr*tensor[2];
<a name="l03829"></a>03829                     val += pre*2.0*qxy*xr*yr*tensor[2];
<a name="l03830"></a>03830                     val += pre*2.0*qxz*xr*zr*tensor[2];
<a name="l03831"></a>03831                     val += pre*2.0*qyz*yr*zr*tensor[2];
<a name="l03832"></a>03832 
<a name="l03833"></a>03833                     <span class="keywordflow">if</span>(i==0){
<a name="l03834"></a>03834                         gxcf[IJKx(j,k,0)] = val;
<a name="l03835"></a>03835                     }
<a name="l03836"></a>03836                     <span class="keywordflow">if</span>(i==nx-1){
<a name="l03837"></a>03837                         gxcf[IJKx(j,k,1)] = val;
<a name="l03838"></a>03838                     }
<a name="l03839"></a>03839                     <span class="keywordflow">if</span>(j==0){
<a name="l03840"></a>03840                         gycf[IJKy(i,k,0)] = val;
<a name="l03841"></a>03841                     }
<a name="l03842"></a>03842                     <span class="keywordflow">if</span>(j==ny-1){
<a name="l03843"></a>03843                         gycf[IJKy(i,k,1)] = val;
<a name="l03844"></a>03844                     }
<a name="l03845"></a>03845                     <span class="keywordflow">if</span>(k==0){
<a name="l03846"></a>03846                         gzcf[IJKz(i,j,0)] = val;
<a name="l03847"></a>03847                     }
<a name="l03848"></a>03848                     <span class="keywordflow">if</span>(k==nz-1){
<a name="l03849"></a>03849                         gzcf[IJKz(i,j,1)] = val;
<a name="l03850"></a>03850                     }
<a name="l03851"></a>03851                 } <span class="comment">/* End grid point is valid */</span>
<a name="l03852"></a>03852             } <span class="comment">/* End i loop */</span>
<a name="l03853"></a>03853         } <span class="comment">/* End j loop */</span>
<a name="l03854"></a>03854     } <span class="comment">/* End k loop */</span>
<a name="l03855"></a>03855 
<a name="l03856"></a>03856 }
<a name="l03857"></a>03857 
<a name="l03858"></a>03858 VPRIVATE <span class="keywordtype">void</span> bcfl_mdh(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l03859"></a>03859 
<a name="l03860"></a>03860     <span class="keywordtype">int</span> i,j,k,iatom;
<a name="l03861"></a>03861     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l03862"></a>03862 
<a name="l03863"></a>03863     <span class="keywordtype">double</span> val, *apos, gpos[3];
<a name="l03864"></a>03864     <span class="keywordtype">double</span> *dipole, *quadrupole;
<a name="l03865"></a>03865     <span class="keywordtype">double</span> size, charge, xkappa, eps_w, eps_p, T, pre1, dist;
<a name="l03866"></a>03866 
<a name="l03867"></a>03867     <span class="keywordtype">double</span> *xf, *yf, *zf;
<a name="l03868"></a>03868     <span class="keywordtype">double</span> *gxcf, *gycf, *gzcf;
<a name="l03869"></a>03869 
<a name="l03870"></a>03870     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l03871"></a>03871     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l03872"></a>03872     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l03873"></a>03873 
<a name="l03874"></a>03874     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l03875"></a>03875     alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l03876"></a>03876     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l03877"></a>03877     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l03878"></a>03878     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l03879"></a>03879 
<a name="l03880"></a>03880     xf = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>;
<a name="l03881"></a>03881     yf = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>;
<a name="l03882"></a>03882     zf = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>;
<a name="l03883"></a>03883 
<a name="l03884"></a>03884     gxcf = thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>;
<a name="l03885"></a>03885     gycf = thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>;
<a name="l03886"></a>03886     gzcf = thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>;
<a name="l03887"></a>03887 
<a name="l03888"></a>03888     <span class="comment">/* For each &quot;atom&quot; (only one for bcfl=1), we use the following formula to</span>
<a name="l03889"></a>03889 <span class="comment">     * calculate the boundary conditions:</span>
<a name="l03890"></a>03890 <span class="comment">     *    g(x) = \frac{q e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l03891"></a>03891 <span class="comment">     *          * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l03892"></a>03892 <span class="comment">     *          * 1/d</span>
<a name="l03893"></a>03893 <span class="comment">     * where d = ||x - x_0|| (in m) and a is the size of the atom (in m).</span>
<a name="l03894"></a>03894 <span class="comment">     * We only need to evaluate some of these prefactors once:</span>
<a name="l03895"></a>03895 <span class="comment">     *    pre1 = \frac{e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l03896"></a>03896 <span class="comment">     * which gives the potential as</span>
<a name="l03897"></a>03897 <span class="comment">     *    g(x) = pre1 * q/d * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l03898"></a>03898 <span class="comment">     */</span>
<a name="l03899"></a>03899     eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l03900"></a>03900     eps_p = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l03901"></a>03901     T = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe);               <span class="comment">/* K             */</span>
<a name="l03902"></a>03902     pre1 = (<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*eps_w*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T);
<a name="l03903"></a>03903 
<a name="l03904"></a>03904     <span class="comment">/* Finally, if we convert keep xkappa in A^{-1} and scale pre1 by</span>
<a name="l03905"></a>03905 <span class="comment">     * m/A, then we will only need to deal with distances and sizes in</span>
<a name="l03906"></a>03906 <span class="comment">     * Angstroms rather than meters.                                       */</span>
<a name="l03907"></a>03907     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);              <span class="comment">/* A^{-1}        */</span>
<a name="l03908"></a>03908     pre1 = pre1*(1.0e10);
<a name="l03909"></a>03909 
<a name="l03910"></a>03910     <span class="comment">/* Finally, if we convert keep xkappa in A^{-1} and scale pre1 by</span>
<a name="l03911"></a>03911 <span class="comment">     * m/A, then we will only need to deal with distances and sizes in</span>
<a name="l03912"></a>03912 <span class="comment">     * Angstroms rather than meters.                                       */</span>
<a name="l03913"></a>03913     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);              <span class="comment">/* A^{-1}        */</span>
<a name="l03914"></a>03914 
<a name="l03915"></a>03915     <span class="keywordflow">for</span>(k=0;k&lt;nz;k++){
<a name="l03916"></a>03916         gpos[2] = zf[k];
<a name="l03917"></a>03917         <span class="keywordflow">for</span>(j=0;j&lt;ny;j++){
<a name="l03918"></a>03918             gpos[1] = yf[j];
<a name="l03919"></a>03919             <span class="keywordflow">for</span>(i=0;i&lt;nx;i++){
<a name="l03920"></a>03920                 gpos[0] = xf[i];
<a name="l03921"></a>03921                 <span class="keywordflow">if</span>(gridPointIsValid(i, j, k, nx, ny, nz)){
<a name="l03922"></a>03922 
<a name="l03923"></a>03923                     val = 0.0;
<a name="l03924"></a>03924 
<a name="l03925"></a>03925                     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l03926"></a>03926                         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l03927"></a>03927                         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l03928"></a>03928                         charge = <a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*<a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l03929"></a>03929                         size = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l03930"></a>03930 
<a name="l03931"></a>03931                         dist = VSQRT(VSQR(gpos[0]-apos[0]) + VSQR(gpos[1]-apos[1])
<a name="l03932"></a>03932                                      + VSQR(gpos[2]-apos[2]));
<a name="l03933"></a>03933                         <span class="keywordflow">if</span> (xkappa &gt; VSMALL) {
<a name="l03934"></a>03934                             val += pre1*(charge/dist)*VEXP(-xkappa*(dist-size))
<a name="l03935"></a>03935                             / (1+xkappa*size);
<a name="l03936"></a>03936                         } <span class="keywordflow">else</span> {
<a name="l03937"></a>03937                             val += pre1*(charge/dist);
<a name="l03938"></a>03938                         }
<a name="l03939"></a>03939 
<a name="l03940"></a>03940                     }
<a name="l03941"></a>03941 
<a name="l03942"></a>03942                     <span class="keywordflow">if</span>(i==0){
<a name="l03943"></a>03943                         gxcf[IJKx(j,k,0)] = val;
<a name="l03944"></a>03944                     }
<a name="l03945"></a>03945                     <span class="keywordflow">if</span>(i==nx-1){
<a name="l03946"></a>03946                         gxcf[IJKx(j,k,1)] = val;
<a name="l03947"></a>03947                     }
<a name="l03948"></a>03948                     <span class="keywordflow">if</span>(j==0){
<a name="l03949"></a>03949                         gycf[IJKy(i,k,0)] = val;
<a name="l03950"></a>03950                     }
<a name="l03951"></a>03951                     <span class="keywordflow">if</span>(j==ny-1){
<a name="l03952"></a>03952                         gycf[IJKy(i,k,1)] = val;
<a name="l03953"></a>03953                     }
<a name="l03954"></a>03954                     <span class="keywordflow">if</span>(k==0){
<a name="l03955"></a>03955                         gzcf[IJKz(i,j,0)] = val;
<a name="l03956"></a>03956                     }
<a name="l03957"></a>03957                     <span class="keywordflow">if</span>(k==nz-1){
<a name="l03958"></a>03958                         gzcf[IJKz(i,j,1)] = val;
<a name="l03959"></a>03959                     }
<a name="l03960"></a>03960                 } <span class="comment">/* End grid point is valid */</span>
<a name="l03961"></a>03961             } <span class="comment">/* End i loop */</span>
<a name="l03962"></a>03962         } <span class="comment">/* End j loop */</span>
<a name="l03963"></a>03963     } <span class="comment">/* End k loop */</span>
<a name="l03964"></a>03964 
<a name="l03965"></a>03965 }
<a name="l03966"></a>03966 
<a name="l03967"></a>03967 <span class="comment">/* ///////////////////////////////////////////////////////////////////////////</span>
<a name="l03968"></a>03968 <span class="comment"> // Routine:  bcfl_mem</span>
<a name="l03969"></a>03969 <span class="comment"> //</span>
<a name="l03970"></a>03970 <span class="comment"> // Purpose:  Increment all the boundary points by the</span>
<a name="l03971"></a>03971 <span class="comment"> //           analytic expression for a membrane system in</span>
<a name="l03972"></a>03972 <span class="comment"> //           the presence of a membrane potential. This</span>
<a name="l03973"></a>03973 <span class="comment"> //           Boundary flag should only be used for systems</span>
<a name="l03974"></a>03974 <span class="comment"> //           that explicitly have membranes in the dielectric</span>
<a name="l03975"></a>03975 <span class="comment"> //           and solvent maps.</span>
<a name="l03976"></a>03976 <span class="comment"> //</span>
<a name="l03977"></a>03977 <span class="comment"> //           There should be several input variables add to this</span>
<a name="l03978"></a>03978 <span class="comment"> //           function such as membrane potential, membrane thickness</span>
<a name="l03979"></a>03979 <span class="comment"> //           and height.</span>
<a name="l03980"></a>03980 <span class="comment"> //</span>
<a name="l03981"></a>03981 <span class="comment"> // Args:     apos is a 3-vector</span>
<a name="l03982"></a>03982 <span class="comment"> //</span>
<a name="l03983"></a>03983 <span class="comment"> // Author: Michael Grabe</span>
<a name="l03985"></a>03985 <span class="comment">VPRIVATE void bcfl_mem(double zmem, double L, double eps_m, double eps_w,</span>
<a name="l03986"></a>03986 <span class="comment">                    double V, double xkappa, double *gxcf, double *gycf, double *gzcf,</span>
<a name="l03987"></a>03987 <span class="comment">                    double *xf, double *yf, double *zf, int nx, int ny, int nz) {</span>
<a name="l03988"></a>03988 <span class="comment"></span>
<a name="l03990"></a>03990 <span class="comment">    /* some definitions                              */</span>
<a name="l03991"></a>03991     <span class="comment">/* L = total length of the membrane              */</span>
<a name="l03992"></a>03992     <span class="comment">/* xkappa = inverse Debeye length                */</span>
<a name="l03993"></a>03993     <span class="comment">/* zmem = z value of membrane bottom (Cytoplasm) */</span>
<a name="l03994"></a>03994     <span class="comment">/* V = electrical potential inside the cell      */</span>
<a name="l03996"></a>03996     <span class="keywordtype">int</span> i, j, k;
<a name="l03997"></a>03997     <span class="keywordtype">double</span> dist, val, z_low, z_high, z_shift;
<a name="l03998"></a>03998     <span class="keywordtype">double</span> A, B, C, D, edge_L, l;
<a name="l03999"></a>03999     <span class="keywordtype">double</span> G, z_0, z_rel;
<a name="l04000"></a>04000     <span class="keywordtype">double</span> gpos[3];
<a name="l04001"></a>04001 
<a name="l04002"></a>04002     Vnm_print(0, <span class="stringliteral">&quot;Here is the value of kappa: %f\n&quot;</span>,xkappa);
<a name="l04003"></a>04003     Vnm_print(0, <span class="stringliteral">&quot;Here is the value of L: %f\n&quot;</span>,L);
<a name="l04004"></a>04004     Vnm_print(0, <span class="stringliteral">&quot;Here is the value of zmem: %f\n&quot;</span>,zmem);
<a name="l04005"></a>04005     Vnm_print(0, <span class="stringliteral">&quot;Here is the value of mdie: %f\n&quot;</span>,eps_m);
<a name="l04006"></a>04006     Vnm_print(0, <span class="stringliteral">&quot;Here is the value of memv: %f\n&quot;</span>,V);
<a name="l04007"></a>04007 
<a name="l04008"></a>04008     <span class="comment">/* no salt symmetric BC&#39;s at +/- infinity */</span>
<a name="l04009"></a>04009     <span class="comment">// B=V/(edge_L - l*(1-eps_w/eps_m));</span>
<a name="l04010"></a>04010     <span class="comment">// A=V + B*edge_L;</span>
<a name="l04011"></a>04011     <span class="comment">// D=eps_w/eps_m*B;</span>
<a name="l04012"></a>04012     z_low = zmem;     <span class="comment">/* this defines the bottom of the membrane */</span>
<a name="l04013"></a>04013     z_high = zmem + L;  <span class="comment">/* this is the top of the membrane */</span>
<a name="l04014"></a>04014 
<a name="l04015"></a>04015     <span class="comment">/******************************************************/</span>
<a name="l04016"></a>04016     <span class="comment">/* proper boundary conditions for V = 0 extracellular */</span>
<a name="l04017"></a>04017     <span class="comment">/* and psi=-V cytoplasm.                              */</span>
<a name="l04018"></a>04018     <span class="comment">/* Implicit in this formulation is that the membrane  */</span>
<a name="l04019"></a>04019     <span class="comment">/* center be at z = 0                                 */</span>
<a name="l04020"></a>04020     <span class="comment">/******************************************************/</span>
<a name="l04021"></a>04021 
<a name="l04022"></a>04022     l=L/2;                     <span class="comment">/* half of the membrane length */</span>
<a name="l04023"></a>04023     z_0 = z_low + l;           <span class="comment">/* center of the membrane      */</span>
<a name="l04024"></a>04024     G=l*eps_w/eps_m*xkappa;
<a name="l04025"></a>04025     A=-V/2*(1/(G+1))*exp(xkappa*l);
<a name="l04026"></a>04026     B=V/2;
<a name="l04027"></a>04027     C=-V/2*eps_w/eps_m*xkappa*(1/(G+1));
<a name="l04028"></a>04028     D=-A;
<a name="l04029"></a>04029     <span class="comment">/* The analytic expression for the boundary conditions      */</span>
<a name="l04030"></a>04030     <span class="comment">/* had the cytoplasmic surface of the membrane set to zero. */</span>
<a name="l04031"></a>04031     <span class="comment">/* This requires an off-set of the BC equations.            */</span>
<a name="l04032"></a>04032 
<a name="l04033"></a>04033     <span class="comment">/* the &quot;i&quot; boundaries (dirichlet) */</span>
<a name="l04034"></a>04034     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l04035"></a>04035         gpos[2] = zf[k];
<a name="l04036"></a>04036         z_rel = gpos[2] - z_0;    <span class="comment">/* relative position for BCs */</span>
<a name="l04037"></a>04037 
<a name="l04038"></a>04038         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l04039"></a>04039 
<a name="l04040"></a>04040             <span class="keywordflow">if</span> (gpos[2] &lt;= z_low) {                       <span class="comment">/* cytoplasmic */</span>
<a name="l04041"></a>04041 
<a name="l04042"></a>04042                 val = A*exp(xkappa*z_rel) + V;
<a name="l04043"></a>04043                 gxcf[IJKx(j,k,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04044"></a>04044                 gxcf[IJKx(j,k,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04045"></a>04045 
<a name="l04046"></a>04046             }
<a name="l04047"></a>04047 
<a name="l04048"></a>04048             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpos[2] &gt; z_low &amp;&amp; gpos[2] &lt;= z_high) {  <span class="comment">/* in membrane */</span>
<a name="l04049"></a>04049 
<a name="l04050"></a>04050                 val = B + C*z_rel;
<a name="l04051"></a>04051                 gxcf[IJKx(j,k,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04052"></a>04052                 gxcf[IJKx(j,k,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04053"></a>04053 
<a name="l04054"></a>04054             }
<a name="l04055"></a>04055 
<a name="l04056"></a>04056             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpos[2] &gt; z_high)  {                  <span class="comment">/* extracellular */</span>
<a name="l04057"></a>04057 
<a name="l04058"></a>04058                 val = D*exp(-xkappa*z_rel);
<a name="l04059"></a>04059                 gxcf[IJKx(j,k,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04060"></a>04060                 gxcf[IJKx(j,k,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04061"></a>04061 
<a name="l04062"></a>04062             }
<a name="l04063"></a>04063 
<a name="l04064"></a>04064         }
<a name="l04065"></a>04065     }
<a name="l04066"></a>04066 
<a name="l04067"></a>04067     <span class="comment">/* the &quot;j&quot; boundaries (dirichlet) */</span>
<a name="l04068"></a>04068     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l04069"></a>04069         gpos[2] = zf[k];
<a name="l04070"></a>04070         z_rel = gpos[2] - z_0;
<a name="l04071"></a>04071         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l04072"></a>04072 
<a name="l04073"></a>04073             <span class="keywordflow">if</span> (gpos[2] &lt;= z_low) {                       <span class="comment">/* cytoplasmic */</span>
<a name="l04074"></a>04074 
<a name="l04075"></a>04075                 val = A*exp(xkappa*z_rel) + V;
<a name="l04076"></a>04076                 gycf[IJKy(i,k,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04077"></a>04077                 gycf[IJKy(i,k,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04078"></a>04078                 <span class="comment">//printf(&quot;%f \n&quot;,val);</span>
<a name="l04079"></a>04079 
<a name="l04080"></a>04080             }
<a name="l04081"></a>04081 
<a name="l04082"></a>04082             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpos[2] &gt; z_low &amp;&amp; gpos[2] &lt;= z_high) {  <span class="comment">/* in membrane */</span>
<a name="l04083"></a>04083 
<a name="l04084"></a>04084                 val = B + C*z_rel;
<a name="l04085"></a>04085                 gycf[IJKy(i,k,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04086"></a>04086                 gycf[IJKy(i,k,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04087"></a>04087                 <span class="comment">//printf(&quot;%f \n&quot;,val);</span>
<a name="l04088"></a>04088 
<a name="l04089"></a>04089             }
<a name="l04090"></a>04090             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpos[2] &gt; z_high)  {                  <span class="comment">/* extracellular */</span>
<a name="l04091"></a>04091 
<a name="l04092"></a>04092                 val = D*exp(-xkappa*z_rel);
<a name="l04093"></a>04093                 gycf[IJKy(i,k,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04094"></a>04094                 gycf[IJKy(i,k,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04095"></a>04095                 <span class="comment">//printf(&quot;%f \n&quot;,val);</span>
<a name="l04096"></a>04096 
<a name="l04097"></a>04097             }
<a name="l04098"></a>04098 
<a name="l04099"></a>04099         }
<a name="l04100"></a>04100     }
<a name="l04101"></a>04101 
<a name="l04102"></a>04102     <span class="comment">/* the &quot;k&quot; boundaries (dirichlet) */</span>
<a name="l04103"></a>04103     <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l04104"></a>04104         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l04105"></a>04105 
<a name="l04106"></a>04106             <span class="comment">/* first assign the bottom boundary */</span>
<a name="l04107"></a>04107 
<a name="l04108"></a>04108             gpos[2] = zf[0];
<a name="l04109"></a>04109             z_rel = gpos[2] - z_0;
<a name="l04110"></a>04110 
<a name="l04111"></a>04111             <span class="keywordflow">if</span> (gpos[2] &lt;= z_low) {                       <span class="comment">/* cytoplasmic */</span>
<a name="l04112"></a>04112 
<a name="l04113"></a>04113                 val = A*exp(xkappa*z_rel) + V;
<a name="l04114"></a>04114                 gzcf[IJKz(i,j,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04115"></a>04115                 <span class="comment">//printf(&quot;%f \n&quot;,val);</span>
<a name="l04116"></a>04116 
<a name="l04117"></a>04117             }
<a name="l04118"></a>04118 
<a name="l04119"></a>04119             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpos[2] &gt; z_low &amp;&amp; gpos[2] &lt;= z_high) {  <span class="comment">/* in membrane */</span>
<a name="l04120"></a>04120 
<a name="l04121"></a>04121                 val = B + C*z_rel;
<a name="l04122"></a>04122                 gzcf[IJKz(i,j,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04123"></a>04123 
<a name="l04124"></a>04124             }
<a name="l04125"></a>04125 
<a name="l04126"></a>04126             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpos[2] &gt; z_high)  {                  <span class="comment">/* extracellular */</span>
<a name="l04127"></a>04127 
<a name="l04128"></a>04128                 val = D*exp(-xkappa*z_rel);
<a name="l04129"></a>04129                 gzcf[IJKz(i,j,0)] += val;    <span class="comment">/* assign low side BC */</span>
<a name="l04130"></a>04130 
<a name="l04131"></a>04131             }
<a name="l04132"></a>04132 
<a name="l04133"></a>04133             <span class="comment">/* now assign the top boundary */</span>
<a name="l04134"></a>04134 
<a name="l04135"></a>04135             gpos[2] = zf[nz-1];
<a name="l04136"></a>04136             z_rel = gpos[2] - z_0;
<a name="l04137"></a>04137 
<a name="l04138"></a>04138             <span class="keywordflow">if</span> (gpos[2] &lt;= z_low) {                       <span class="comment">/* cytoplasmic */</span>
<a name="l04139"></a>04139 
<a name="l04140"></a>04140                 val = A*exp(xkappa*z_rel) + V;
<a name="l04141"></a>04141                 gzcf[IJKz(i,j,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04142"></a>04142 
<a name="l04143"></a>04143             }
<a name="l04144"></a>04144 
<a name="l04145"></a>04145             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpos[2] &gt; z_low &amp;&amp; gpos[2] &lt;= z_high) {  <span class="comment">/* in membrane */</span>
<a name="l04146"></a>04146 
<a name="l04147"></a>04147                 val = B + C*z_rel;
<a name="l04148"></a>04148                 gzcf[IJKz(i,j,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04149"></a>04149 
<a name="l04150"></a>04150             }
<a name="l04151"></a>04151 
<a name="l04152"></a>04152             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gpos[2] &gt; z_high)  {                  <span class="comment">/* extracellular */</span>
<a name="l04153"></a>04153 
<a name="l04154"></a>04154                 val = D*exp(-xkappa*z_rel);
<a name="l04155"></a>04155                 gzcf[IJKz(i,j,1)] += val;    <span class="comment">/* assign high side BC */</span>
<a name="l04156"></a>04156                 <span class="comment">//printf(&quot;%f \n&quot;,val);</span>
<a name="l04157"></a>04157 
<a name="l04158"></a>04158             }
<a name="l04159"></a>04159 
<a name="l04160"></a>04160         }
<a name="l04161"></a>04161     }
<a name="l04162"></a>04162 }
<a name="l04163"></a>04163 
<a name="l04164"></a>04164 VPRIVATE <span class="keywordtype">void</span> bcfl_map(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l04165"></a>04165 
<a name="l04166"></a>04166     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04167"></a>04167     <span class="keywordtype">double</span> position[3], pot, hx, hy, hzed;
<a name="l04168"></a>04168     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, rc;
<a name="l04169"></a>04169 
<a name="l04170"></a>04170 
<a name="l04171"></a>04171     VASSERT(thee != VNULL);
<a name="l04172"></a>04172 
<a name="l04173"></a>04173     <span class="comment">/* Mesh info */</span>
<a name="l04174"></a>04174     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l04175"></a>04175     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l04176"></a>04176     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l04177"></a>04177     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l04178"></a>04178     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l04179"></a>04179     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l04180"></a>04180 
<a name="l04181"></a>04181     <span class="comment">/* Reset the potential array */</span>
<a name="l04182"></a>04182     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) thee-&gt;<a class="code" href="structs_vpmg.html#a34ec3c42c48d141ec30c8d2195722e11">pot</a>[i] = 0.0;
<a name="l04183"></a>04183 
<a name="l04184"></a>04184     <span class="comment">/* Fill in the source term (atomic potentials) */</span>
<a name="l04185"></a>04185     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling in source term.\n&quot;</span>);
<a name="l04186"></a>04186     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l04187"></a>04187         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l04188"></a>04188             <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l04189"></a>04189                 position[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[i];
<a name="l04190"></a>04190                 position[1] = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[j];
<a name="l04191"></a>04191                 position[2] = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[k];
<a name="l04192"></a>04192                 rc = <a class="code" href="group___vgrid.html#gae96a803dbd3016673affbc3d10310150" title="Get potential value (from mesh or approximation) at a point.">Vgrid_value</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a>, position, &amp;pot);
<a name="l04193"></a>04193                 <span class="keywordflow">if</span> (!rc) {
<a name="l04194"></a>04194                     Vnm_print(2, <span class="stringliteral">&quot;fillcoChargeMap:  Error -- fell off of potential map at (%g, %g, %g)!\n&quot;</span>,
<a name="l04195"></a>04195                               position[0], position[1], position[2]);
<a name="l04196"></a>04196                     VASSERT(0);
<a name="l04197"></a>04197                 }
<a name="l04198"></a>04198                 thee-&gt;<a class="code" href="structs_vpmg.html#a34ec3c42c48d141ec30c8d2195722e11">pot</a>[IJK(i,j,k)] = pot;
<a name="l04199"></a>04199             }
<a name="l04200"></a>04200         }
<a name="l04201"></a>04201     }
<a name="l04202"></a>04202 
<a name="l04203"></a>04203 }
<a name="l04204"></a>04204 
<a name="l04205"></a>04205 <span class="preprocessor">#if  defined(WITH_TINKER)</span>
<a name="l04206"></a>04206 <span class="preprocessor"></span>VPRIVATE <span class="keywordtype">void</span> bcfl_mdh_tinker(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l04207"></a>04207 
<a name="l04208"></a>04208     <span class="keywordtype">int</span> i,j,k,iatom;
<a name="l04209"></a>04209     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l04210"></a>04210 
<a name="l04211"></a>04211     <span class="keywordtype">double</span> val, *apos, gpos[3], tensor[9];
<a name="l04212"></a>04212     <span class="keywordtype">double</span> *dipole, *quadrupole;
<a name="l04213"></a>04213     <span class="keywordtype">double</span> size, charge, xkappa, eps_w, eps_p, T, pre1, dist;
<a name="l04214"></a>04214 
<a name="l04215"></a>04215     <span class="keywordtype">double</span> ux,uy,uz,xr,yr,zr;
<a name="l04216"></a>04216     <span class="keywordtype">double</span> qxx,qxy,qxz,qyx,qyy,qyz,qzx,qzy,qzz;
<a name="l04217"></a>04217 
<a name="l04218"></a>04218     <span class="keywordtype">double</span> *xf, *yf, *zf;
<a name="l04219"></a>04219     <span class="keywordtype">double</span> *gxcf, *gycf, *gzcf;
<a name="l04220"></a>04220 
<a name="l04221"></a>04221     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04222"></a>04222     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l04223"></a>04223     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l04224"></a>04224 
<a name="l04225"></a>04225     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04226"></a>04226     alist = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l04227"></a>04227     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l04228"></a>04228     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l04229"></a>04229     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l04230"></a>04230 
<a name="l04231"></a>04231     xf = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>;
<a name="l04232"></a>04232     yf = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>;
<a name="l04233"></a>04233     zf = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>;
<a name="l04234"></a>04234 
<a name="l04235"></a>04235     gxcf = thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>;
<a name="l04236"></a>04236     gycf = thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>;
<a name="l04237"></a>04237     gzcf = thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>;
<a name="l04238"></a>04238 
<a name="l04239"></a>04239     <span class="comment">/* For each &quot;atom&quot; (only one for bcfl=1), we use the following formula to</span>
<a name="l04240"></a>04240 <span class="comment">     * calculate the boundary conditions:</span>
<a name="l04241"></a>04241 <span class="comment">     *    g(x) = \frac{q e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l04242"></a>04242 <span class="comment">     *          * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l04243"></a>04243 <span class="comment">     *          * 1/d</span>
<a name="l04244"></a>04244 <span class="comment">     * where d = ||x - x_0|| (in m) and a is the size of the atom (in m).</span>
<a name="l04245"></a>04245 <span class="comment">     * We only need to evaluate some of these prefactors once:</span>
<a name="l04246"></a>04246 <span class="comment">     *    pre1 = \frac{e_c}{4*\pi*\eps_0*\eps_w*k_b*T}</span>
<a name="l04247"></a>04247 <span class="comment">     * which gives the potential as</span>
<a name="l04248"></a>04248 <span class="comment">     *    g(x) = pre1 * q/d * \frac{exp(-xkappa*(d - a))}{1+xkappa*a}</span>
<a name="l04249"></a>04249 <span class="comment">     */</span>
<a name="l04250"></a>04250     eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l04251"></a>04251     eps_p = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);           <span class="comment">/* Dimensionless */</span>
<a name="l04252"></a>04252     T = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe);               <span class="comment">/* K             */</span>
<a name="l04253"></a>04253     pre1 = (<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>*<a class="code" href="group___vunit.html#ga11c9c34b1a2e6e9c6624380d8dd352b4" title="Charge of an electron in C.">Vunit_ec</a>)/(4*VPI*<a class="code" href="group___vunit.html#gaef150c79014029691cae98252647ec24" title="Vacuum permittivity.">Vunit_eps0</a>*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>*T);
<a name="l04254"></a>04254 
<a name="l04255"></a>04255     <span class="comment">/* Finally, if we convert keep xkappa in A^{-1} and scale pre1 by</span>
<a name="l04256"></a>04256 <span class="comment">     * m/A, then we will only need to deal with distances and sizes in</span>
<a name="l04257"></a>04257 <span class="comment">     * Angstroms rather than meters.                                       */</span>
<a name="l04258"></a>04258     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);              <span class="comment">/* A^{-1}        */</span>
<a name="l04259"></a>04259     pre1 = pre1*(1.0e10);
<a name="l04260"></a>04260 
<a name="l04261"></a>04261     <span class="comment">/* Finally, if we convert keep xkappa in A^{-1} and scale pre1 by</span>
<a name="l04262"></a>04262 <span class="comment">     * m/A, then we will only need to deal with distances and sizes in</span>
<a name="l04263"></a>04263 <span class="comment">     * Angstroms rather than meters.                                       */</span>
<a name="l04264"></a>04264     xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(pbe);              <span class="comment">/* A^{-1}        */</span>
<a name="l04265"></a>04265 
<a name="l04266"></a>04266     <span class="keywordflow">for</span>(k=0;k&lt;nz;k++){
<a name="l04267"></a>04267         gpos[2] = zf[k];
<a name="l04268"></a>04268         <span class="keywordflow">for</span>(j=0;j&lt;ny;j++){
<a name="l04269"></a>04269             gpos[1] = yf[j];
<a name="l04270"></a>04270             <span class="keywordflow">for</span>(i=0;i&lt;nx;i++){
<a name="l04271"></a>04271                 gpos[0] = xf[i];
<a name="l04272"></a>04272                 <span class="keywordflow">if</span>(gridPointIsValid(i, j, k, nx, ny, nz)){
<a name="l04273"></a>04273 
<a name="l04274"></a>04274                     val = 0.0;
<a name="l04275"></a>04275 
<a name="l04276"></a>04276                     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l04277"></a>04277                         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l04278"></a>04278                         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l04279"></a>04279                         size = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l04280"></a>04280 
<a name="l04281"></a>04281                         charge = 0.0;
<a name="l04282"></a>04282 
<a name="l04283"></a>04283                         dipole = VNULL;
<a name="l04284"></a>04284                         quadrupole = VNULL;
<a name="l04285"></a>04285 
<a name="l04286"></a>04286                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a311ed24e465040d2095273159d497995">chargeSrc</a> == <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4dac6801535dedee5a72c8a91f5872731aa">VCM_PERMANENT</a>) {
<a name="l04287"></a>04287                             charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l04288"></a>04288                             dipole = Vatom_getDipole(atom);
<a name="l04289"></a>04289                             quadrupole = Vatom_getQuadrupole(atom);
<a name="l04290"></a>04290                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a311ed24e465040d2095273159d497995">chargeSrc</a> == <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da92d27a9c40417842c09da484ab798a03">VCM_INDUCED</a>) {
<a name="l04291"></a>04291                             dipole = Vatom_getInducedDipole(atom);
<a name="l04292"></a>04292                         } <span class="keywordflow">else</span> {
<a name="l04293"></a>04293                             dipole = Vatom_getNLInducedDipole(atom);
<a name="l04294"></a>04294                         }
<a name="l04295"></a>04295 
<a name="l04296"></a>04296                         ux = dipole[0];
<a name="l04297"></a>04297                         uy = dipole[1];
<a name="l04298"></a>04298                         uz = dipole[2];
<a name="l04299"></a>04299 
<a name="l04300"></a>04300                         <span class="keywordflow">if</span> (quadrupole != VNULL) {
<a name="l04301"></a>04301                             <span class="comment">/* The factor of 1/3 results from using a</span>
<a name="l04302"></a>04302 <span class="comment">                             traceless quadrupole definition. See, for example,</span>
<a name="l04303"></a>04303 <span class="comment">                             &quot;The Theory of Intermolecular Forces&quot; by A.J. Stone,</span>
<a name="l04304"></a>04304 <span class="comment">                             Chapter 3. */</span>
<a name="l04305"></a>04305                             qxx = quadrupole[0] / 3.0;
<a name="l04306"></a>04306                             qxy = quadrupole[1] / 3.0;
<a name="l04307"></a>04307                             qxz = quadrupole[2] / 3.0;
<a name="l04308"></a>04308                             qyx = quadrupole[3] / 3.0;
<a name="l04309"></a>04309                             qyy = quadrupole[4] / 3.0;
<a name="l04310"></a>04310                             qyz = quadrupole[5] / 3.0;
<a name="l04311"></a>04311                             qzx = quadrupole[6] / 3.0;
<a name="l04312"></a>04312                             qzy = quadrupole[7] / 3.0;
<a name="l04313"></a>04313                             qzz = quadrupole[8] / 3.0;
<a name="l04314"></a>04314                         } <span class="keywordflow">else</span> {
<a name="l04315"></a>04315                             qxx = 0.0;
<a name="l04316"></a>04316                             qxy = 0.0;
<a name="l04317"></a>04317                             qxz = 0.0;
<a name="l04318"></a>04318                             qyx = 0.0;
<a name="l04319"></a>04319                             qyy = 0.0;
<a name="l04320"></a>04320                             qyz = 0.0;
<a name="l04321"></a>04321                             qzx = 0.0;
<a name="l04322"></a>04322                             qzy = 0.0;
<a name="l04323"></a>04323                             qzz = 0.0;
<a name="l04324"></a>04324                         }
<a name="l04325"></a>04325 
<a name="l04326"></a>04326                         xr = gpos[0] - apos[0];
<a name="l04327"></a>04327                         yr = gpos[1] - apos[1];
<a name="l04328"></a>04328                         zr = gpos[2] - apos[2];
<a name="l04329"></a>04329 
<a name="l04330"></a>04330                         dist = VSQRT(VSQR(xr) + VSQR(yr) + VSQR(zr));
<a name="l04331"></a>04331                         <a class="code" href="vpmg_8c.html#a0f71bb1c4fe48352092a82c88c5eac3e" title="This routine serves bcfl2. It returns (in tsr) the contraction independent portion of the Debye-Hucke...">multipolebc</a>(dist, xkappa, eps_p, eps_w, size, tensor);
<a name="l04332"></a>04332 
<a name="l04333"></a>04333                         val += pre1*charge*tensor[0];
<a name="l04334"></a>04334                         val -= pre1*ux*xr*tensor[1];
<a name="l04335"></a>04335                         val -= pre1*uy*yr*tensor[1];
<a name="l04336"></a>04336                         val -= pre1*uz*zr*tensor[1];
<a name="l04337"></a>04337                         val += pre1*qxx*xr*xr*tensor[2];
<a name="l04338"></a>04338                         val += pre1*qyy*yr*yr*tensor[2];
<a name="l04339"></a>04339                         val += pre1*qzz*zr*zr*tensor[2];
<a name="l04340"></a>04340                         val += pre1*2.0*qxy*xr*yr*tensor[2];
<a name="l04341"></a>04341                         val += pre1*2.0*qxz*xr*zr*tensor[2];
<a name="l04342"></a>04342                         val += pre1*2.0*qyz*yr*zr*tensor[2];
<a name="l04343"></a>04343 
<a name="l04344"></a>04344                     }
<a name="l04345"></a>04345 
<a name="l04346"></a>04346                     <span class="keywordflow">if</span>(i==0){
<a name="l04347"></a>04347                         gxcf[IJKx(j,k,0)] = val;
<a name="l04348"></a>04348                     }
<a name="l04349"></a>04349                     <span class="keywordflow">if</span>(i==nx-1){
<a name="l04350"></a>04350                         gxcf[IJKx(j,k,1)] = val;
<a name="l04351"></a>04351                     }
<a name="l04352"></a>04352                     <span class="keywordflow">if</span>(j==0){
<a name="l04353"></a>04353                         gycf[IJKy(i,k,0)] = val;
<a name="l04354"></a>04354                     }
<a name="l04355"></a>04355                     <span class="keywordflow">if</span>(j==ny-1){
<a name="l04356"></a>04356                         gycf[IJKy(i,k,1)] = val;
<a name="l04357"></a>04357                     }
<a name="l04358"></a>04358                     <span class="keywordflow">if</span>(k==0){
<a name="l04359"></a>04359                         gzcf[IJKz(i,j,0)] = val;
<a name="l04360"></a>04360                     }
<a name="l04361"></a>04361                     <span class="keywordflow">if</span>(k==nz-1){
<a name="l04362"></a>04362                         gzcf[IJKz(i,j,1)] = val;
<a name="l04363"></a>04363                     }
<a name="l04364"></a>04364                 } <span class="comment">/* End grid point is valid */</span>
<a name="l04365"></a>04365             } <span class="comment">/* End i loop */</span>
<a name="l04366"></a>04366         } <span class="comment">/* End j loop */</span>
<a name="l04367"></a>04367     } <span class="comment">/* End k loop */</span>
<a name="l04368"></a>04368 
<a name="l04369"></a>04369 }
<a name="l04370"></a>04370 <span class="preprocessor">#endif</span>
<a name="l04371"></a>04371 <span class="preprocessor"></span>
<a name="l04372"></a><a class="code" href="vpmg_8h.html#a9803b64d96685d27923d899ef6f4c5cd">04372</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a9803b64d96685d27923d899ef6f4c5cd" title="Fill boundary condition arrays.">bcCalc</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee){
<a name="l04373"></a>04373 
<a name="l04374"></a>04374     <span class="keywordtype">int</span> i, j, k;
<a name="l04375"></a>04375     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l04376"></a>04376 
<a name="l04377"></a>04377     <span class="keywordtype">double</span> zmem, eps_m, Lmem, memv, eps_w, xkappa;
<a name="l04378"></a>04378 
<a name="l04379"></a>04379     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l04380"></a>04380     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l04381"></a>04381     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l04382"></a>04382 
<a name="l04383"></a>04383     <span class="comment">/* Zero out the boundaries */</span>
<a name="l04384"></a>04384     <span class="comment">/* the &quot;i&quot; boundaries (dirichlet) */</span>
<a name="l04385"></a>04385     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l04386"></a>04386         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l04387"></a>04387             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,0)] = 0.0;
<a name="l04388"></a>04388             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,1)] = 0.0;
<a name="l04389"></a>04389             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,2)] = 0.0;
<a name="l04390"></a>04390             thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,3)] = 0.0;
<a name="l04391"></a>04391         }
<a name="l04392"></a>04392     }
<a name="l04393"></a>04393 
<a name="l04394"></a>04394     <span class="comment">/* the &quot;j&quot; boundaries (dirichlet) */</span>
<a name="l04395"></a>04395     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l04396"></a>04396         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l04397"></a>04397             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,0)] = 0.0;
<a name="l04398"></a>04398             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,1)] = 0.0;
<a name="l04399"></a>04399             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,2)] = 0.0;
<a name="l04400"></a>04400             thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,3)] = 0.0;
<a name="l04401"></a>04401         }
<a name="l04402"></a>04402     }
<a name="l04403"></a>04403 
<a name="l04404"></a>04404     <span class="comment">/* the &quot;k&quot; boundaries (dirichlet) */</span>
<a name="l04405"></a>04405     <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l04406"></a>04406         <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l04407"></a>04407             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,0)] = 0.0;
<a name="l04408"></a>04408             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,1)] = 0.0;
<a name="l04409"></a>04409             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,2)] = 0.0;
<a name="l04410"></a>04410             thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,3)] = 0.0;
<a name="l04411"></a>04411         }
<a name="l04412"></a>04412     }
<a name="l04413"></a>04413 
<a name="l04414"></a>04414     <span class="keywordflow">switch</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a>) {
<a name="l04415"></a>04415             <span class="comment">/*  If we have zero boundary conditions, we&#39;re done */</span>
<a name="l04416"></a>04416         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a938886846c2d77f2f01352f17628692f">BCFL_ZERO</a>:
<a name="l04417"></a>04417             <span class="keywordflow">return</span>;
<a name="l04418"></a>04418         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a5b0fd9934f32bb7255ed6ebc373a6ad4">BCFL_SDH</a>:
<a name="l04419"></a>04419             bcfl_sdh(thee);
<a name="l04420"></a>04420             <span class="keywordflow">break</span>;
<a name="l04421"></a>04421         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a27a9bff27804c87341c57807c4be7a67">BCFL_MDH</a>:
<a name="l04422"></a>04422 <span class="preprocessor">#if defined(WITH_TINKER)</span>
<a name="l04423"></a>04423 <span class="preprocessor"></span>            bcfl_mdh_tinker(thee);
<a name="l04424"></a>04424 <span class="preprocessor">#else</span>
<a name="l04425"></a>04425 <span class="preprocessor"></span>
<a name="l04426"></a>04426 <span class="preprocessor">#ifdef DEBUG_MAC_OSX_OCL</span>
<a name="l04427"></a>04427 <span class="preprocessor"></span><span class="preprocessor">#include &quot;mach_chud.h&quot;</span>
<a name="l04428"></a>04428             uint64_t mbeg = mach_absolute_time();
<a name="l04429"></a>04429 
<a name="l04430"></a>04430             <span class="comment">/*</span>
<a name="l04431"></a>04431 <span class="comment">             * If OpenCL is available we use it, otherwise fall back to</span>
<a name="l04432"></a>04432 <span class="comment">             * normal route (CPU multithreaded w/ OpenMP)</span>
<a name="l04433"></a>04433 <span class="comment">             */</span>
<a name="l04434"></a>04434             <span class="keywordflow">if</span> (kOpenCLAvailable == 1) bcflnewOpenCL(thee);
<a name="l04435"></a>04435             <span class="keywordflow">else</span> bcflnew(thee);
<a name="l04436"></a>04436 
<a name="l04437"></a>04437             mets_(&amp;mbeg, <span class="stringliteral">&quot;MDH&quot;</span>);
<a name="l04438"></a>04438 <span class="preprocessor">#else</span>
<a name="l04439"></a>04439 <span class="preprocessor"></span>            <span class="comment">/* bcfl_mdh(thee); */</span>
<a name="l04440"></a>04440             bcflnew(thee);
<a name="l04441"></a>04441 <span class="preprocessor">#endif </span><span class="comment">/* DEBUG_MAC_OSX_OCL */</span>
<a name="l04442"></a>04442 
<a name="l04443"></a>04443 <span class="preprocessor">#endif </span><span class="comment">/* WITH_TINKER */</span>
<a name="l04444"></a>04444             <span class="keywordflow">break</span>;
<a name="l04445"></a>04445         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201aca72ad232e97659d66f2ae7f13969cfe">BCFL_MEM</a>:
<a name="l04446"></a>04446 
<a name="l04447"></a>04447             zmem  = <a class="code" href="group___vpbe.html#ga65394a771afdf72438400665484f713d" title="Get z position of the membrane bottom.">Vpbe_getzmem</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l04448"></a>04448             Lmem  = <a class="code" href="group___vpbe.html#gaafd907bf54994c337dc3962b8c445e84" title="Get length of the membrane (A)aauthor Michael Grabe.">Vpbe_getLmem</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l04449"></a>04449             eps_m = <a class="code" href="group___vpbe.html#gaa92d6d1c93aedbfa059fd52e0be214c5" title="Get membrane dielectric constant.">Vpbe_getmembraneDiel</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l04450"></a>04450             memv =  <a class="code" href="group___vpbe.html#ga513e4ba228cbce76d264c76efea1e624" title="Get membrane potential (kT)">Vpbe_getmemv</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l04451"></a>04451 
<a name="l04452"></a>04452             eps_w = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l04453"></a>04453             xkappa = <a class="code" href="group___vpbe.html#ga7695a6f94ede72e89779a64b2f7a2217" title="Get Debye-Huckel parameter.">Vpbe_getXkappa</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l04454"></a>04454 
<a name="l04455"></a>04455             bcfl_mem(zmem, Lmem, eps_m, eps_w, memv, xkappa,
<a name="l04456"></a>04456                   thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>,
<a name="l04457"></a>04457                   thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>, thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>, nx, ny, nz);
<a name="l04458"></a>04458             <span class="keywordflow">break</span>;
<a name="l04459"></a>04459         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a4220be78e81865a755b75866cf05277f">BCFL_UNUSED</a>:
<a name="l04460"></a>04460             Vnm_print(2, <span class="stringliteral">&quot;bcCalc:  Invalid bcfl (%d)!\n&quot;</span>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a>);
<a name="l04461"></a>04461             VASSERT(0);
<a name="l04462"></a>04462             <span class="keywordflow">break</span>;
<a name="l04463"></a>04463         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>:
<a name="l04464"></a>04464             Vnm_print(2, <span class="stringliteral">&quot;VPMG::bcCalc -- not appropriate for focusing!\n&quot;</span>);
<a name="l04465"></a>04465             VASSERT(0);
<a name="l04466"></a>04466             <span class="keywordflow">break</span>;
<a name="l04467"></a>04467         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>:
<a name="l04468"></a>04468             bcfl_map(thee);
<a name="l04469"></a>04469             focusFillBound(thee,VNULL);
<a name="l04470"></a>04470             <span class="keywordflow">break</span>;
<a name="l04471"></a>04471         <span class="keywordflow">default</span>:
<a name="l04472"></a>04472             Vnm_print(2, <span class="stringliteral">&quot;VPMG::bcCalc -- invalid boundary condition \</span>
<a name="l04473"></a>04473 <span class="stringliteral">                      flag (%d)!\n&quot;</span>, thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a>);
<a name="l04474"></a>04474             VASSERT(0);
<a name="l04475"></a>04475             <span class="keywordflow">break</span>;
<a name="l04476"></a>04476     }
<a name="l04477"></a>04477 }
<a name="l04478"></a>04478 
<a name="l04479"></a><a class="code" href="vpmg_8h.html#a35949511a7f2779c8ac7e7c88bdca001">04479</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a35949511a7f2779c8ac7e7c88bdca001" title="Fill operator coefficient arrays from pre-calculated maps.">fillcoCoefMap</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l04480"></a>04480 
<a name="l04481"></a>04481     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04482"></a>04482     <span class="keywordtype">double</span> ionstr, position[3], tkappa, eps, pot, hx, hy, hzed;
<a name="l04483"></a>04483     <span class="keywordtype">int</span> i, j, k, nx, ny, nz;
<a name="l04484"></a>04484     <span class="keywordtype">double</span> kappamax;
<a name="l04485"></a>04485     VASSERT(thee != VNULL);
<a name="l04486"></a>04486 
<a name="l04487"></a>04487     <span class="comment">/* Get PBE info */</span>
<a name="l04488"></a>04488     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04489"></a>04489     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(pbe);
<a name="l04490"></a>04490 
<a name="l04491"></a>04491     <span class="comment">/* Mesh info */</span>
<a name="l04492"></a>04492     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l04493"></a>04493     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l04494"></a>04494     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l04495"></a>04495     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l04496"></a>04496     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l04497"></a>04497     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l04498"></a>04498 
<a name="l04499"></a>04499     <span class="keywordflow">if</span> ((!thee-&gt;<a class="code" href="structs_vpmg.html#aabc9813d7bb766c5361e421db6efabb2">useDielXMap</a>) || (!thee-&gt;<a class="code" href="structs_vpmg.html#a96d6eb86ab769d22e762da608c518190">useDielYMap</a>)
<a name="l04500"></a>04500         || (!thee-&gt;<a class="code" href="structs_vpmg.html#a1735e6924b92c76dc0b4eb3f2501ee33">useDielZMap</a>) || ((!thee-&gt;<a class="code" href="structs_vpmg.html#ad5f2fc675c0c6d12488dc6d02e599ade">useKappaMap</a>) &amp;&amp; (ionstr&gt;<a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>))) {
<a name="l04501"></a>04501 
<a name="l04502"></a>04502         Vnm_print(2, <span class="stringliteral">&quot;fillcoCoefMap:  You need to use all coefficient maps!\n&quot;</span>);
<a name="l04503"></a>04503         VASSERT(0);
<a name="l04504"></a>04504 
<a name="l04505"></a>04505     }
<a name="l04506"></a>04506 
<a name="l04507"></a>04507     <span class="comment">/* Scale the kappa map to values between 0 and 1</span>
<a name="l04508"></a>04508 <span class="comment">       Thus get the maximum value in the map - this</span>
<a name="l04509"></a>04509 <span class="comment">       is theoretically unnecessary, but a good check.*/</span>
<a name="l04510"></a>04510     kappamax = -1.00;
<a name="l04511"></a>04511     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l04512"></a>04512         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l04513"></a>04513             <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l04514"></a>04514                 <span class="keywordflow">if</span> (ionstr &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l04515"></a>04515                      position[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[i];
<a name="l04516"></a>04516                      position[1] = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[j];
<a name="l04517"></a>04517                      position[2] = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[k];
<a name="l04518"></a>04518                      <span class="keywordflow">if</span> (!<a class="code" href="group___vgrid.html#gae96a803dbd3016673affbc3d10310150" title="Get potential value (from mesh or approximation) at a point.">Vgrid_value</a>(thee-&gt;<a class="code" href="structs_vpmg.html#aa3ffd50808f24b927e1828a3e2aacdd7">kappaMap</a>, position, &amp;tkappa)) {
<a name="l04519"></a>04519                          Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Off kappaMap at:\n&quot;</span>);
<a name="l04520"></a>04520                          Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  (x,y,z) = (%g,%g %g)\n&quot;</span>,
<a name="l04521"></a>04521                                    position[0], position[1], position[2]);
<a name="l04522"></a>04522                          VASSERT(0);
<a name="l04523"></a>04523                      }
<a name="l04524"></a>04524                      <span class="keywordflow">if</span> (tkappa &gt; kappamax) {
<a name="l04525"></a>04525                          kappamax = tkappa;
<a name="l04526"></a>04526                      }
<a name="l04527"></a>04527                      <span class="keywordflow">if</span> (tkappa &lt; 0.0){
<a name="l04528"></a>04528                        Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillcoCoefMap: Kappa map less than 0\n&quot;</span>);
<a name="l04529"></a>04529                        Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillcoCoefMap: at (x,y,z) = (%g,%g %g)\n&quot;</span>,
<a name="l04530"></a>04530                                  position[0], position[1], position[2]);
<a name="l04531"></a>04531                        VASSERT(0);
<a name="l04532"></a>04532                      }
<a name="l04533"></a>04533                 }
<a name="l04534"></a>04534             }
<a name="l04535"></a>04535         }
<a name="l04536"></a>04536     }
<a name="l04537"></a>04537 
<a name="l04538"></a>04538     <span class="keywordflow">if</span> (kappamax &gt; 1.0){
<a name="l04539"></a>04539       Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillcoCoefMap:  Maximum Kappa value\n&quot;</span>);
<a name="l04540"></a>04540       Vnm_print(2, <span class="stringliteral">&quot;%g is greater than 1 - will scale appropriately!\n&quot;</span>,
<a name="l04541"></a>04541                 kappamax);
<a name="l04542"></a>04542     }
<a name="l04543"></a>04543     <span class="keywordflow">else</span> {
<a name="l04544"></a>04544       kappamax = 1.0;
<a name="l04545"></a>04545     }
<a name="l04546"></a>04546 
<a name="l04547"></a>04547     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l04548"></a>04548         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l04549"></a>04549             <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l04550"></a>04550 
<a name="l04551"></a>04551                 <span class="keywordflow">if</span> (ionstr &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l04552"></a>04552                      position[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[i];
<a name="l04553"></a>04553                      position[1] = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[j];
<a name="l04554"></a>04554                      position[2] = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[k];
<a name="l04555"></a>04555                      <span class="keywordflow">if</span> (!<a class="code" href="group___vgrid.html#gae96a803dbd3016673affbc3d10310150" title="Get potential value (from mesh or approximation) at a point.">Vgrid_value</a>(thee-&gt;<a class="code" href="structs_vpmg.html#aa3ffd50808f24b927e1828a3e2aacdd7">kappaMap</a>, position, &amp;tkappa)) {
<a name="l04556"></a>04556                          Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Off kappaMap at:\n&quot;</span>);
<a name="l04557"></a>04557                          Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  (x,y,z) = (%g,%g %g)\n&quot;</span>,
<a name="l04558"></a>04558                            position[0], position[1], position[2]);
<a name="l04559"></a>04559                          VASSERT(0);
<a name="l04560"></a>04560                      }
<a name="l04561"></a>04561                      <span class="keywordflow">if</span> (tkappa &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) tkappa = 0.0;
<a name="l04562"></a>04562                      thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] = (tkappa / kappamax);
<a name="l04563"></a>04563                 }
<a name="l04564"></a>04564 
<a name="l04565"></a>04565                 position[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[i] + 0.5*hx;
<a name="l04566"></a>04566                 position[1] = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[j];
<a name="l04567"></a>04567                 position[2] = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[k];
<a name="l04568"></a>04568                 <span class="keywordflow">if</span> (!<a class="code" href="group___vgrid.html#gae96a803dbd3016673affbc3d10310150" title="Get potential value (from mesh or approximation) at a point.">Vgrid_value</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a38134d9a49656dcb9f368d07cd309668">dielXMap</a>, position, &amp;eps)) {
<a name="l04569"></a>04569                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Off dielXMap at:\n&quot;</span>);
<a name="l04570"></a>04570                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  (x,y,z) = (%g,%g %g)\n&quot;</span>,
<a name="l04571"></a>04571                       position[0], position[1], position[2]);
<a name="l04572"></a>04572                     VASSERT(0);
<a name="l04573"></a>04573                  }
<a name="l04574"></a>04574                  thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] = eps;
<a name="l04575"></a>04575 
<a name="l04576"></a>04576                  position[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[i];
<a name="l04577"></a>04577                  position[1] = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[j] + 0.5*hy;
<a name="l04578"></a>04578                  position[2] = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[k];
<a name="l04579"></a>04579                  <span class="keywordflow">if</span> (!<a class="code" href="group___vgrid.html#gae96a803dbd3016673affbc3d10310150" title="Get potential value (from mesh or approximation) at a point.">Vgrid_value</a>(thee-&gt;<a class="code" href="structs_vpmg.html#ac8831cd0b192d78a05b3ed38b1434137">dielYMap</a>, position, &amp;eps)) {
<a name="l04580"></a>04580                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Off dielYMap at:\n&quot;</span>);
<a name="l04581"></a>04581                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  (x,y,z) = (%g,%g %g)\n&quot;</span>,
<a name="l04582"></a>04582                       position[0], position[1], position[2]);
<a name="l04583"></a>04583                     VASSERT(0);
<a name="l04584"></a>04584                  }
<a name="l04585"></a>04585                  thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] = eps;
<a name="l04586"></a>04586 
<a name="l04587"></a>04587                  position[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[i];
<a name="l04588"></a>04588                  position[1] = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[j];
<a name="l04589"></a>04589                  position[2] = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[k] + 0.5*hzed;
<a name="l04590"></a>04590                  <span class="keywordflow">if</span> (!<a class="code" href="group___vgrid.html#gae96a803dbd3016673affbc3d10310150" title="Get potential value (from mesh or approximation) at a point.">Vgrid_value</a>(thee-&gt;<a class="code" href="structs_vpmg.html#acb1fce9e3e8e32859a9aae06ceccb6f1">dielZMap</a>, position, &amp;eps)) {
<a name="l04591"></a>04591                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Off dielZMap at:\n&quot;</span>);
<a name="l04592"></a>04592                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  (x,y,z) = (%g,%g %g)\n&quot;</span>,
<a name="l04593"></a>04593                       position[0], position[1], position[2]);
<a name="l04594"></a>04594                     VASSERT(0);
<a name="l04595"></a>04595                  }
<a name="l04596"></a>04596                  thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] = eps;
<a name="l04597"></a>04597             }
<a name="l04598"></a>04598         }
<a name="l04599"></a>04599     }
<a name="l04600"></a>04600 }
<a name="l04601"></a>04601 
<a name="l04602"></a><a class="code" href="vpmg_8h.html#a62617829770eaed11c159947453e457c">04602</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a62617829770eaed11c159947453e457c" title="Fill operator coefficient arrays from a molecular surface calculation.">fillcoCoefMol</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l04603"></a>04603 
<a name="l04604"></a>04604     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#aabc9813d7bb766c5361e421db6efabb2">useDielXMap</a> || thee-&gt;<a class="code" href="structs_vpmg.html#a96d6eb86ab769d22e762da608c518190">useDielYMap</a> || thee-&gt;<a class="code" href="structs_vpmg.html#a1735e6924b92c76dc0b4eb3f2501ee33">useDielZMap</a> ||
<a name="l04605"></a>04605       thee-&gt;<a class="code" href="structs_vpmg.html#ad5f2fc675c0c6d12488dc6d02e599ade">useKappaMap</a>)  {
<a name="l04606"></a>04606 
<a name="l04607"></a>04607         <a class="code" href="vpmg_8c.html#a35949511a7f2779c8ac7e7c88bdca001" title="Fill operator coefficient arrays from pre-calculated maps.">fillcoCoefMap</a>(thee);
<a name="l04608"></a>04608 
<a name="l04609"></a>04609     } <span class="keywordflow">else</span> {
<a name="l04610"></a>04610 
<a name="l04611"></a>04611         <a class="code" href="vpmg_8c.html#a34484f0f2f254b954abf20c5a98ab9d4" title="Fill differential operator coefficient arrays from a molecular surface calculation.">fillcoCoefMolDiel</a>(thee);
<a name="l04612"></a>04612         <a class="code" href="vpmg_8c.html#a9217fdfc8737424d5e5ccc1193f9c3b0" title="Fill ion (nonlinear) operator coefficient array from a molecular surface calculation.">fillcoCoefMolIon</a>(thee);
<a name="l04613"></a>04613 
<a name="l04614"></a>04614     }
<a name="l04615"></a>04615 
<a name="l04616"></a>04616 }
<a name="l04617"></a>04617 
<a name="l04618"></a><a class="code" href="vpmg_8h.html#a9217fdfc8737424d5e5ccc1193f9c3b0">04618</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a9217fdfc8737424d5e5ccc1193f9c3b0" title="Fill ion (nonlinear) operator coefficient array from a molecular surface calculation.">fillcoCoefMolIon</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l04619"></a>04619 
<a name="l04620"></a>04620     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l04621"></a>04621     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l04622"></a>04622     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04623"></a>04623     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l04624"></a>04624     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax, ionmask, ionstr;
<a name="l04625"></a>04625     <span class="keywordtype">double</span> xlen, ylen, zlen, irad;
<a name="l04626"></a>04626     <span class="keywordtype">double</span> hx, hy, hzed, *apos, arad;
<a name="l04627"></a>04627     <span class="keywordtype">int</span> i, nx, ny, nz, iatom;
<a name="l04628"></a>04628     <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> surfMeth;
<a name="l04629"></a>04629 
<a name="l04630"></a>04630     VASSERT(thee != VNULL);
<a name="l04631"></a>04631     surfMeth = thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>;
<a name="l04632"></a>04632 
<a name="l04633"></a>04633     <span class="comment">/* Get PBE info */</span>
<a name="l04634"></a>04634     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04635"></a>04635     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l04636"></a>04636     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l04637"></a>04637     irad = <a class="code" href="group___vpbe.html#gabf77d3500a5e3b3c8673eab703bb53e0" title="Get maximum radius of ion species.">Vpbe_getMaxIonRadius</a>(pbe);
<a name="l04638"></a>04638     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(pbe);
<a name="l04639"></a>04639 
<a name="l04640"></a>04640     <span class="comment">/* Mesh info */</span>
<a name="l04641"></a>04641     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l04642"></a>04642     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l04643"></a>04643     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l04644"></a>04644     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l04645"></a>04645     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l04646"></a>04646     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l04647"></a>04647 
<a name="l04648"></a>04648     <span class="comment">/* Define the total domain size */</span>
<a name="l04649"></a>04649     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l04650"></a>04650     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l04651"></a>04651     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l04652"></a>04652 
<a name="l04653"></a>04653     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l04654"></a>04654     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l04655"></a>04655     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l04656"></a>04656     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l04657"></a>04657     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l04658"></a>04658     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l04659"></a>04659     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l04660"></a>04660 
<a name="l04661"></a>04661     <span class="comment">/* This is a floating point parameter related to the non-zero nature of the</span>
<a name="l04662"></a>04662 <span class="comment">     * bulk ionic strength.  If the ionic strength is greater than zero; this</span>
<a name="l04663"></a>04663 <span class="comment">     * parameter is set to 1.0 and later scaled by the appropriate pre-factors.</span>
<a name="l04664"></a>04664 <span class="comment">     * Otherwise, this parameter is set to 0.0 */</span>
<a name="l04665"></a>04665     <span class="keywordflow">if</span> (ionstr &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) ionmask = 1.0;
<a name="l04666"></a>04666     <span class="keywordflow">else</span> ionmask = 0.0;
<a name="l04667"></a>04667 
<a name="l04668"></a>04668     <span class="comment">/* Reset the kappa array, marking everything accessible */</span>
<a name="l04669"></a>04669     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] = ionmask;
<a name="l04670"></a>04670 
<a name="l04671"></a>04671     if (ionstr &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) <span class="keywordflow">return</span>;
<a name="l04672"></a>04672 
<a name="l04673"></a>04673     <span class="comment">/* Loop through the atoms and set kappa = 0.0 (inaccessible) if a point</span>
<a name="l04674"></a>04674 <span class="comment">     * is inside the ion-inflated van der Waals radii */</span>
<a name="l04675"></a>04675     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l04676"></a>04676 
<a name="l04677"></a>04677         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l04678"></a>04678         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l04679"></a>04679         arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l04680"></a>04680 
<a name="l04681"></a>04681         <span class="keywordflow">if</span> (arad &gt; VSMALL) {
<a name="l04682"></a>04682 
<a name="l04683"></a>04683             <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l04684"></a>04684             <span class="keywordflow">if</span> ((apos[0]&lt;(xmin-irad-arad)) || (apos[0]&gt;(xmax+irad+arad))  || \
<a name="l04685"></a>04685                 (apos[1]&lt;(ymin-irad-arad)) || (apos[1]&gt;(ymax+irad+arad))  || \
<a name="l04686"></a>04686                 (apos[2]&lt;(zmin-irad-arad)) || (apos[2]&gt;(zmax+irad+arad))) {
<a name="l04687"></a>04687                 <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l04688"></a>04688                     (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l04689"></a>04689                     Vnm_print(2,
<a name="l04690"></a>04690     <span class="stringliteral">&quot;Vpmg_fillco:  Atom #%d at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l04691"></a>04691                       iatom, apos[0], apos[1], apos[2]);
<a name="l04692"></a>04692                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  xmin = %g, xmax = %g\n&quot;</span>,
<a name="l04693"></a>04693                       xmin, xmax);
<a name="l04694"></a>04694                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  ymin = %g, ymax = %g\n&quot;</span>,
<a name="l04695"></a>04695                       ymin, ymax);
<a name="l04696"></a>04696                     Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  zmin = %g, zmax = %g\n&quot;</span>,
<a name="l04697"></a>04697                       zmin, zmax);
<a name="l04698"></a>04698                 }
<a name="l04699"></a>04699                 fflush(stderr);
<a name="l04700"></a>04700 
<a name="l04701"></a>04701             } <span class="keywordflow">else</span> { <span class="comment">/* if we&#39;re on the mesh */</span>
<a name="l04702"></a>04702 
<a name="l04703"></a>04703                 <span class="comment">/* Mark ions */</span>
<a name="l04704"></a>04704                 <a class="code" href="vpmg_8c.html#af4f11e78d20500aa43167eab5e52752f" title="Mark the grid points inside a sphere with a particular value. This marks by resetting the the grid po...">markSphere</a>((irad+arad), apos,
<a name="l04705"></a>04705                         nx, ny, nz,
<a name="l04706"></a>04706                         hx, hy, hzed,
<a name="l04707"></a>04707                         xmin, ymin, zmin,
<a name="l04708"></a>04708                         thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>, 0.0);
<a name="l04709"></a>04709 
<a name="l04710"></a>04710             } <span class="comment">/* endif (on the mesh) */</span>
<a name="l04711"></a>04711         }
<a name="l04712"></a>04712     } <span class="comment">/* endfor (over all atoms) */</span>
<a name="l04713"></a>04713 
<a name="l04714"></a>04714 }
<a name="l04715"></a>04715 
<a name="l04716"></a><a class="code" href="vpmg_8h.html#a34484f0f2f254b954abf20c5a98ab9d4">04716</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a34484f0f2f254b954abf20c5a98ab9d4" title="Fill differential operator coefficient arrays from a molecular surface calculation.">fillcoCoefMolDiel</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l04717"></a>04717 
<a name="l04718"></a>04718     <span class="comment">/* Always call NoSmooth to fill the epsilon arrays */</span>
<a name="l04719"></a>04719     <a class="code" href="vpmg_8c.html#adf9fff114eed3d5d94f3adbbf9527483" title="Fill differential operator coefficient arrays from a molecular surface calculation without smoothing...">fillcoCoefMolDielNoSmooth</a>(thee);
<a name="l04720"></a>04720 
<a name="l04721"></a>04721     <span class="comment">/* Call the smoothing algorithm as needed */</span>
<a name="l04722"></a>04722     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a> == <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8a5a9c3bd0f3896b676ca0e5c77bd7792a">VSM_MOLSMOOTH</a>) {
<a name="l04723"></a>04723         <a class="code" href="vpmg_8c.html#aafab27ad33274047911bd2ec092eb265" title="Fill differential operator coefficient arrays from a molecular surface calculation with smoothing...">fillcoCoefMolDielSmooth</a>(thee);
<a name="l04724"></a>04724     }
<a name="l04725"></a>04725 }
<a name="l04726"></a>04726 
<a name="l04727"></a><a class="code" href="vpmg_8h.html#adf9fff114eed3d5d94f3adbbf9527483">04727</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#adf9fff114eed3d5d94f3adbbf9527483" title="Fill differential operator coefficient arrays from a molecular surface calculation without smoothing...">fillcoCoefMolDielNoSmooth</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l04728"></a>04728 
<a name="l04729"></a>04729     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l04730"></a>04730     <a class="code" href="structs_vacc_surf.html" title="Surface object list of per-atom surface points.">VaccSurf</a> *asurf;
<a name="l04731"></a>04731     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l04732"></a>04732     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04733"></a>04733     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l04734"></a>04734     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax;
<a name="l04735"></a>04735     <span class="keywordtype">double</span> xlen, ylen, zlen, position[3];
<a name="l04736"></a>04736     <span class="keywordtype">double</span> srad, epsw, epsp, deps, area;
<a name="l04737"></a>04737     <span class="keywordtype">double</span> hx, hy, hzed, *apos, arad;
<a name="l04738"></a>04738     <span class="keywordtype">int</span> i, nx, ny, nz, ntot, iatom, ipt;
<a name="l04739"></a>04739 
<a name="l04740"></a>04740     <span class="comment">/* Get PBE info */</span>
<a name="l04741"></a>04741     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04742"></a>04742     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l04743"></a>04743     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l04744"></a>04744     srad = <a class="code" href="group___vpbe.html#ga87631b31eefd5639e45c43f972344f29" title="Get solvent molecule radius.">Vpbe_getSolventRadius</a>(pbe);
<a name="l04745"></a>04745     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l04746"></a>04746     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l04747"></a>04747 
<a name="l04748"></a>04748     <span class="comment">/* Mesh info */</span>
<a name="l04749"></a>04749     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l04750"></a>04750     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l04751"></a>04751     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l04752"></a>04752     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l04753"></a>04753     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l04754"></a>04754     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l04755"></a>04755 
<a name="l04756"></a>04756     <span class="comment">/* Define the total domain size */</span>
<a name="l04757"></a>04757     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l04758"></a>04758     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l04759"></a>04759     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l04760"></a>04760 
<a name="l04761"></a>04761     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l04762"></a>04762     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l04763"></a>04763     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l04764"></a>04764     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l04765"></a>04765     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l04766"></a>04766     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l04767"></a>04767     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l04768"></a>04768 
<a name="l04769"></a>04769     <span class="comment">/* Reset the arrays */</span>
<a name="l04770"></a>04770     ntot = nx*ny*nz;
<a name="l04771"></a>04771     <span class="keywordflow">for</span> (i=0; i&lt;ntot; i++) {
<a name="l04772"></a>04772         thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i] = epsw;
<a name="l04773"></a>04773         thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i] = epsw;
<a name="l04774"></a>04774         thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i] = epsw;
<a name="l04775"></a>04775     }
<a name="l04776"></a>04776 
<a name="l04777"></a>04777     <span class="comment">/* Loop through the atoms and set a{123}cf = 0.0 (inaccessible)</span>
<a name="l04778"></a>04778 <span class="comment">     * if a point is inside the solvent-inflated van der Waals radii */</span>
<a name="l04779"></a>04779 <span class="preprocessor">#pragma omp parallel for default(shared) private(iatom,atom,apos,arad)</span>
<a name="l04780"></a>04780 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l04781"></a>04781 
<a name="l04782"></a>04782         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l04783"></a>04783         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l04784"></a>04784         arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l04785"></a>04785 
<a name="l04786"></a>04786         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l04787"></a>04787         <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l04788"></a>04788             (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l04789"></a>04789             (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l04790"></a>04790             <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l04791"></a>04791                 (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l04792"></a>04792                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Atom #%d at (%4.3f, %4.3f,\</span>
<a name="l04793"></a>04793 <span class="stringliteral"> %4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l04794"></a>04794                   iatom, apos[0], apos[1], apos[2]);
<a name="l04795"></a>04795                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  xmin = %g, xmax = %g\n&quot;</span>,
<a name="l04796"></a>04796                   xmin, xmax);
<a name="l04797"></a>04797                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  ymin = %g, ymax = %g\n&quot;</span>,
<a name="l04798"></a>04798                   ymin, ymax);
<a name="l04799"></a>04799                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  zmin = %g, zmax = %g\n&quot;</span>,
<a name="l04800"></a>04800                   zmin, zmax);
<a name="l04801"></a>04801             }
<a name="l04802"></a>04802             fflush(stderr);
<a name="l04803"></a>04803 
<a name="l04804"></a>04804         } <span class="keywordflow">else</span> { <span class="comment">/* if we&#39;re on the mesh */</span>
<a name="l04805"></a>04805 
<a name="l04806"></a>04806             <span class="keywordflow">if</span> (arad &gt; VSMALL) {
<a name="l04807"></a>04807                 <span class="comment">/* Mark x-shifted dielectric */</span>
<a name="l04808"></a>04808                 <a class="code" href="vpmg_8c.html#af4f11e78d20500aa43167eab5e52752f" title="Mark the grid points inside a sphere with a particular value. This marks by resetting the the grid po...">markSphere</a>((arad+srad), apos,
<a name="l04809"></a>04809                         nx, ny, nz,
<a name="l04810"></a>04810                         hx, hy, hzed,
<a name="l04811"></a>04811                         (xmin+0.5*hx), ymin, zmin,
<a name="l04812"></a>04812                         thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>, epsp);
<a name="l04813"></a>04813 
<a name="l04814"></a>04814                 <span class="comment">/* Mark y-shifted dielectric */</span>
<a name="l04815"></a>04815                 <a class="code" href="vpmg_8c.html#af4f11e78d20500aa43167eab5e52752f" title="Mark the grid points inside a sphere with a particular value. This marks by resetting the the grid po...">markSphere</a>((arad+srad), apos,
<a name="l04816"></a>04816                         nx, ny, nz,
<a name="l04817"></a>04817                         hx, hy, hzed,
<a name="l04818"></a>04818                         xmin, (ymin+0.5*hy), zmin,
<a name="l04819"></a>04819                         thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>, epsp);
<a name="l04820"></a>04820 
<a name="l04821"></a>04821                 <span class="comment">/* Mark z-shifted dielectric */</span>
<a name="l04822"></a>04822                 <a class="code" href="vpmg_8c.html#af4f11e78d20500aa43167eab5e52752f" title="Mark the grid points inside a sphere with a particular value. This marks by resetting the the grid po...">markSphere</a>((arad+srad), apos,
<a name="l04823"></a>04823                         nx, ny, nz,
<a name="l04824"></a>04824                         hx, hy, hzed,
<a name="l04825"></a>04825                         xmin, ymin, (zmin+0.5*hzed),
<a name="l04826"></a>04826                         thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>, epsp);
<a name="l04827"></a>04827             }
<a name="l04828"></a>04828 
<a name="l04829"></a>04829         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l04830"></a>04830     } <span class="comment">/* endfor (over all atoms) */</span>
<a name="l04831"></a>04831 
<a name="l04832"></a>04832     area = <a class="code" href="group___vacc.html#gad2041f50041470d01e00a17f18b5b6c2" title="Build the solvent accessible surface (SAS) and calculate the solvent accessible surface area...">Vacc_SASA</a>(acc, srad);
<a name="l04833"></a>04833 
<a name="l04834"></a>04834     <span class="comment">/* We only need to do the next step for non-zero solvent radii */</span>
<a name="l04835"></a>04835     <span class="keywordflow">if</span> (srad &gt; VSMALL) {
<a name="l04836"></a>04836 
<a name="l04837"></a>04837         <span class="comment">/* Now loop over the solvent accessible surface points */</span>
<a name="l04838"></a>04838 
<a name="l04839"></a>04839 <span class="preprocessor">#pragma omp parallel for default(shared) private(iatom,atom,area,asurf,ipt,position)</span>
<a name="l04840"></a>04840 <span class="preprocessor"></span>        <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l04841"></a>04841             atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l04842"></a>04842             area = <a class="code" href="group___vacc.html#ga9913f912bca5c71ba11ef9aefe7c390c" title="Return the atomic solvent accessible surface area (SASA)">Vacc_atomSASA</a>(acc, srad, atom);
<a name="l04843"></a>04843             <span class="keywordflow">if</span> (area &gt; 0.0 ) {
<a name="l04844"></a>04844                 asurf = <a class="code" href="group___vacc.html#gaa1b76ea181d5f3a3ddb2b890e470cb3f" title="Get the set of points for this atom&#39;s solvent-accessible surface.">Vacc_atomSASPoints</a>(acc, srad, atom);
<a name="l04845"></a>04845 
<a name="l04846"></a>04846                 <span class="comment">/* Use each point on the SAS to reset the solvent accessibility */</span>
<a name="l04847"></a>04847                 <span class="comment">/* TODO:  Make sure we&#39;re not still wasting time here. */</span>
<a name="l04848"></a>04848                 <span class="keywordflow">for</span> (ipt=0; ipt&lt;(asurf-&gt;<a class="code" href="structs_vacc_surf.html#a0306378cd06415f84b10cb3d15516ec3">npts</a>); ipt++) {
<a name="l04849"></a>04849 
<a name="l04850"></a>04850                     position[0] = asurf-&gt;<a class="code" href="structs_vacc_surf.html#adc11c159667b978601b182a72c2f3776">xpts</a>[ipt];
<a name="l04851"></a>04851                     position[1] = asurf-&gt;<a class="code" href="structs_vacc_surf.html#a3bfb2571d11ee4b7a1f913f83d1af800">ypts</a>[ipt];
<a name="l04852"></a>04852                     position[2] = asurf-&gt;<a class="code" href="structs_vacc_surf.html#a2596a33a35721e9b3f989c98a8c12589">zpts</a>[ipt];
<a name="l04853"></a>04853 
<a name="l04854"></a>04854                     <span class="comment">/* Mark x-shifted dielectric */</span>
<a name="l04855"></a>04855                     <a class="code" href="vpmg_8c.html#af4f11e78d20500aa43167eab5e52752f" title="Mark the grid points inside a sphere with a particular value. This marks by resetting the the grid po...">markSphere</a>(srad, position,
<a name="l04856"></a>04856                                nx, ny, nz,
<a name="l04857"></a>04857                                hx, hy, hzed,
<a name="l04858"></a>04858                                (xmin+0.5*hx), ymin, zmin,
<a name="l04859"></a>04859                                thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>, epsw);
<a name="l04860"></a>04860 
<a name="l04861"></a>04861                     <span class="comment">/* Mark y-shifted dielectric */</span>
<a name="l04862"></a>04862                     <a class="code" href="vpmg_8c.html#af4f11e78d20500aa43167eab5e52752f" title="Mark the grid points inside a sphere with a particular value. This marks by resetting the the grid po...">markSphere</a>(srad, position,
<a name="l04863"></a>04863                                nx, ny, nz,
<a name="l04864"></a>04864                                hx, hy, hzed,
<a name="l04865"></a>04865                                xmin, (ymin+0.5*hy), zmin,
<a name="l04866"></a>04866                                thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>, epsw);
<a name="l04867"></a>04867 
<a name="l04868"></a>04868                     <span class="comment">/* Mark z-shifted dielectric */</span>
<a name="l04869"></a>04869                     <a class="code" href="vpmg_8c.html#af4f11e78d20500aa43167eab5e52752f" title="Mark the grid points inside a sphere with a particular value. This marks by resetting the the grid po...">markSphere</a>(srad, position,
<a name="l04870"></a>04870                                nx, ny, nz,
<a name="l04871"></a>04871                                hx, hy, hzed,
<a name="l04872"></a>04872                                xmin, ymin, (zmin+0.5*hzed),
<a name="l04873"></a>04873                                thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>, epsw);
<a name="l04874"></a>04874 
<a name="l04875"></a>04875                 }
<a name="l04876"></a>04876             }
<a name="l04877"></a>04877         }
<a name="l04878"></a>04878     }
<a name="l04879"></a>04879 }
<a name="l04880"></a>04880 
<a name="l04881"></a><a class="code" href="vpmg_8h.html#aafab27ad33274047911bd2ec092eb265">04881</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#aafab27ad33274047911bd2ec092eb265" title="Fill differential operator coefficient arrays from a molecular surface calculation with smoothing...">fillcoCoefMolDielSmooth</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l04882"></a>04882 
<a name="l04883"></a>04883   <span class="comment">/* This function smoothes using a 9 point method based on</span>
<a name="l04884"></a>04884 <span class="comment">     Bruccoleri, et al. J Comput Chem 18 268-276 (1997).  The nine points</span>
<a name="l04885"></a>04885 <span class="comment">     used are the shifted grid point and the 8 points that are 1/sqrt(2)</span>
<a name="l04886"></a>04886 <span class="comment">     grid spacings away.  The harmonic mean of the 9 points is then used to</span>
<a name="l04887"></a>04887 <span class="comment">     find the overall dielectric value for the point in question. The use of</span>
<a name="l04888"></a>04888 <span class="comment">     this function assumes that the non-smoothed values were placed in the</span>
<a name="l04889"></a>04889 <span class="comment">     dielectric arrays by the fillcoCoefMolDielNoSmooth function.*/</span>
<a name="l04890"></a>04890 
<a name="l04891"></a>04891     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04892"></a>04892     <span class="keywordtype">double</span> frac, epsw;
<a name="l04893"></a>04893     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, numpts;
<a name="l04894"></a>04894 
<a name="l04895"></a>04895     <span class="comment">/* Mesh info */</span>
<a name="l04896"></a>04896     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l04897"></a>04897     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l04898"></a>04898     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l04899"></a>04899 
<a name="l04900"></a>04900     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l04901"></a>04901     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l04902"></a>04902 
<a name="l04903"></a>04903     <span class="comment">/* Copy the existing diel arrays to work arrays */</span>
<a name="l04904"></a>04904     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) {
<a name="l04905"></a>04905         thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[i] = thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i];
<a name="l04906"></a>04906         thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[i] = thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i];
<a name="l04907"></a>04907         thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[i] = thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i];
<a name="l04908"></a>04908         thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i] = epsw;
<a name="l04909"></a>04909         thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i] = epsw;
<a name="l04910"></a>04910         thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i] = epsw;
<a name="l04911"></a>04911     }
<a name="l04912"></a>04912 
<a name="l04913"></a>04913     <span class="comment">/* Smooth the dielectric values */</span>
<a name="l04914"></a>04914     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l04915"></a>04915         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l04916"></a>04916             <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l04917"></a>04917 
<a name="l04918"></a>04918                 <span class="comment">/* Get the 8 points that are 1/sqrt(2) grid spacings away */</span>
<a name="l04919"></a>04919 
<a name="l04920"></a>04920                 <span class="comment">/* Points for the X-shifted array */</span>
<a name="l04921"></a>04921                 frac = 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i,j,k)];
<a name="l04922"></a>04922                 frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i,j,k)];
<a name="l04923"></a>04923                 frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i,j,k)];
<a name="l04924"></a>04924                 numpts = 3;
<a name="l04925"></a>04925 
<a name="l04926"></a>04926                 <span class="keywordflow">if</span> (j &gt; 0) {
<a name="l04927"></a>04927                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i,j-1,k)];
<a name="l04928"></a>04928                     numpts += 1;
<a name="l04929"></a>04929                 }
<a name="l04930"></a>04930                 <span class="keywordflow">if</span> (k &gt; 0) {
<a name="l04931"></a>04931                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i,j,k-1)];
<a name="l04932"></a>04932                     numpts += 1;
<a name="l04933"></a>04933                 }
<a name="l04934"></a>04934                 <span class="keywordflow">if</span> (i &lt; (nx-1)){
<a name="l04935"></a>04935                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i+1,j,k)];
<a name="l04936"></a>04936                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i+1,j,k)];
<a name="l04937"></a>04937                     numpts += 2;
<a name="l04938"></a>04938                     <span class="keywordflow">if</span> (j &gt; 0) {
<a name="l04939"></a>04939                         frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i+1,j-1,k)];
<a name="l04940"></a>04940                         numpts += 1;
<a name="l04941"></a>04941                     }
<a name="l04942"></a>04942                     <span class="keywordflow">if</span> (k &gt; 0) {
<a name="l04943"></a>04943                         frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i+1,j,k-1)];
<a name="l04944"></a>04944                         numpts += 1;
<a name="l04945"></a>04945                     }
<a name="l04946"></a>04946                 }
<a name="l04947"></a>04947                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] = numpts/frac;
<a name="l04948"></a>04948 
<a name="l04949"></a>04949                 <span class="comment">/* Points for the Y-shifted array */</span>
<a name="l04950"></a>04950                 frac = 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i,j,k)];
<a name="l04951"></a>04951                 frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i,j,k)];
<a name="l04952"></a>04952                 frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i,j,k)];
<a name="l04953"></a>04953                 numpts = 3;
<a name="l04954"></a>04954 
<a name="l04955"></a>04955                 <span class="keywordflow">if</span> (i &gt; 0) {
<a name="l04956"></a>04956                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i-1,j,k)];
<a name="l04957"></a>04957                     numpts += 1;
<a name="l04958"></a>04958                 }
<a name="l04959"></a>04959                 <span class="keywordflow">if</span> (k &gt; 0) {
<a name="l04960"></a>04960                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i,j,k-1)];
<a name="l04961"></a>04961                     numpts += 1;
<a name="l04962"></a>04962                 }
<a name="l04963"></a>04963                 <span class="keywordflow">if</span> (j &lt; (ny-1)){
<a name="l04964"></a>04964                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i,j+1,k)];
<a name="l04965"></a>04965                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i,j+1,k)];
<a name="l04966"></a>04966                     numpts += 2;
<a name="l04967"></a>04967                     <span class="keywordflow">if</span> (i &gt; 0) {
<a name="l04968"></a>04968                         frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i-1,j+1,k)];
<a name="l04969"></a>04969                         numpts += 1;
<a name="l04970"></a>04970                     }
<a name="l04971"></a>04971                     <span class="keywordflow">if</span> (k &gt; 0) {
<a name="l04972"></a>04972                         frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i,j+1,k-1)];
<a name="l04973"></a>04973                         numpts += 1;
<a name="l04974"></a>04974                     }
<a name="l04975"></a>04975                 }
<a name="l04976"></a>04976                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] = numpts/frac;
<a name="l04977"></a>04977 
<a name="l04978"></a>04978                 <span class="comment">/* Points for the Z-shifted array */</span>
<a name="l04979"></a>04979                 frac = 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a7fdc5b25f586f50366157b8b264c315a">a3cf</a>[IJK(i,j,k)];
<a name="l04980"></a>04980                 frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i,j,k)];
<a name="l04981"></a>04981                 frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i,j,k)];
<a name="l04982"></a>04982                 numpts = 3;
<a name="l04983"></a>04983 
<a name="l04984"></a>04984                 <span class="keywordflow">if</span> (i &gt; 0) {
<a name="l04985"></a>04985                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i-1,j,k)];
<a name="l04986"></a>04986                     numpts += 1;
<a name="l04987"></a>04987                 }
<a name="l04988"></a>04988                 <span class="keywordflow">if</span> (j &gt; 0) {
<a name="l04989"></a>04989                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i,j-1,k)];
<a name="l04990"></a>04990                     numpts += 1;
<a name="l04991"></a>04991                 }
<a name="l04992"></a>04992                 <span class="keywordflow">if</span> (k &lt; (nz-1)){
<a name="l04993"></a>04993                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i,j,k+1)];
<a name="l04994"></a>04994                     frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i,j,k+1)];
<a name="l04995"></a>04995                     numpts += 2;
<a name="l04996"></a>04996                     <span class="keywordflow">if</span> (i &gt; 0) {
<a name="l04997"></a>04997                         frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a483426d5c54ed9224408eee1ca899a4b">a1cf</a>[IJK(i-1,j,k+1)];
<a name="l04998"></a>04998                         numpts += 1;
<a name="l04999"></a>04999                     }
<a name="l05000"></a>05000                     <span class="keywordflow">if</span> (j &gt; 0) {
<a name="l05001"></a>05001                         frac += 1.0/thee-&gt;<a class="code" href="structs_vpmg.html#a8a81cccea30792fc940eaa7df4f19fc4">a2cf</a>[IJK(i,j-1,k+1)];
<a name="l05002"></a>05002                         numpts += 1;
<a name="l05003"></a>05003                     }
<a name="l05004"></a>05004                 }
<a name="l05005"></a>05005                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] = numpts/frac;
<a name="l05006"></a>05006             }
<a name="l05007"></a>05007         }
<a name="l05008"></a>05008     }
<a name="l05009"></a>05009 }
<a name="l05010"></a>05010 
<a name="l05011"></a>05011 
<a name="l05012"></a><a class="code" href="vpmg_8h.html#a61365ff4cedaf084ea6d960d432a3d03">05012</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a61365ff4cedaf084ea6d960d432a3d03" title="Fill operator coefficient arrays from a spline-based surface calculation.">fillcoCoefSpline</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l05013"></a>05013 
<a name="l05014"></a>05014     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l05015"></a>05015     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05016"></a>05016     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l05017"></a>05017     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax, ionmask, ionstr, dist2;
<a name="l05018"></a>05018     <span class="keywordtype">double</span> xlen, ylen, zlen, position[3], itot, stot, ictot, ictot2, sctot;
<a name="l05019"></a>05019     <span class="keywordtype">double</span> irad, dx, dy, dz, epsw, epsp, w2i;
<a name="l05020"></a>05020     <span class="keywordtype">double</span> hx, hy, hzed, *apos, arad, sctot2;
<a name="l05021"></a>05021     <span class="keywordtype">double</span> dx2, dy2, dz2, stot2, itot2, rtot, rtot2, splineWin, w3i;
<a name="l05022"></a>05022     <span class="keywordtype">double</span> dist, value, sm, sm2;
<a name="l05023"></a>05023     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, iatom;
<a name="l05024"></a>05024     <span class="keywordtype">int</span> imin, imax, jmin, jmax, kmin, kmax;
<a name="l05025"></a>05025 
<a name="l05026"></a>05026     VASSERT(thee != VNULL);
<a name="l05027"></a>05027     splineWin = thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>;
<a name="l05028"></a>05028     w2i = 1.0/(splineWin*splineWin);
<a name="l05029"></a>05029     w3i = 1.0/(splineWin*splineWin*splineWin);
<a name="l05030"></a>05030 
<a name="l05031"></a>05031     <span class="comment">/* Get PBE info */</span>
<a name="l05032"></a>05032     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05033"></a>05033     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l05034"></a>05034     irad = <a class="code" href="group___vpbe.html#gabf77d3500a5e3b3c8673eab703bb53e0" title="Get maximum radius of ion species.">Vpbe_getMaxIonRadius</a>(pbe);
<a name="l05035"></a>05035     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(pbe);
<a name="l05036"></a>05036     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l05037"></a>05037     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l05038"></a>05038 
<a name="l05039"></a>05039     <span class="comment">/* Mesh info */</span>
<a name="l05040"></a>05040     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l05041"></a>05041     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l05042"></a>05042     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l05043"></a>05043     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l05044"></a>05044     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l05045"></a>05045     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l05046"></a>05046 
<a name="l05047"></a>05047     <span class="comment">/* Define the total domain size */</span>
<a name="l05048"></a>05048     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l05049"></a>05049     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l05050"></a>05050     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l05051"></a>05051 
<a name="l05052"></a>05052     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l05053"></a>05053     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l05054"></a>05054     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l05055"></a>05055     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l05056"></a>05056     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l05057"></a>05057     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l05058"></a>05058     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l05059"></a>05059 
<a name="l05060"></a>05060     <span class="comment">/* This is a floating point parameter related to the non-zero nature of the</span>
<a name="l05061"></a>05061 <span class="comment">     * bulk ionic strength.  If the ionic strength is greater than zero; this</span>
<a name="l05062"></a>05062 <span class="comment">     * parameter is set to 1.0 and later scaled by the appropriate pre-factors.</span>
<a name="l05063"></a>05063 <span class="comment">     * Otherwise, this parameter is set to 0.0 */</span>
<a name="l05064"></a>05064     <span class="keywordflow">if</span> (ionstr &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) ionmask = 1.0;
<a name="l05065"></a>05065     <span class="keywordflow">else</span> ionmask = 0.0;
<a name="l05066"></a>05066 
<a name="l05067"></a>05067     <span class="comment">/* Reset the kappa, epsx, epsy, and epsz arrays */</span>
<a name="l05068"></a>05068     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) {
<a name="l05069"></a>05069         thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] = 1.0;
<a name="l05070"></a>05070         thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i] = 1.0;
<a name="l05071"></a>05071         thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i] = 1.0;
<a name="l05072"></a>05072         thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i] = 1.0;
<a name="l05073"></a>05073     }
<a name="l05074"></a>05074 
<a name="l05075"></a>05075     <span class="comment">/* Loop through the atoms and do assign the dielectric */</span>
<a name="l05076"></a>05076     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l05077"></a>05077 
<a name="l05078"></a>05078         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l05079"></a>05079         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l05080"></a>05080         arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l05081"></a>05081 
<a name="l05082"></a>05082         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l05083"></a>05083         <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l05084"></a>05084             (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l05085"></a>05085             (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l05086"></a>05086             <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l05087"></a>05087                 (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l05088"></a>05088                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Atom #%d at (%4.3f, %4.3f,\</span>
<a name="l05089"></a>05089 <span class="stringliteral"> %4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l05090"></a>05090                   iatom, apos[0], apos[1], apos[2]);
<a name="l05091"></a>05091                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    xmin = %g, xmax = %g\n&quot;</span>,
<a name="l05092"></a>05092                   xmin, xmax);
<a name="l05093"></a>05093                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    ymin = %g, ymax = %g\n&quot;</span>,
<a name="l05094"></a>05094                   ymin, ymax);
<a name="l05095"></a>05095                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    zmin = %g, zmax = %g\n&quot;</span>,
<a name="l05096"></a>05096                   zmin, zmax);
<a name="l05097"></a>05097             }
<a name="l05098"></a>05098             fflush(stderr);
<a name="l05099"></a>05099 
<a name="l05100"></a>05100         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arad &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a> ) { <span class="comment">/* if we&#39;re on the mesh */</span>
<a name="l05101"></a>05101 
<a name="l05102"></a>05102             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l05103"></a>05103             position[0] = apos[0] - xmin;
<a name="l05104"></a>05104             position[1] = apos[1] - ymin;
<a name="l05105"></a>05105             position[2] = apos[2] - zmin;
<a name="l05106"></a>05106 
<a name="l05107"></a>05107             <span class="comment">/* MARK ION ACCESSIBILITY AND DIELECTRIC VALUES FOR LATER</span>
<a name="l05108"></a>05108 <span class="comment">             * ASSIGNMENT (Steps #1-3) */</span>
<a name="l05109"></a>05109             itot = irad + arad + splineWin;
<a name="l05110"></a>05110             itot2 = VSQR(itot);
<a name="l05111"></a>05111             ictot = VMAX2(0, (irad + arad - splineWin));
<a name="l05112"></a>05112             ictot2 = VSQR(ictot);
<a name="l05113"></a>05113             stot = arad + splineWin;
<a name="l05114"></a>05114             stot2 = VSQR(stot);
<a name="l05115"></a>05115             sctot = VMAX2(0, (arad - splineWin));
<a name="l05116"></a>05116             sctot2 = VSQR(sctot);
<a name="l05117"></a>05117 
<a name="l05118"></a>05118            <span class="comment">/* We&#39;ll search over grid points which are in the greater of</span>
<a name="l05119"></a>05119 <span class="comment">             * these two radii */</span>
<a name="l05120"></a>05120             rtot = VMAX2(itot, stot);
<a name="l05121"></a>05121             rtot2 = VMAX2(itot2, stot2);
<a name="l05122"></a>05122             dx = rtot + 0.5*hx;
<a name="l05123"></a>05123             dy = rtot + 0.5*hy;
<a name="l05124"></a>05124             dz = rtot + 0.5*hzed;
<a name="l05125"></a>05125             imin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[0] - dx)/hx));
<a name="l05126"></a>05126             imax = VMIN2(nx-1,(<span class="keywordtype">int</span>)ceil((position[0] + dx)/hx));
<a name="l05127"></a>05127             jmin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[1] - dy)/hy));
<a name="l05128"></a>05128             jmax = VMIN2(ny-1,(<span class="keywordtype">int</span>)ceil((position[1] + dy)/hy));
<a name="l05129"></a>05129             kmin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[2] - dz)/hzed));
<a name="l05130"></a>05130             kmax = VMIN2(nz-1,(<span class="keywordtype">int</span>)ceil((position[2] + dz)/hzed));
<a name="l05131"></a>05131             <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l05132"></a>05132                 dx2 = VSQR(position[0] - hx*i);
<a name="l05133"></a>05133                 <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l05134"></a>05134                     dy2 = VSQR(position[1] - hy*j);
<a name="l05135"></a>05135                     <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l05136"></a>05136                         dz2 = VSQR(position[2] - k*hzed);
<a name="l05137"></a>05137 
<a name="l05138"></a>05138                         <span class="comment">/* ASSIGN CCF */</span>
<a name="l05139"></a>05139                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l05140"></a>05140                             dist2 = dz2 + dy2 + dx2;
<a name="l05141"></a>05141                             <span class="keywordflow">if</span> (dist2 &gt;= itot2) {
<a name="l05142"></a>05142                                 ;
<a name="l05143"></a>05143                             }
<a name="l05144"></a>05144                             <span class="keywordflow">if</span> (dist2 &lt;= ictot2) {
<a name="l05145"></a>05145                                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] = 0.0;
<a name="l05146"></a>05146                             }
<a name="l05147"></a>05147                             <span class="keywordflow">if</span> ((dist2 &lt; itot2) &amp;&amp; (dist2 &gt; ictot2)) {
<a name="l05148"></a>05148                                 dist = VSQRT(dist2);
<a name="l05149"></a>05149                                 sm = dist - (arad + irad) + splineWin;
<a name="l05150"></a>05150                                 sm2 = VSQR(sm);
<a name="l05151"></a>05151                                 value = 0.75*sm2*w2i - 0.25*sm*sm2*w3i;
<a name="l05152"></a>05152                                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] *= value;
<a name="l05153"></a>05153                             }
<a name="l05154"></a>05154                         }
<a name="l05155"></a>05155 
<a name="l05156"></a>05156                         <span class="comment">/* ASSIGN A1CF */</span>
<a name="l05157"></a>05157                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l05158"></a>05158                             dist2 = dz2+dy2+VSQR(position[0]-(i+0.5)*hx);
<a name="l05159"></a>05159                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l05160"></a>05160                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] *= 1.0;
<a name="l05161"></a>05161                             }
<a name="l05162"></a>05162                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l05163"></a>05163                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] = 0.0;
<a name="l05164"></a>05164                             }
<a name="l05165"></a>05165                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l05166"></a>05166                                 dist = VSQRT(dist2);
<a name="l05167"></a>05167                                 sm = dist - arad + splineWin;
<a name="l05168"></a>05168                                 sm2 = VSQR(sm);
<a name="l05169"></a>05169                                 value = 0.75*sm2*w2i - 0.25*sm*sm2*w3i;
<a name="l05170"></a>05170                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] *= value;
<a name="l05171"></a>05171                             }
<a name="l05172"></a>05172                         }
<a name="l05173"></a>05173 
<a name="l05174"></a>05174                         <span class="comment">/* ASSIGN A2CF */</span>
<a name="l05175"></a>05175                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l05176"></a>05176                             dist2 = dz2+dx2+VSQR(position[1]-(j+0.5)*hy);
<a name="l05177"></a>05177                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l05178"></a>05178                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] *= 1.0;
<a name="l05179"></a>05179                             }
<a name="l05180"></a>05180                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l05181"></a>05181                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] = 0.0;
<a name="l05182"></a>05182                             }
<a name="l05183"></a>05183                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l05184"></a>05184                                 dist = VSQRT(dist2);
<a name="l05185"></a>05185                                 sm = dist - arad + splineWin;
<a name="l05186"></a>05186                                 sm2 = VSQR(sm);
<a name="l05187"></a>05187                                 value = 0.75*sm2*w2i - 0.25*sm*sm2*w3i;
<a name="l05188"></a>05188                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] *= value;
<a name="l05189"></a>05189                             }
<a name="l05190"></a>05190                         }
<a name="l05191"></a>05191 
<a name="l05192"></a>05192                         <span class="comment">/* ASSIGN A3CF */</span>
<a name="l05193"></a>05193                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l05194"></a>05194                             dist2 = dy2+dx2+VSQR(position[2]-(k+0.5)*hzed);
<a name="l05195"></a>05195                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l05196"></a>05196                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] *= 1.0;
<a name="l05197"></a>05197                             }
<a name="l05198"></a>05198                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l05199"></a>05199                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] = 0.0;
<a name="l05200"></a>05200                             }
<a name="l05201"></a>05201                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l05202"></a>05202                                 dist = VSQRT(dist2);
<a name="l05203"></a>05203                                 sm = dist - arad + splineWin;
<a name="l05204"></a>05204                                 sm2 = VSQR(sm);
<a name="l05205"></a>05205                                 value = 0.75*sm2*w2i - 0.25*sm*sm2*w3i;
<a name="l05206"></a>05206                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] *= value;
<a name="l05207"></a>05207                             }
<a name="l05208"></a>05208                         }
<a name="l05209"></a>05209 
<a name="l05210"></a>05210 
<a name="l05211"></a>05211                     } <span class="comment">/* k loop */</span>
<a name="l05212"></a>05212                 } <span class="comment">/* j loop */</span>
<a name="l05213"></a>05213             } <span class="comment">/* i loop */</span>
<a name="l05214"></a>05214         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l05215"></a>05215     } <span class="comment">/* endfor (over all atoms) */</span>
<a name="l05216"></a>05216 
<a name="l05217"></a>05217     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling coefficient arrays\n&quot;</span>);
<a name="l05218"></a>05218     <span class="comment">/* Interpret markings and fill the coefficient arrays */</span>
<a name="l05219"></a>05219     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l05220"></a>05220         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l05221"></a>05221             <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l05222"></a>05222 
<a name="l05223"></a>05223                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] = ionmask*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)];
<a name="l05224"></a>05224                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)]
<a name="l05225"></a>05225                   + epsp;
<a name="l05226"></a>05226                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)]
<a name="l05227"></a>05227                   + epsp;
<a name="l05228"></a>05228                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)]
<a name="l05229"></a>05229                   + epsp;
<a name="l05230"></a>05230 
<a name="l05231"></a>05231             } <span class="comment">/* i loop */</span>
<a name="l05232"></a>05232         } <span class="comment">/* j loop */</span>
<a name="l05233"></a>05233     } <span class="comment">/* k loop */</span>
<a name="l05234"></a>05234 
<a name="l05235"></a>05235 }
<a name="l05236"></a>05236 
<a name="l05237"></a><a class="code" href="vpmg_8h.html#a169088d2631112390e9699d0ff25ab0a">05237</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a169088d2631112390e9699d0ff25ab0a" title="Top-level driver to fill all operator coefficient arrays.">fillcoCoef</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l05238"></a>05238 
<a name="l05239"></a>05239     VASSERT(thee != VNULL);
<a name="l05240"></a>05240 
<a name="l05241"></a>05241     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#aabc9813d7bb766c5361e421db6efabb2">useDielXMap</a> || thee-&gt;<a class="code" href="structs_vpmg.html#a96d6eb86ab769d22e762da608c518190">useDielYMap</a> ||
<a name="l05242"></a>05242         thee-&gt;<a class="code" href="structs_vpmg.html#a1735e6924b92c76dc0b4eb3f2501ee33">useDielZMap</a> || thee-&gt;<a class="code" href="structs_vpmg.html#ad5f2fc675c0c6d12488dc6d02e599ade">useKappaMap</a>) {
<a name="l05243"></a>05243         <a class="code" href="vpmg_8c.html#a35949511a7f2779c8ac7e7c88bdca001" title="Fill operator coefficient arrays from pre-calculated maps.">fillcoCoefMap</a>(thee);
<a name="l05244"></a>05244         <span class="keywordflow">return</span>;
<a name="l05245"></a>05245     }
<a name="l05246"></a>05246 
<a name="l05247"></a>05247     <span class="keywordflow">switch</span>(thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>) {
<a name="l05248"></a>05248         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8ab44cc705c6ce062d10225d2a85988d4d">VSM_MOL</a>:
<a name="l05249"></a>05249             Vnm_print(0, <span class="stringliteral">&quot;fillcoCoef:  Calling fillcoCoefMol...\n&quot;</span>);
<a name="l05250"></a>05250             <a class="code" href="vpmg_8c.html#a62617829770eaed11c159947453e457c" title="Fill operator coefficient arrays from a molecular surface calculation.">fillcoCoefMol</a>(thee);
<a name="l05251"></a>05251             <span class="keywordflow">break</span>;
<a name="l05252"></a>05252         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8a5a9c3bd0f3896b676ca0e5c77bd7792a">VSM_MOLSMOOTH</a>:
<a name="l05253"></a>05253             Vnm_print(0, <span class="stringliteral">&quot;fillcoCoef:  Calling fillcoCoefMol...\n&quot;</span>);
<a name="l05254"></a>05254             <a class="code" href="vpmg_8c.html#a62617829770eaed11c159947453e457c" title="Fill operator coefficient arrays from a molecular surface calculation.">fillcoCoefMol</a>(thee);
<a name="l05255"></a>05255             <span class="keywordflow">break</span>;
<a name="l05256"></a>05256         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8abf8efa6fb4b60ce37f33598a7fd4d8e0">VSM_SPLINE</a>:
<a name="l05257"></a>05257             Vnm_print(0, <span class="stringliteral">&quot;fillcoCoef:  Calling fillcoCoefSpline...\n&quot;</span>);
<a name="l05258"></a>05258             <a class="code" href="vpmg_8c.html#a61365ff4cedaf084ea6d960d432a3d03" title="Fill operator coefficient arrays from a spline-based surface calculation.">fillcoCoefSpline</a>(thee);
<a name="l05259"></a>05259             <span class="keywordflow">break</span>;
<a name="l05260"></a>05260         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8a03532041240be6ec5531304c179cf921">VSM_SPLINE3</a>:
<a name="l05261"></a>05261             Vnm_print(0, <span class="stringliteral">&quot;fillcoCoef:  Calling fillcoCoefSpline3...\n&quot;</span>);
<a name="l05262"></a>05262             <a class="code" href="vpmg_8c.html#ab7b5543b591c9433e7190a2fe45b4ca2" title="Fill operator coefficient arrays from a 5th order polynomial based surface calculation.">fillcoCoefSpline3</a>(thee);
<a name="l05263"></a>05263             <span class="keywordflow">break</span>;
<a name="l05264"></a>05264         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8ab38c84c490653dab4a075d30cfb2c955">VSM_SPLINE4</a>:
<a name="l05265"></a>05265             Vnm_print(0, <span class="stringliteral">&quot;fillcoCoef:  Calling fillcoCoefSpline4...\n&quot;</span>);
<a name="l05266"></a>05266             <a class="code" href="vpmg_8c.html#abe8b2056b56093552215f2e97c8f5c1b" title="Fill operator coefficient arrays from a 7th order polynomial based surface calculation.">fillcoCoefSpline4</a>(thee);
<a name="l05267"></a>05267             <span class="keywordflow">break</span>;
<a name="l05268"></a>05268         <span class="keywordflow">default</span>:
<a name="l05269"></a>05269             Vnm_print(2, <span class="stringliteral">&quot;fillcoCoef:  Invalid surfMeth (%d)!\n&quot;</span>,
<a name="l05270"></a>05270               thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>);
<a name="l05271"></a>05271             VASSERT(0);
<a name="l05272"></a>05272             <span class="keywordflow">break</span>;
<a name="l05273"></a>05273     }
<a name="l05274"></a>05274 }
<a name="l05275"></a>05275 
<a name="l05276"></a>05276 
<a name="l05277"></a><a class="code" href="vpmg_8h.html#ada65af06c9af5bf4ee593cb051bd0b0d">05277</a> VPRIVATE Vrc_Codes <a class="code" href="vpmg_8c.html#ada65af06c9af5bf4ee593cb051bd0b0d" title="Top-level driver to fill source term charge array.">fillcoCharge</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l05278"></a>05278 
<a name="l05279"></a>05279     Vrc_Codes rc;
<a name="l05280"></a>05280 
<a name="l05281"></a>05281     VASSERT(thee != VNULL);
<a name="l05282"></a>05282 
<a name="l05283"></a>05283     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a3e7c8b5aba81f00256dc7f302ed73722">useChargeMap</a>) {
<a name="l05284"></a>05284         <span class="keywordflow">return</span> <a class="code" href="vpmg_8c.html#a2fe0074cd016170f829d76a856409185" title="Fill source term charge array from a pre-calculated map.">fillcoChargeMap</a>(thee);
<a name="l05285"></a>05285     }
<a name="l05286"></a>05286 
<a name="l05287"></a>05287     <span class="keywordflow">switch</span>(thee-&gt;<a class="code" href="structs_vpmg.html#a6327432ac9805931a52cd96505836c35">chargeMeth</a>) {
<a name="l05288"></a>05288         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga3008c37bfa581864fd3dd8a61f10aa1caec4ace101ce9fb196f683f2f0b49f288">VCM_TRIL</a>:
<a name="l05289"></a>05289             Vnm_print(0, <span class="stringliteral">&quot;fillcoCharge:  Calling fillcoChargeSpline1...\n&quot;</span>);
<a name="l05290"></a>05290             <a class="code" href="vpmg_8c.html#a7e7a2991c9f8b5e9a4a06843aecd38ae" title="Fill source term charge array from linear interpolation.">fillcoChargeSpline1</a>(thee);
<a name="l05291"></a>05291             <span class="keywordflow">break</span>;
<a name="l05292"></a>05292         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga3008c37bfa581864fd3dd8a61f10aa1cacd947c58b709cba6c3df8f56785db184">VCM_BSPL2</a>:
<a name="l05293"></a>05293             Vnm_print(0, <span class="stringliteral">&quot;fillcoCharge:  Calling fillcoChargeSpline2...\n&quot;</span>);
<a name="l05294"></a>05294             <a class="code" href="vpmg_8c.html#a6074122271a6957f5d463aa95c90f61c" title="Fill source term charge array from cubic spline interpolation.">fillcoChargeSpline2</a>(thee);
<a name="l05295"></a>05295             <span class="keywordflow">break</span>;
<a name="l05296"></a>05296         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga3008c37bfa581864fd3dd8a61f10aa1caf886afdc9765c36571359ce9d2764ca1">VCM_BSPL4</a>:
<a name="l05297"></a>05297             <span class="keywordflow">switch</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a311ed24e465040d2095273159d497995">chargeSrc</a>) {
<a name="l05298"></a>05298                 <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4daf34ddd788f7709bb1093266ae397826d">VCM_CHARGE</a>:
<a name="l05299"></a>05299                     Vnm_print(0, <span class="stringliteral">&quot;fillcoCharge: Calling fillcoPermanentMultipole...\n&quot;</span>);
<a name="l05300"></a>05300                     <a class="code" href="vpmg_8c.html#a45c2c05ddfc0c4e4aea3be668137d2e0" title="Fill source term charge array for the use of permanent multipoles.">fillcoPermanentMultipole</a>(thee);
<a name="l05301"></a>05301                     <span class="keywordflow">break</span>;
<a name="l05302"></a>05302 <span class="preprocessor">#if defined(WITH_TINKER)</span>
<a name="l05303"></a>05303 <span class="preprocessor"></span>                <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4dac6801535dedee5a72c8a91f5872731aa">VCM_PERMANENT</a>:
<a name="l05304"></a>05304                     Vnm_print(0, <span class="stringliteral">&quot;fillcoCharge: Calling fillcoPermanentMultipole...\n&quot;</span>);
<a name="l05305"></a>05305                     <a class="code" href="vpmg_8c.html#a45c2c05ddfc0c4e4aea3be668137d2e0" title="Fill source term charge array for the use of permanent multipoles.">fillcoPermanentMultipole</a>(thee);
<a name="l05306"></a>05306                     <span class="keywordflow">break</span>;
<a name="l05307"></a>05307                 <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da92d27a9c40417842c09da484ab798a03">VCM_INDUCED</a>:
<a name="l05308"></a>05308                     Vnm_print(0, <span class="stringliteral">&quot;fillcoCharge: Calling fillcoInducedDipole...\n&quot;</span>);
<a name="l05309"></a>05309                     <a class="code" href="vpmg_8h.html#ae84de46101d6abe2046ae860b55832a0" title="Fill source term charge array for use of induced dipoles.">fillcoInducedDipole</a>(thee);
<a name="l05310"></a>05310                     <span class="keywordflow">break</span>;
<a name="l05311"></a>05311                 <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga9fc03397fccaca6f6ce707e27285ea4da0380d67590db2e7662a896e98521dcbf">VCM_NLINDUCED</a>:
<a name="l05312"></a>05312                      Vnm_print(0, <span class="stringliteral">&quot;fillcoCharge: Calling fillcoNLInducedDipole...\n&quot;</span>);
<a name="l05313"></a>05313                      <a class="code" href="vpmg_8h.html#a6139befcbac10d86518d7b4cd397204a" title="Fill source term charge array for non-local induced dipoles.">fillcoNLInducedDipole</a>(thee);
<a name="l05314"></a>05314                      <span class="keywordflow">break</span>;
<a name="l05315"></a>05315 <span class="preprocessor">#endif </span><span class="comment">/* if defined(WITH_TINKER) */</span>
<a name="l05316"></a>05316                 <span class="keywordflow">default</span>:
<a name="l05317"></a>05317                     Vnm_print(2, <span class="stringliteral">&quot;fillcoCharge:  Invalid chargeSource (%d)!\n&quot;</span>,
<a name="l05318"></a>05318                       thee-&gt;<a class="code" href="structs_vpmg.html#a311ed24e465040d2095273159d497995">chargeSrc</a>);
<a name="l05319"></a>05319                     <span class="keywordflow">return</span> <a class="code" href="group___vhal.html#ggaa18adbb8b2cef7de47c9ea728305dc2ea4641379f5cf8dfdb82a2f0b45f60ce86">VRC_FAILURE</a>;
<a name="l05320"></a>05320                     <span class="keywordflow">break</span>;
<a name="l05321"></a>05321             }
<a name="l05322"></a>05322             <span class="keywordflow">break</span>;
<a name="l05323"></a>05323         <span class="keywordflow">default</span>:
<a name="l05324"></a>05324             Vnm_print(2, <span class="stringliteral">&quot;fillcoCharge:  Invalid chargeMeth (%d)!\n&quot;</span>,
<a name="l05325"></a>05325               thee-&gt;<a class="code" href="structs_vpmg.html#a6327432ac9805931a52cd96505836c35">chargeMeth</a>);
<a name="l05326"></a>05326             <span class="keywordflow">return</span> <a class="code" href="group___vhal.html#ggaa18adbb8b2cef7de47c9ea728305dc2ea4641379f5cf8dfdb82a2f0b45f60ce86">VRC_FAILURE</a>;
<a name="l05327"></a>05327             <span class="keywordflow">break</span>;
<a name="l05328"></a>05328     }
<a name="l05329"></a>05329 
<a name="l05330"></a>05330     <span class="keywordflow">return</span> <a class="code" href="group___vhal.html#ggaa18adbb8b2cef7de47c9ea728305dc2ea6a7a2e28e502cbde61b4cfb7e56fac81">VRC_SUCCESS</a>;
<a name="l05331"></a>05331 }
<a name="l05332"></a>05332 
<a name="l05333"></a><a class="code" href="vpmg_8h.html#a2fe0074cd016170f829d76a856409185">05333</a> VPRIVATE Vrc_Codes <a class="code" href="vpmg_8c.html#a2fe0074cd016170f829d76a856409185" title="Fill source term charge array from a pre-calculated map.">fillcoChargeMap</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l05334"></a>05334 
<a name="l05335"></a>05335     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05336"></a>05336     <span class="keywordtype">double</span> position[3], charge, zmagic, hx, hy, hzed;
<a name="l05337"></a>05337     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, rc;
<a name="l05338"></a>05338 
<a name="l05339"></a>05339 
<a name="l05340"></a>05340     VASSERT(thee != VNULL);
<a name="l05341"></a>05341 
<a name="l05342"></a>05342     <span class="comment">/* Get PBE info */</span>
<a name="l05343"></a>05343     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05344"></a>05344     zmagic = <a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l05345"></a>05345 
<a name="l05346"></a>05346     <span class="comment">/* Mesh info */</span>
<a name="l05347"></a>05347     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l05348"></a>05348     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l05349"></a>05349     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l05350"></a>05350     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l05351"></a>05351     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l05352"></a>05352     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l05353"></a>05353 
<a name="l05354"></a>05354     <span class="comment">/* Reset the charge array */</span>
<a name="l05355"></a>05355     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[i] = 0.0;
<a name="l05356"></a>05356 
<a name="l05357"></a>05357     <span class="comment">/* Fill in the source term (atomic charges) */</span>
<a name="l05358"></a>05358     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling in source term.\n&quot;</span>);
<a name="l05359"></a>05359     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l05360"></a>05360         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l05361"></a>05361             <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l05362"></a>05362                 position[0] = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[i];
<a name="l05363"></a>05363                 position[1] = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[j];
<a name="l05364"></a>05364                 position[2] = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[k];
<a name="l05365"></a>05365                 rc = <a class="code" href="group___vgrid.html#gae96a803dbd3016673affbc3d10310150" title="Get potential value (from mesh or approximation) at a point.">Vgrid_value</a>(thee-&gt;<a class="code" href="structs_vpmg.html#afdf99718d7e4332dad5481f18952e9da">chargeMap</a>, position, &amp;charge);
<a name="l05366"></a>05366                 <span class="keywordflow">if</span> (!rc) {
<a name="l05367"></a>05367                     Vnm_print(2, <span class="stringliteral">&quot;fillcoChargeMap:  Error -- fell off of charge map at (%g, %g, %g)!\n&quot;</span>,
<a name="l05368"></a>05368                           position[0], position[1], position[2]);
<a name="l05369"></a>05369                     <span class="keywordflow">return</span> <a class="code" href="group___vhal.html#ggaa18adbb8b2cef7de47c9ea728305dc2ea4641379f5cf8dfdb82a2f0b45f60ce86">VRC_FAILURE</a>;
<a name="l05370"></a>05370                 }
<a name="l05371"></a>05371                 <span class="comment">/* Scale the charge to internal units */</span>
<a name="l05372"></a>05372                 charge = charge*zmagic;
<a name="l05373"></a>05373                 thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(i,j,k)] = charge;
<a name="l05374"></a>05374             }
<a name="l05375"></a>05375         }
<a name="l05376"></a>05376     }
<a name="l05377"></a>05377 
<a name="l05378"></a>05378     <span class="keywordflow">return</span> <a class="code" href="group___vhal.html#ggaa18adbb8b2cef7de47c9ea728305dc2ea6a7a2e28e502cbde61b4cfb7e56fac81">VRC_SUCCESS</a>;
<a name="l05379"></a>05379 }
<a name="l05380"></a>05380 
<a name="l05381"></a><a class="code" href="vpmg_8h.html#a7e7a2991c9f8b5e9a4a06843aecd38ae">05381</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a7e7a2991c9f8b5e9a4a06843aecd38ae" title="Fill source term charge array from linear interpolation.">fillcoChargeSpline1</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l05382"></a>05382 
<a name="l05383"></a>05383     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l05384"></a>05384     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05385"></a>05385     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l05386"></a>05386     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax;
<a name="l05387"></a>05387     <span class="keywordtype">double</span> xlen, ylen, zlen, position[3], ifloat, jfloat, kfloat;
<a name="l05388"></a>05388     <span class="keywordtype">double</span> charge, dx, dy, dz, zmagic, hx, hy, hzed, *apos;
<a name="l05389"></a>05389     <span class="keywordtype">int</span> i, nx, ny, nz, iatom, ihi, ilo, jhi, jlo, khi, klo;
<a name="l05390"></a>05390 
<a name="l05391"></a>05391 
<a name="l05392"></a>05392     VASSERT(thee != VNULL);
<a name="l05393"></a>05393 
<a name="l05394"></a>05394     <span class="comment">/* Get PBE info */</span>
<a name="l05395"></a>05395     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05396"></a>05396     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l05397"></a>05397     zmagic = <a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l05398"></a>05398 
<a name="l05399"></a>05399     <span class="comment">/* Mesh info */</span>
<a name="l05400"></a>05400     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l05401"></a>05401     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l05402"></a>05402     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l05403"></a>05403     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l05404"></a>05404     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l05405"></a>05405     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l05406"></a>05406 
<a name="l05407"></a>05407     <span class="comment">/* Define the total domain size */</span>
<a name="l05408"></a>05408     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l05409"></a>05409     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l05410"></a>05410     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l05411"></a>05411 
<a name="l05412"></a>05412     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l05413"></a>05413     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l05414"></a>05414     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l05415"></a>05415     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l05416"></a>05416     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l05417"></a>05417     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l05418"></a>05418     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l05419"></a>05419 
<a name="l05420"></a>05420     <span class="comment">/* Reset the charge array */</span>
<a name="l05421"></a>05421     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[i] = 0.0;
<a name="l05422"></a>05422 
<a name="l05423"></a>05423     <span class="comment">/* Fill in the source term (atomic charges) */</span>
<a name="l05424"></a>05424     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling in source term.\n&quot;</span>);
<a name="l05425"></a>05425     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l05426"></a>05426 
<a name="l05427"></a>05427         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l05428"></a>05428         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l05429"></a>05429         charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l05430"></a>05430 
<a name="l05431"></a>05431         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l05432"></a>05432         <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l05433"></a>05433             (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l05434"></a>05434             (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l05435"></a>05435             <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l05436"></a>05436                 (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l05437"></a>05437                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Atom #%d at (%4.3f, %4.3f, \</span>
<a name="l05438"></a>05438 <span class="stringliteral">%4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l05439"></a>05439                   iatom, apos[0], apos[1], apos[2]);
<a name="l05440"></a>05440                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    xmin = %g, xmax = %g\n&quot;</span>,
<a name="l05441"></a>05441                   xmin, xmax);
<a name="l05442"></a>05442                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    ymin = %g, ymax = %g\n&quot;</span>,
<a name="l05443"></a>05443                   ymin, ymax);
<a name="l05444"></a>05444                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    zmin = %g, zmax = %g\n&quot;</span>,
<a name="l05445"></a>05445                   zmin, zmax);
<a name="l05446"></a>05446             }
<a name="l05447"></a>05447             fflush(stderr);
<a name="l05448"></a>05448         } <span class="keywordflow">else</span> {
<a name="l05449"></a>05449 
<a name="l05450"></a>05450             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l05451"></a>05451             position[0] = apos[0] - xmin;
<a name="l05452"></a>05452             position[1] = apos[1] - ymin;
<a name="l05453"></a>05453             position[2] = apos[2] - zmin;
<a name="l05454"></a>05454 
<a name="l05455"></a>05455             <span class="comment">/* Scale the charge to be a delta function */</span>
<a name="l05456"></a>05456             charge = charge*zmagic/(hx*hy*hzed);
<a name="l05457"></a>05457 
<a name="l05458"></a>05458             <span class="comment">/* Figure out which vertices we&#39;re next to */</span>
<a name="l05459"></a>05459             ifloat = position[0]/hx;
<a name="l05460"></a>05460             jfloat = position[1]/hy;
<a name="l05461"></a>05461             kfloat = position[2]/hzed;
<a name="l05462"></a>05462 
<a name="l05463"></a>05463             ihi = (int)ceil(ifloat);
<a name="l05464"></a>05464             ilo = (int)floor(ifloat);
<a name="l05465"></a>05465             jhi = (int)ceil(jfloat);
<a name="l05466"></a>05466             jlo = (int)floor(jfloat);
<a name="l05467"></a>05467             khi = (int)ceil(kfloat);
<a name="l05468"></a>05468             klo = (int)floor(kfloat);
<a name="l05469"></a>05469 
<a name="l05470"></a>05470             <span class="comment">/* Now assign fractions of the charge to the nearby verts */</span>
<a name="l05471"></a>05471             dx = ifloat - (double)(ilo);
<a name="l05472"></a>05472             dy = jfloat - (double)(jlo);
<a name="l05473"></a>05473             dz = kfloat - (double)(klo);
<a name="l05474"></a>05474             thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ihi,jhi,khi)] += (dx*dy*dz*charge);
<a name="l05475"></a>05475             thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ihi,jlo,khi)] += (dx*(1.0-dy)*dz*charge);
<a name="l05476"></a>05476             thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ihi,jhi,klo)] += (dx*dy*(1.0-dz)*charge);
<a name="l05477"></a>05477             thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ihi,jlo,klo)] += (dx*(1.0-dy)*(1.0-dz)*charge);
<a name="l05478"></a>05478             thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ilo,jhi,khi)] += ((1.0-dx)*dy*dz *charge);
<a name="l05479"></a>05479             thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ilo,jlo,khi)] += ((1.0-dx)*(1.0-dy)*dz *charge);
<a name="l05480"></a>05480             thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ilo,jhi,klo)] += ((1.0-dx)*dy*(1.0-dz)*charge);
<a name="l05481"></a>05481             thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ilo,jlo,klo)] += ((1.0-dx)*(1.0-dy)*(1.0-dz)*charge);
<a name="l05482"></a>05482         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l05483"></a>05483     } <span class="comment">/* endfor (each atom) */</span>
<a name="l05484"></a>05484 }
<a name="l05485"></a>05485 
<a name="l05486"></a><a class="code" href="vpmg_8h.html#a50d8ef438d4a7a76d869fb256b24d372">05486</a> VPRIVATE <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#a50d8ef438d4a7a76d869fb256b24d372" title="Evaluate a cubic B-spline.">bspline2</a>(<span class="keywordtype">double</span> x) {
<a name="l05487"></a>05487 
<a name="l05488"></a>05488     <span class="keywordtype">double</span> m2m, m2, m3;
<a name="l05489"></a>05489 
<a name="l05490"></a>05490     <span class="keywordflow">if</span> ((x &gt;= 0.0) &amp;&amp; (x &lt;= 2.0)) m2m = 1.0 - VABS(x - 1.0);
<a name="l05491"></a>05491     <span class="keywordflow">else</span> m2m = 0.0;
<a name="l05492"></a>05492     <span class="keywordflow">if</span> ((x &gt;= 1.0) &amp;&amp; (x &lt;= 3.0)) m2 = 1.0 - VABS(x - 2.0);
<a name="l05493"></a>05493     <span class="keywordflow">else</span> m2 = 0.0;
<a name="l05494"></a>05494 
<a name="l05495"></a>05495     <span class="keywordflow">if</span> ((x &gt;= 0.0) &amp;&amp; (x &lt;= 3.0)) m3 = 0.5*x*m2m + 0.5*(3.0-x)*m2;
<a name="l05496"></a>05496     <span class="keywordflow">else</span> m3 = 0.0;
<a name="l05497"></a>05497 
<a name="l05498"></a>05498     <span class="keywordflow">return</span> m3;
<a name="l05499"></a>05499 
<a name="l05500"></a>05500 }
<a name="l05501"></a>05501 
<a name="l05502"></a><a class="code" href="vpmg_8h.html#a8a4a959a2448c20bfc3660f04077892e">05502</a> VPRIVATE <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#a8a4a959a2448c20bfc3660f04077892e" title="Evaluate a cubic B-spline derivative.">dbspline2</a>(<span class="keywordtype">double</span> x) {
<a name="l05503"></a>05503 
<a name="l05504"></a>05504     <span class="keywordtype">double</span> m2m, m2, dm3;
<a name="l05505"></a>05505 
<a name="l05506"></a>05506     <span class="keywordflow">if</span> ((x &gt;= 0.0) &amp;&amp; (x &lt;= 2.0)) m2m = 1.0 - VABS(x - 1.0);
<a name="l05507"></a>05507     <span class="keywordflow">else</span> m2m = 0.0;
<a name="l05508"></a>05508     <span class="keywordflow">if</span> ((x &gt;= 1.0) &amp;&amp; (x &lt;= 3.0)) m2 = 1.0 - VABS(x - 2.0);
<a name="l05509"></a>05509     <span class="keywordflow">else</span> m2 = 0.0;
<a name="l05510"></a>05510 
<a name="l05511"></a>05511     dm3 = m2m - m2;
<a name="l05512"></a>05512 
<a name="l05513"></a>05513     <span class="keywordflow">return</span> dm3;
<a name="l05514"></a>05514 
<a name="l05515"></a>05515 }
<a name="l05516"></a>05516 
<a name="l05517"></a>05517 
<a name="l05518"></a><a class="code" href="vpmg_8h.html#a6074122271a6957f5d463aa95c90f61c">05518</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a6074122271a6957f5d463aa95c90f61c" title="Fill source term charge array from cubic spline interpolation.">fillcoChargeSpline2</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l05519"></a>05519 
<a name="l05520"></a>05520     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l05521"></a>05521     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05522"></a>05522     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l05523"></a>05523     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax, zmagic;
<a name="l05524"></a>05524     <span class="keywordtype">double</span> xlen, ylen, zlen, position[3], ifloat, jfloat, kfloat;
<a name="l05525"></a>05525     <span class="keywordtype">double</span> charge, hx, hy, hzed, *apos, mx, my, mz;
<a name="l05526"></a>05526     <span class="keywordtype">int</span> i, ii, jj, kk, nx, ny, nz, iatom;
<a name="l05527"></a>05527     <span class="keywordtype">int</span> im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1, kp1, kp2;
<a name="l05528"></a>05528 
<a name="l05529"></a>05529 
<a name="l05530"></a>05530     VASSERT(thee != VNULL);
<a name="l05531"></a>05531 
<a name="l05532"></a>05532     <span class="comment">/* Get PBE info */</span>
<a name="l05533"></a>05533     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05534"></a>05534     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l05535"></a>05535     zmagic = <a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l05536"></a>05536 
<a name="l05537"></a>05537     <span class="comment">/* Mesh info */</span>
<a name="l05538"></a>05538     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l05539"></a>05539     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l05540"></a>05540     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l05541"></a>05541     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l05542"></a>05542     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l05543"></a>05543     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l05544"></a>05544 
<a name="l05545"></a>05545     <span class="comment">/* Define the total domain size */</span>
<a name="l05546"></a>05546     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l05547"></a>05547     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l05548"></a>05548     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l05549"></a>05549 
<a name="l05550"></a>05550     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l05551"></a>05551     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l05552"></a>05552     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l05553"></a>05553     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l05554"></a>05554     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l05555"></a>05555     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l05556"></a>05556     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l05557"></a>05557 
<a name="l05558"></a>05558     <span class="comment">/* Reset the charge array */</span>
<a name="l05559"></a>05559     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[i] = 0.0;
<a name="l05560"></a>05560 
<a name="l05561"></a>05561     <span class="comment">/* Fill in the source term (atomic charges) */</span>
<a name="l05562"></a>05562     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling in source term.\n&quot;</span>);
<a name="l05563"></a>05563     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l05564"></a>05564 
<a name="l05565"></a>05565         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l05566"></a>05566         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l05567"></a>05567         charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l05568"></a>05568 
<a name="l05569"></a>05569         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l05570"></a>05570         <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin-hx)) || (apos[0]&gt;=(xmax+hx))  || \
<a name="l05571"></a>05571             (apos[1]&lt;=(ymin-hy)) || (apos[1]&gt;=(ymax+hy))  || \
<a name="l05572"></a>05572             (apos[2]&lt;=(zmin-hzed)) || (apos[2]&gt;=(zmax+hzed))) {
<a name="l05573"></a>05573             <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l05574"></a>05574                 (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l05575"></a>05575                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Atom #%d at (%4.3f, %4.3f, \</span>
<a name="l05576"></a>05576 <span class="stringliteral">%4.3f) is off the mesh (for cubic splines!!) (ignoring this atom):\n&quot;</span>,
<a name="l05577"></a>05577                   iatom, apos[0], apos[1], apos[2]);
<a name="l05578"></a>05578                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    xmin = %g, xmax = %g\n&quot;</span>,
<a name="l05579"></a>05579                   xmin, xmax);
<a name="l05580"></a>05580                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    ymin = %g, ymax = %g\n&quot;</span>,
<a name="l05581"></a>05581                   ymin, ymax);
<a name="l05582"></a>05582                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    zmin = %g, zmax = %g\n&quot;</span>,
<a name="l05583"></a>05583                   zmin, zmax);
<a name="l05584"></a>05584             }
<a name="l05585"></a>05585             fflush(stderr);
<a name="l05586"></a>05586         } <span class="keywordflow">else</span> {
<a name="l05587"></a>05587 
<a name="l05588"></a>05588             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l05589"></a>05589             position[0] = apos[0] - xmin;
<a name="l05590"></a>05590             position[1] = apos[1] - ymin;
<a name="l05591"></a>05591             position[2] = apos[2] - zmin;
<a name="l05592"></a>05592 
<a name="l05593"></a>05593             <span class="comment">/* Scale the charge to be a delta function */</span>
<a name="l05594"></a>05594             charge = charge*zmagic/(hx*hy*hzed);
<a name="l05595"></a>05595 
<a name="l05596"></a>05596             <span class="comment">/* Figure out which vertices we&#39;re next to */</span>
<a name="l05597"></a>05597             ifloat = position[0]/hx;
<a name="l05598"></a>05598             jfloat = position[1]/hy;
<a name="l05599"></a>05599             kfloat = position[2]/hzed;
<a name="l05600"></a>05600 
<a name="l05601"></a>05601             ip1   = (int)ceil(ifloat);
<a name="l05602"></a>05602             ip2   = ip1 + 1;
<a name="l05603"></a>05603             im1   = (int)floor(ifloat);
<a name="l05604"></a>05604             im2   = im1 - 1;
<a name="l05605"></a>05605             jp1   = (int)ceil(jfloat);
<a name="l05606"></a>05606             jp2   = jp1 + 1;
<a name="l05607"></a>05607             jm1   = (int)floor(jfloat);
<a name="l05608"></a>05608             jm2   = jm1 - 1;
<a name="l05609"></a>05609             kp1   = (int)ceil(kfloat);
<a name="l05610"></a>05610             kp2   = kp1 + 1;
<a name="l05611"></a>05611             km1   = (int)floor(kfloat);
<a name="l05612"></a>05612             km2   = km1 - 1;
<a name="l05613"></a>05613 
<a name="l05614"></a>05614             <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l05615"></a>05615 <span class="comment">             * later on if something goes wrong */</span>
<a name="l05616"></a>05616             ip2 = VMIN2(ip2,nx-1);
<a name="l05617"></a>05617             ip1 = VMIN2(ip1,nx-1);
<a name="l05618"></a>05618             im1 = VMAX2(im1,0);
<a name="l05619"></a>05619             im2 = VMAX2(im2,0);
<a name="l05620"></a>05620             jp2 = VMIN2(jp2,ny-1);
<a name="l05621"></a>05621             jp1 = VMIN2(jp1,ny-1);
<a name="l05622"></a>05622             jm1 = VMAX2(jm1,0);
<a name="l05623"></a>05623             jm2 = VMAX2(jm2,0);
<a name="l05624"></a>05624             kp2 = VMIN2(kp2,nz-1);
<a name="l05625"></a>05625             kp1 = VMIN2(kp1,nz-1);
<a name="l05626"></a>05626             km1 = VMAX2(km1,0);
<a name="l05627"></a>05627             km2 = VMAX2(km2,0);
<a name="l05628"></a>05628 
<a name="l05629"></a>05629             <span class="comment">/* Now assign fractions of the charge to the nearby verts */</span>
<a name="l05630"></a>05630             <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l05631"></a>05631                 mx = <a class="code" href="vpmg_8c.html#a50d8ef438d4a7a76d869fb256b24d372" title="Evaluate a cubic B-spline.">bspline2</a>(VFCHI(ii,ifloat));
<a name="l05632"></a>05632                 <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l05633"></a>05633                     my = <a class="code" href="vpmg_8c.html#a50d8ef438d4a7a76d869fb256b24d372" title="Evaluate a cubic B-spline.">bspline2</a>(VFCHI(jj,jfloat));
<a name="l05634"></a>05634                     <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l05635"></a>05635                         mz = <a class="code" href="vpmg_8c.html#a50d8ef438d4a7a76d869fb256b24d372" title="Evaluate a cubic B-spline.">bspline2</a>(VFCHI(kk,kfloat));
<a name="l05636"></a>05636                         thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ii,jj,kk)] += (charge*mx*my*mz);
<a name="l05637"></a>05637                     }
<a name="l05638"></a>05638                 }
<a name="l05639"></a>05639             }
<a name="l05640"></a>05640 
<a name="l05641"></a>05641         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l05642"></a>05642     } <span class="comment">/* endfor (each atom) */</span>
<a name="l05643"></a>05643 }
<a name="l05644"></a>05644 
<a name="l05645"></a><a class="code" href="group___vpmg.html#gaf117af16d5e9c5bd4e557a69ec1eb73a">05645</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#gaf117af16d5e9c5bd4e557a69ec1eb73a" title="Fill the coefficient arrays prior to solving the equation.">Vpmg_fillco</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l05646"></a>05646                         <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> surfMeth,
<a name="l05647"></a>05647                         <span class="keywordtype">double</span> splineWin,
<a name="l05648"></a>05648                         <a class="code" href="group___vhal.html#gadd887856f01d4328b9a028110a5488a6" title="Declaration of the Vchrg_Meth type as the Vchrg_Meth enum.">Vchrg_Meth</a> chargeMeth,
<a name="l05649"></a>05649                         <span class="keywordtype">int</span> useDielXMap,
<a name="l05650"></a>05650                         <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *dielXMap,
<a name="l05651"></a>05651                         <span class="keywordtype">int</span> useDielYMap,
<a name="l05652"></a>05652                         <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *dielYMap,
<a name="l05653"></a>05653                         <span class="keywordtype">int</span> useDielZMap,
<a name="l05654"></a>05654                         <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *dielZMap,
<a name="l05655"></a>05655                         <span class="keywordtype">int</span> useKappaMap,
<a name="l05656"></a>05656                         <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *kappaMap,
<a name="l05657"></a>05657                         <span class="keywordtype">int</span> usePotMap,
<a name="l05658"></a>05658                         <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *potMap,
<a name="l05659"></a>05659                         <span class="keywordtype">int</span> useChargeMap,
<a name="l05660"></a>05660                         <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *chargeMap
<a name="l05661"></a>05661                        ) {
<a name="l05662"></a>05662 
<a name="l05663"></a>05663     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05664"></a>05664     <span class="keywordtype">double</span> xmin,
<a name="l05665"></a>05665            xmax,
<a name="l05666"></a>05666            ymin,
<a name="l05667"></a>05667            ymax,
<a name="l05668"></a>05668            zmin,
<a name="l05669"></a>05669            zmax,
<a name="l05670"></a>05670            xlen,
<a name="l05671"></a>05671            ylen,
<a name="l05672"></a>05672            zlen,
<a name="l05673"></a>05673            hx,
<a name="l05674"></a>05674            hy,
<a name="l05675"></a>05675            hzed,
<a name="l05676"></a>05676            epsw,
<a name="l05677"></a>05677            epsp,
<a name="l05678"></a>05678            ionstr;
<a name="l05679"></a>05679     <span class="keywordtype">int</span> i,
<a name="l05680"></a>05680         nx,
<a name="l05681"></a>05681         ny,
<a name="l05682"></a>05682         nz,
<a name="l05683"></a>05683         islap;
<a name="l05684"></a>05684     Vrc_Codes rc;
<a name="l05685"></a>05685 
<a name="l05686"></a>05686     <span class="keywordflow">if</span> (thee == VNULL) {
<a name="l05687"></a>05687         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  got NULL thee!\n&quot;</span>);
<a name="l05688"></a>05688         <span class="keywordflow">return</span> 0;
<a name="l05689"></a>05689     }
<a name="l05690"></a>05690 
<a name="l05691"></a>05691     thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a> = surfMeth;
<a name="l05692"></a>05692     thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a> = splineWin;
<a name="l05693"></a>05693     thee-&gt;<a class="code" href="structs_vpmg.html#a6327432ac9805931a52cd96505836c35">chargeMeth</a> = chargeMeth;
<a name="l05694"></a>05694     thee-&gt;<a class="code" href="structs_vpmg.html#aabc9813d7bb766c5361e421db6efabb2">useDielXMap</a> = useDielXMap;
<a name="l05695"></a>05695     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#aabc9813d7bb766c5361e421db6efabb2">useDielXMap</a>) thee-&gt;<a class="code" href="structs_vpmg.html#a38134d9a49656dcb9f368d07cd309668">dielXMap</a> = dielXMap;
<a name="l05696"></a>05696     thee-&gt;<a class="code" href="structs_vpmg.html#a96d6eb86ab769d22e762da608c518190">useDielYMap</a> = useDielYMap;
<a name="l05697"></a>05697     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a96d6eb86ab769d22e762da608c518190">useDielYMap</a>) thee-&gt;<a class="code" href="structs_vpmg.html#ac8831cd0b192d78a05b3ed38b1434137">dielYMap</a> = dielYMap;
<a name="l05698"></a>05698     thee-&gt;<a class="code" href="structs_vpmg.html#a1735e6924b92c76dc0b4eb3f2501ee33">useDielZMap</a> = useDielZMap;
<a name="l05699"></a>05699     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a1735e6924b92c76dc0b4eb3f2501ee33">useDielZMap</a>) thee-&gt;<a class="code" href="structs_vpmg.html#acb1fce9e3e8e32859a9aae06ceccb6f1">dielZMap</a> = dielZMap;
<a name="l05700"></a>05700     thee-&gt;<a class="code" href="structs_vpmg.html#ad5f2fc675c0c6d12488dc6d02e599ade">useKappaMap</a> = useKappaMap;
<a name="l05701"></a>05701     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ad5f2fc675c0c6d12488dc6d02e599ade">useKappaMap</a>) thee-&gt;<a class="code" href="structs_vpmg.html#aa3ffd50808f24b927e1828a3e2aacdd7">kappaMap</a> = kappaMap;
<a name="l05702"></a>05702     thee-&gt;<a class="code" href="structs_vpmg.html#a479180ef03324b15ca9b83f11fff70c5">usePotMap</a> = usePotMap;
<a name="l05703"></a>05703     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a479180ef03324b15ca9b83f11fff70c5">usePotMap</a>) thee-&gt;<a class="code" href="structs_vpmg.html#a8eb003a0429de07f2f48a6c88c873d1f">potMap</a> = potMap;
<a name="l05704"></a>05704     thee-&gt;<a class="code" href="structs_vpmg.html#a3e7c8b5aba81f00256dc7f302ed73722">useChargeMap</a> = useChargeMap;
<a name="l05705"></a>05705     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a3e7c8b5aba81f00256dc7f302ed73722">useChargeMap</a>) thee-&gt;<a class="code" href="structs_vpmg.html#afdf99718d7e4332dad5481f18952e9da">chargeMap</a> = chargeMap;
<a name="l05706"></a>05706 
<a name="l05707"></a>05707     <span class="comment">/* Get PBE info */</span>
<a name="l05708"></a>05708     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05709"></a>05709     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(pbe);
<a name="l05710"></a>05710     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l05711"></a>05711     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l05712"></a>05712 
<a name="l05713"></a>05713     <span class="comment">/* Mesh info */</span>
<a name="l05714"></a>05714     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l05715"></a>05715     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l05716"></a>05716     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l05717"></a>05717     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l05718"></a>05718     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l05719"></a>05719     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l05720"></a>05720 
<a name="l05721"></a>05721     <span class="comment">/* Define the total domain size */</span>
<a name="l05722"></a>05722     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l05723"></a>05723     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l05724"></a>05724     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l05725"></a>05725 
<a name="l05726"></a>05726     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l05727"></a>05727     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l05728"></a>05728     thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a> = xmin;
<a name="l05729"></a>05729     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l05730"></a>05730     thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a> = ymin;
<a name="l05731"></a>05731     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l05732"></a>05732     thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a> = zmin;
<a name="l05733"></a>05733     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l05734"></a>05734     thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a> = xmax;
<a name="l05735"></a>05735     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l05736"></a>05736     thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a> = ymax;
<a name="l05737"></a>05737     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l05738"></a>05738     thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a> = zmax;
<a name="l05739"></a>05739     thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>[2] = xmin;
<a name="l05740"></a>05740     thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>[3] = xmax;
<a name="l05741"></a>05741     thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>[4] = ymin;
<a name="l05742"></a>05742     thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>[5] = ymax;
<a name="l05743"></a>05743     thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>[6] = zmin;
<a name="l05744"></a>05744     thee-&gt;<a class="code" href="structs_vpmg.html#a00cb02d8b9719e9574fc04283450b6be">rparm</a>[7] = zmax;
<a name="l05745"></a>05745 
<a name="l05746"></a>05746     <span class="comment">/* This is a flag that gets set if the operator is a simple Laplacian;</span>
<a name="l05747"></a>05747 <span class="comment">     * i.e., in the case of a homogenous dielectric and zero ionic strength</span>
<a name="l05748"></a>05748 <span class="comment">     * The operator cannot be a simple Laplacian if maps are read in. */</span>
<a name="l05749"></a>05749     <span class="keywordflow">if</span>(thee-&gt;<a class="code" href="structs_vpmg.html#aabc9813d7bb766c5361e421db6efabb2">useDielXMap</a> || thee-&gt;<a class="code" href="structs_vpmg.html#a96d6eb86ab769d22e762da608c518190">useDielYMap</a> || thee-&gt;<a class="code" href="structs_vpmg.html#a1735e6924b92c76dc0b4eb3f2501ee33">useDielZMap</a> ||
<a name="l05750"></a>05750        thee-&gt;<a class="code" href="structs_vpmg.html#ad5f2fc675c0c6d12488dc6d02e599ade">useKappaMap</a> || thee-&gt;<a class="code" href="structs_vpmg.html#a479180ef03324b15ca9b83f11fff70c5">usePotMap</a>){
<a name="l05751"></a>05751         islap = 0;
<a name="l05752"></a>05752     }<span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (ionstr &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp; (VABS(epsp-epsw) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) ){
<a name="l05753"></a>05753         islap = 1;
<a name="l05754"></a>05754     }<span class="keywordflow">else</span>{
<a name="l05755"></a>05755         islap = 0;
<a name="l05756"></a>05756     }
<a name="l05757"></a>05757 
<a name="l05758"></a>05758     <span class="comment">/* Fill the mesh point coordinate arrays */</span>
<a name="l05759"></a>05759     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[i] = xmin + i*hx;
<a name="l05760"></a>05760     for (i=0; i&lt;ny; i++) thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[i] = ymin + i*hy;
<a name="l05761"></a>05761     for (i=0; i&lt;nz; i++) thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[i] = zmin + i*hzed;
<a name="l05762"></a>05762 
<a name="l05763"></a>05763     <span class="comment">/* Reset the tcf array */</span>
<a name="l05764"></a>05764     for (i=0; i&lt;(nx*ny*nz); i++) thee-&gt;<a class="code" href="structs_vpmg.html#a4340bbd780d87a004aa32f56db41e63c">tcf</a>[i] = 0.0;
<a name="l05765"></a>05765 
<a name="l05766"></a>05766     <span class="comment">/* Fill in the source term (atomic charges) */</span>
<a name="l05767"></a>05767     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling in source term.\n&quot;</span>);
<a name="l05768"></a>05768     rc = <a class="code" href="vpmg_8c.html#ada65af06c9af5bf4ee593cb051bd0b0d" title="Top-level driver to fill source term charge array.">fillcoCharge</a>(thee);
<a name="l05769"></a>05769     <span class="keywordflow">switch</span>(rc) {
<a name="l05770"></a>05770         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#ggaa18adbb8b2cef7de47c9ea728305dc2ea6a7a2e28e502cbde61b4cfb7e56fac81">VRC_SUCCESS</a>:
<a name="l05771"></a>05771             <span class="keywordflow">break</span>;
<a name="l05772"></a>05772         <span class="keywordflow">case</span> VRC_WARNING:
<a name="l05773"></a>05773             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  non-fatal errors while filling charge map!\n&quot;</span>);
<a name="l05774"></a>05774             <span class="keywordflow">break</span>;
<a name="l05775"></a>05775         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#ggaa18adbb8b2cef7de47c9ea728305dc2ea4641379f5cf8dfdb82a2f0b45f60ce86">VRC_FAILURE</a>:
<a name="l05776"></a>05776             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  fatal errors while filling charge map!\n&quot;</span>);
<a name="l05777"></a>05777             <span class="keywordflow">return</span> 0;
<a name="l05778"></a>05778             <span class="keywordflow">break</span>;
<a name="l05779"></a>05779     }
<a name="l05780"></a>05780 
<a name="l05781"></a>05781     <span class="comment">/* THE FOLLOWING NEEDS TO BE DONE IF WE&#39;RE NOT USING A SIMPLE LAPLACIAN</span>
<a name="l05782"></a>05782 <span class="comment">     * OPERATOR */</span>
<a name="l05783"></a>05783     <span class="keywordflow">if</span> (!islap) {
<a name="l05784"></a>05784         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  marking ion and solvent accessibility.\n&quot;</span>);
<a name="l05785"></a>05785         <a class="code" href="vpmg_8c.html#a169088d2631112390e9699d0ff25ab0a" title="Top-level driver to fill all operator coefficient arrays.">fillcoCoef</a>(thee);
<a name="l05786"></a>05786         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  done filling coefficient arrays\n&quot;</span>);
<a name="l05787"></a>05787 
<a name="l05788"></a>05788     } <span class="keywordflow">else</span> { <span class="comment">/* else (!islap) ==&gt; It&#39;s a Laplacian operator! */</span>
<a name="l05789"></a>05789 
<a name="l05790"></a>05790         <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) {
<a name="l05791"></a>05791             thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] = 0.0;
<a name="l05792"></a>05792             thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i] = epsp;
<a name="l05793"></a>05793             thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i] = epsp;
<a name="l05794"></a>05794             thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i] = epsp;
<a name="l05795"></a>05795         }
<a name="l05796"></a>05796 
<a name="l05797"></a>05797     } <span class="comment">/* endif (!islap) */</span>
<a name="l05798"></a>05798 
<a name="l05799"></a>05799     <span class="comment">/* Fill the boundary arrays (except when focusing, bcfl = 4) */</span>
<a name="l05800"></a>05800     <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) {
<a name="l05801"></a>05801         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling boundary arrays\n&quot;</span>);
<a name="l05802"></a>05802         <a class="code" href="vpmg_8c.html#a9803b64d96685d27923d899ef6f4c5cd" title="Fill boundary condition arrays.">bcCalc</a>(thee);
<a name="l05803"></a>05803         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  done filling boundary arrays\n&quot;</span>);
<a name="l05804"></a>05804     }
<a name="l05805"></a>05805 
<a name="l05806"></a>05806     thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a> = 1;
<a name="l05807"></a>05807 
<a name="l05808"></a>05808     <span class="keywordflow">return</span> 1;
<a name="l05809"></a>05809 }
<a name="l05810"></a>05810 
<a name="l05811"></a>05811 
<a name="l05812"></a><a class="code" href="group___vpmg.html#gaaedec4be6966e3cee14a0a746ade406c">05812</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#gaaedec4be6966e3cee14a0a746ade406c" title="Calculate the total force on the specified atom in units of k_B T/AA.">Vpmg_force</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> *force, <span class="keywordtype">int</span> atomID,
<a name="l05813"></a>05813   <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm, <a class="code" href="group___vhal.html#gadd887856f01d4328b9a028110a5488a6" title="Declaration of the Vchrg_Meth type as the Vchrg_Meth enum.">Vchrg_Meth</a> chgm) {
<a name="l05814"></a>05814 
<a name="l05815"></a>05815     <span class="keywordtype">int</span> rc = 1;
<a name="l05816"></a>05816     <span class="keywordtype">double</span> qfF[3];                  <span class="comment">/* Charge-field force */</span>
<a name="l05817"></a>05817     <span class="keywordtype">double</span> dbF[3];                  <span class="comment">/* Dielectric boundary force */</span>
<a name="l05818"></a>05818     <span class="keywordtype">double</span> ibF[3];                  <span class="comment">/* Ion boundary force */</span>
<a name="l05819"></a>05819     <span class="keywordtype">double</span> npF[3];                  <span class="comment">/* Non-polar boundary force */</span>
<a name="l05820"></a>05820 
<a name="l05821"></a>05821     VASSERT(thee != VNULL);
<a name="l05822"></a>05822 
<a name="l05823"></a>05823     rc = rc &amp;&amp; <a class="code" href="group___vpmg.html#gae681cc5a764ed8b8f9f869c047af997b" title="Calculate the dielectric boundary forces on the specified atom in units of k_B T/AA.">Vpmg_dbForce</a>(thee, qfF, atomID, srfm);
<a name="l05824"></a>05824     rc = rc &amp;&amp; <a class="code" href="group___vpmg.html#ga140aea8dc31832d40a7cfb638464ee67" title="Calculate the osmotic pressure on the specified atom in units of k_B T/AA.">Vpmg_ibForce</a>(thee, dbF, atomID, srfm);
<a name="l05825"></a>05825     rc = rc &amp;&amp; <a class="code" href="group___vpmg.html#gaf3bc9840c1d9ab92eddbfd5f798ae0b6" title="Calculate the &quot;charge-field&quot; force on the specified atom in units of k_B T/AA.">Vpmg_qfForce</a>(thee, ibF, atomID, chgm);
<a name="l05826"></a>05826 
<a name="l05827"></a>05827     force[0] = qfF[0] + dbF[0] + ibF[0];
<a name="l05828"></a>05828     force[1] = qfF[1] + dbF[1] + ibF[1];
<a name="l05829"></a>05829     force[2] = qfF[2] + dbF[2] + ibF[2];
<a name="l05830"></a>05830 
<a name="l05831"></a>05831     <span class="keywordflow">return</span> rc;
<a name="l05832"></a>05832 
<a name="l05833"></a>05833 }
<a name="l05834"></a>05834 
<a name="l05835"></a><a class="code" href="group___vpmg.html#ga140aea8dc31832d40a7cfb638464ee67">05835</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#ga140aea8dc31832d40a7cfb638464ee67" title="Calculate the osmotic pressure on the specified atom in units of k_B T/AA.">Vpmg_ibForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> *force, <span class="keywordtype">int</span> atomID,
<a name="l05836"></a>05836   <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm) {
<a name="l05837"></a>05837 
<a name="l05838"></a>05838     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l05839"></a>05839     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l05840"></a>05840     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05841"></a>05841     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l05842"></a>05842 
<a name="l05843"></a>05843     <span class="keywordtype">double</span> *apos, position[3], arad, irad, zkappa2, hx, hy, hzed;
<a name="l05844"></a>05844     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax, rtot2;
<a name="l05845"></a>05845     <span class="keywordtype">double</span> rtot, dx, dx2, dy, dy2, dz, dz2, gpos[3], tgrad[3], fmag;
<a name="l05846"></a>05846     <span class="keywordtype">double</span> izmagic;
<a name="l05847"></a>05847     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, imin, imax, jmin, jmax, kmin, kmax;
<a name="l05848"></a>05848 
<a name="l05849"></a>05849     <span class="comment">/* For nonlinear forces */</span>
<a name="l05850"></a>05850     <span class="keywordtype">int</span> ichop, nchop, nion, m;
<a name="l05851"></a>05851     <span class="keywordtype">double</span> ionConc[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>], ionRadii[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>], ionQ[<a class="code" href="group___vhal.html#ga8ec2427efb460890f443d47e210d9b60" title="The maximum number of ion species that can be involved in a single PBE calculation.">MAXION</a>], ionstr;
<a name="l05852"></a>05852 
<a name="l05853"></a>05853     VASSERT(thee != VNULL);
<a name="l05854"></a>05854 
<a name="l05855"></a>05855     acc = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l05856"></a>05856     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l05857"></a>05857     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l05858"></a>05858     arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l05859"></a>05859 
<a name="l05860"></a>05860     <span class="comment">/* Reset force */</span>
<a name="l05861"></a>05861     force[0] = 0.0;
<a name="l05862"></a>05862     force[1] = 0.0;
<a name="l05863"></a>05863     force[2] = 0.0;
<a name="l05864"></a>05864 
<a name="l05865"></a>05865     <span class="comment">/* Check surface definition */</span>
<a name="l05866"></a>05866     <span class="keywordflow">if</span> ((srfm != <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8abf8efa6fb4b60ce37f33598a7fd4d8e0">VSM_SPLINE</a>) &amp;&amp; (srfm!=<a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8a03532041240be6ec5531304c179cf921">VSM_SPLINE3</a>) &amp;&amp; (srfm!=<a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8ab38c84c490653dab4a075d30cfb2c955">VSM_SPLINE4</a>)) {
<a name="l05867"></a>05867         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:  Forces *must* be calculated with \</span>
<a name="l05868"></a>05868 <span class="stringliteral">spline-based surfaces!\n&quot;</span>);
<a name="l05869"></a>05869         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:  Skipping ionic boundary force \</span>
<a name="l05870"></a>05870 <span class="stringliteral">calculation!\n&quot;</span>);
<a name="l05871"></a>05871         <span class="keywordflow">return</span> 0;
<a name="l05872"></a>05872     }
<a name="l05873"></a>05873 
<a name="l05874"></a>05874     <span class="comment">/* If we aren&#39;t in the current position, then we&#39;re done */</span>
<a name="l05875"></a>05875     <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> == 0) <span class="keywordflow">return</span> 1;
<a name="l05876"></a>05876 
<a name="l05877"></a>05877     <span class="comment">/* Get PBE info */</span>
<a name="l05878"></a>05878     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l05879"></a>05879     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l05880"></a>05880     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l05881"></a>05881     irad = <a class="code" href="group___vpbe.html#gabf77d3500a5e3b3c8673eab703bb53e0" title="Get maximum radius of ion species.">Vpbe_getMaxIonRadius</a>(pbe);
<a name="l05882"></a>05882     zkappa2 = <a class="code" href="group___vpbe.html#ga56e38face81d2d29659541b5e3f5e442" title="Get modified squared Debye-Huckel parameter.">Vpbe_getZkappa2</a>(pbe);
<a name="l05883"></a>05883     izmagic = 1.0/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l05884"></a>05884 
<a name="l05885"></a>05885     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(pbe);
<a name="l05886"></a>05886     <a class="code" href="group___vpbe.html#gae42c09bef7405779d87bce73c44e1ebf" title="Get information about the counterion species present.">Vpbe_getIons</a>(pbe, &amp;nion, ionConc, ionRadii, ionQ);
<a name="l05887"></a>05887 
<a name="l05888"></a>05888     <span class="comment">/* Mesh info */</span>
<a name="l05889"></a>05889     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l05890"></a>05890     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l05891"></a>05891     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l05892"></a>05892     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l05893"></a>05893     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l05894"></a>05894     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l05895"></a>05895     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l05896"></a>05896     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l05897"></a>05897     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l05898"></a>05898     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l05899"></a>05899     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l05900"></a>05900     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l05901"></a>05901     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l05902"></a>05902     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l05903"></a>05903     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l05904"></a>05904 
<a name="l05905"></a>05905     <span class="comment">/* Sanity check: there is no force if there is zero ionic strength */</span>
<a name="l05906"></a>05906     <span class="keywordflow">if</span> (zkappa2 &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l05907"></a>05907 <span class="preprocessor">#ifndef VAPBSQUIET</span>
<a name="l05908"></a>05908 <span class="preprocessor"></span>        Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:  No force for zero ionic strength!\n&quot;</span>);
<a name="l05909"></a>05909 <span class="preprocessor">#endif</span>
<a name="l05910"></a>05910 <span class="preprocessor"></span>        <span class="keywordflow">return</span> 1;
<a name="l05911"></a>05911     }
<a name="l05912"></a>05912 
<a name="l05913"></a>05913     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l05914"></a>05914     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l05915"></a>05915       (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l05916"></a>05916       (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l05917"></a>05917         <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l05918"></a>05918             (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l05919"></a>05919             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:  Atom #%d at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l05920"></a>05920                   atom, apos[0], apos[1], apos[2]);
<a name="l05921"></a>05921             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:    xmin = %g, xmax = %g\n&quot;</span>,
<a name="l05922"></a>05922               xmin, xmax);
<a name="l05923"></a>05923             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:    ymin = %g, ymax = %g\n&quot;</span>,
<a name="l05924"></a>05924               ymin, ymax);
<a name="l05925"></a>05925             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:    zmin = %g, zmax = %g\n&quot;</span>,
<a name="l05926"></a>05926               zmin, zmax);
<a name="l05927"></a>05927         }
<a name="l05928"></a>05928         fflush(stderr);
<a name="l05929"></a>05929     } <span class="keywordflow">else</span> {
<a name="l05930"></a>05930 
<a name="l05931"></a>05931         <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l05932"></a>05932         position[0] = apos[0] - xmin;
<a name="l05933"></a>05933         position[1] = apos[1] - ymin;
<a name="l05934"></a>05934         position[2] = apos[2] - zmin;
<a name="l05935"></a>05935 
<a name="l05936"></a>05936         <span class="comment">/* Integrate over points within this atom&#39;s (inflated) radius */</span>
<a name="l05937"></a>05937         rtot = (irad + arad + thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>);
<a name="l05938"></a>05938         rtot2 = VSQR(rtot);
<a name="l05939"></a>05939         dx = rtot + 0.5*hx;
<a name="l05940"></a>05940         imin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[0] - dx)/hx));
<a name="l05941"></a>05941         imax = VMIN2(nx-1,(<span class="keywordtype">int</span>)floor((position[0] + dx)/hx));
<a name="l05942"></a>05942         <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l05943"></a>05943             dx2 = VSQR(position[0] - hx*i);
<a name="l05944"></a>05944             <span class="keywordflow">if</span> (rtot2 &gt; dx2) dy = VSQRT(rtot2 - dx2) + 0.5*hy;
<a name="l05945"></a>05945             <span class="keywordflow">else</span> dy = 0.5*hy;
<a name="l05946"></a>05946             jmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[1] - dy)/hy));
<a name="l05947"></a>05947             jmax = VMIN2(ny-1,(<span class="keywordtype">int</span>)floor((position[1] + dy)/hy));
<a name="l05948"></a>05948             <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l05949"></a>05949                 dy2 = VSQR(position[1] - hy*j);
<a name="l05950"></a>05950                 <span class="keywordflow">if</span> (rtot2 &gt; (dx2+dy2)) dz = VSQRT(rtot2-dx2-dy2)+0.5*hzed;
<a name="l05951"></a>05951                 <span class="keywordflow">else</span> dz = 0.5*hzed;
<a name="l05952"></a>05952                 kmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[2] - dz)/hzed));
<a name="l05953"></a>05953                 kmax = VMIN2(nz-1,(<span class="keywordtype">int</span>)floor((position[2] + dz)/hzed));
<a name="l05954"></a>05954                 <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l05955"></a>05955                     dz2 = VSQR(k*hzed - position[2]);
<a name="l05956"></a>05956                     <span class="comment">/* See if grid point is inside ivdw radius and set kappa</span>
<a name="l05957"></a>05957 <span class="comment">                     * accordingly (do spline assignment here) */</span>
<a name="l05958"></a>05958                     <span class="keywordflow">if</span> ((dz2 + dy2 + dx2) &lt;= rtot2) {
<a name="l05959"></a>05959                         gpos[0] = i*hx + xmin;
<a name="l05960"></a>05960                         gpos[1] = j*hy + ymin;
<a name="l05961"></a>05961                         gpos[2] = k*hzed + zmin;
<a name="l05962"></a>05962 
<a name="l05963"></a>05963                         <span class="comment">/* Select the correct function based on the surface definition</span>
<a name="l05964"></a>05964 <span class="comment">                         * (now including the 7th order polynomial) */</span>
<a name="l05965"></a>05965                         <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm,acc, gpos,thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, irad, atom, tgrad);
<a name="l05966"></a>05966 
<a name="l05967"></a>05967                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>) {
<a name="l05968"></a>05968                             <span class="comment">/* Nonlinear forces */</span>
<a name="l05969"></a>05969                             fmag = 0.0;
<a name="l05970"></a>05970                             nchop = 0;
<a name="l05971"></a>05971                             <span class="keywordflow">for</span> (m=0; m&lt;nion; m++) {
<a name="l05972"></a>05972                                 fmag += (thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)])*ionConc[m]*(<a class="code" href="group___vcap.html#ga3af96d10891f3150377104c65689c6ec" title="Provide a capped exp() function.">Vcap_exp</a>(-ionQ[m]*thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)], &amp;ichop)-1.0)/ionstr;
<a name="l05973"></a>05973                                 nchop += ichop;
<a name="l05974"></a>05974                             }
<a name="l05975"></a>05975                             <span class="comment">/*          if (nchop &gt; 0) Vnm_print(2, &quot;Vpmg_ibForece:  Chopped EXP %d times!\n&quot;, nchop);*/</span>
<a name="l05976"></a>05976                             force[0] += (zkappa2*fmag*tgrad[0]);
<a name="l05977"></a>05977                             force[1] += (zkappa2*fmag*tgrad[1]);
<a name="l05978"></a>05978                             force[2] += (zkappa2*fmag*tgrad[2]);
<a name="l05979"></a>05979                         } <span class="keywordflow">else</span> {
<a name="l05980"></a>05980                             <span class="comment">/* Use of bulk factor (zkappa2) OK here becuase</span>
<a name="l05981"></a>05981 <span class="comment">                             * LPBE force approximation */</span>
<a name="l05982"></a>05982                             <span class="comment">/* NAB -- did we forget a kappa factor here??? */</span>
<a name="l05983"></a>05983                             fmag = VSQR(thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)])*(thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)]);
<a name="l05984"></a>05984                             force[0] += (zkappa2*fmag*tgrad[0]);
<a name="l05985"></a>05985                             force[1] += (zkappa2*fmag*tgrad[1]);
<a name="l05986"></a>05986                             force[2] += (zkappa2*fmag*tgrad[2]);
<a name="l05987"></a>05987                         }
<a name="l05988"></a>05988                     }
<a name="l05989"></a>05989                 } <span class="comment">/* k loop */</span>
<a name="l05990"></a>05990             } <span class="comment">/* j loop */</span>
<a name="l05991"></a>05991         } <span class="comment">/* i loop */</span>
<a name="l05992"></a>05992     }
<a name="l05993"></a>05993     force[0] = force[0] * 0.5 * hx * hy * hzed * izmagic;
<a name="l05994"></a>05994     force[1] = force[1] * 0.5 * hx * hy * hzed * izmagic;
<a name="l05995"></a>05995     force[2] = force[2] * 0.5 * hx * hy * hzed * izmagic;
<a name="l05996"></a>05996 
<a name="l05997"></a>05997     <span class="keywordflow">return</span> 1;
<a name="l05998"></a>05998 }
<a name="l05999"></a>05999 
<a name="l06000"></a><a class="code" href="group___vpmg.html#gae681cc5a764ed8b8f9f869c047af997b">06000</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#gae681cc5a764ed8b8f9f869c047af997b" title="Calculate the dielectric boundary forces on the specified atom in units of k_B T/AA.">Vpmg_dbForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> *dbForce, <span class="keywordtype">int</span> atomID,
<a name="l06001"></a>06001                          <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm) {
<a name="l06002"></a>06002 
<a name="l06003"></a>06003     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l06004"></a>06004     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l06005"></a>06005     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l06006"></a>06006 
<a name="l06007"></a>06007     <span class="keywordtype">double</span> *apos, position[3], arad, srad, hx, hy, hzed, izmagic, deps, depsi;
<a name="l06008"></a>06008     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax, rtot2, epsp;
<a name="l06009"></a>06009     <span class="keywordtype">double</span> rtot, dx, gpos[3], tgrad[3], dbFmag, epsw, kT;
<a name="l06010"></a>06010     <span class="keywordtype">double</span> *u, Hxijk, Hyijk, Hzijk, Hxim1jk, Hyijm1k, Hzijkm1;
<a name="l06011"></a>06011     <span class="keywordtype">double</span> dHxijk[3], dHyijk[3], dHzijk[3], dHxim1jk[3], dHyijm1k[3];
<a name="l06012"></a>06012     <span class="keywordtype">double</span> dHzijkm1[3];
<a name="l06013"></a>06013     <span class="keywordtype">int</span> i, j, k, l, nx, ny, nz, imin, imax, jmin, jmax, kmin, kmax;
<a name="l06014"></a>06014 
<a name="l06015"></a>06015     VASSERT(thee != VNULL);
<a name="l06016"></a>06016     <span class="keywordflow">if</span> (!thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>) {
<a name="l06017"></a>06017         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Need to callVpmg_fillco!\n&quot;</span>);
<a name="l06018"></a>06018         <span class="keywordflow">return</span> 0;
<a name="l06019"></a>06019     }
<a name="l06020"></a>06020 
<a name="l06021"></a>06021     acc = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l06022"></a>06022     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l06023"></a>06023     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l06024"></a>06024     arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l06025"></a>06025     srad = <a class="code" href="group___vpbe.html#ga87631b31eefd5639e45c43f972344f29" title="Get solvent molecule radius.">Vpbe_getSolventRadius</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l06026"></a>06026 
<a name="l06027"></a>06027     <span class="comment">/* Reset force */</span>
<a name="l06028"></a>06028     dbForce[0] = 0.0;
<a name="l06029"></a>06029     dbForce[1] = 0.0;
<a name="l06030"></a>06030     dbForce[2] = 0.0;
<a name="l06031"></a>06031 
<a name="l06032"></a>06032     <span class="comment">/* Check surface definition */</span>
<a name="l06033"></a>06033     <span class="keywordflow">if</span> ((srfm != <a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8abf8efa6fb4b60ce37f33598a7fd4d8e0">VSM_SPLINE</a>) &amp;&amp; (srfm!=<a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8a03532041240be6ec5531304c179cf921">VSM_SPLINE3</a>) &amp;&amp; (srfm!=<a class="code" href="group___vhal.html#gga068e237d419d537df01fc0fad01e24e8ab38c84c490653dab4a075d30cfb2c955">VSM_SPLINE4</a>)) {
<a name="l06034"></a>06034         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Forces *must* be calculated with \</span>
<a name="l06035"></a>06035 <span class="stringliteral">spline-based surfaces!\n&quot;</span>);
<a name="l06036"></a>06036         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Skipping dielectric/apolar boundary \</span>
<a name="l06037"></a>06037 <span class="stringliteral">force calculation!\n&quot;</span>);
<a name="l06038"></a>06038         <span class="keywordflow">return</span> 0;
<a name="l06039"></a>06039     }
<a name="l06040"></a>06040 
<a name="l06041"></a>06041 
<a name="l06042"></a>06042     <span class="comment">/* If we aren&#39;t in the current position, then we&#39;re done */</span>
<a name="l06043"></a>06043     <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> == 0) <span class="keywordflow">return</span> 1;
<a name="l06044"></a>06044 
<a name="l06045"></a>06045     <span class="comment">/* Get PBE info */</span>
<a name="l06046"></a>06046     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l06047"></a>06047     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l06048"></a>06048     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l06049"></a>06049     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l06050"></a>06050     kT = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe)*(1e-3)*<a class="code" href="group___vunit.html#gae194adb8dae1861b5d34d4fc9d2afc86" title="Avogadro&#39;s number.">Vunit_Na</a>*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>;
<a name="l06051"></a>06051     izmagic = 1.0/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l06052"></a>06052 
<a name="l06053"></a>06053     <span class="comment">/* Mesh info */</span>
<a name="l06054"></a>06054     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l06055"></a>06055     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l06056"></a>06056     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l06057"></a>06057     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l06058"></a>06058     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l06059"></a>06059     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l06060"></a>06060     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l06061"></a>06061     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l06062"></a>06062     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l06063"></a>06063     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l06064"></a>06064     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l06065"></a>06065     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l06066"></a>06066     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l06067"></a>06067     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l06068"></a>06068     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l06069"></a>06069     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l06070"></a>06070 
<a name="l06071"></a>06071     <span class="comment">/* Sanity check: there is no force if there is zero ionic strength */</span>
<a name="l06072"></a>06072     <span class="keywordflow">if</span> (VABS(epsp-epsw) &lt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l06073"></a>06073         Vnm_print(0, <span class="stringliteral">&quot;Vpmg_dbForce: No force for uniform dielectric!\n&quot;</span>);
<a name="l06074"></a>06074         <span class="keywordflow">return</span> 1;
<a name="l06075"></a>06075     }
<a name="l06076"></a>06076     deps = (epsw - epsp);
<a name="l06077"></a>06077     depsi = 1.0/deps;
<a name="l06078"></a>06078     rtot = (arad + thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a> + srad);
<a name="l06079"></a>06079 
<a name="l06080"></a>06080     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l06081"></a>06081     <span class="comment">/* Grid checking modified by Matteo Rotter */</span>
<a name="l06082"></a>06082     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin + rtot) || (apos[0]&gt;=xmax - rtot)  || \
<a name="l06083"></a>06083         (apos[1]&lt;=ymin + rtot) || (apos[1]&gt;=ymax - rtot)  || \
<a name="l06084"></a>06084         (apos[2]&lt;=zmin + rtot) || (apos[2]&gt;=zmax - rtot)) {
<a name="l06085"></a>06085         <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l06086"></a>06086             (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l06087"></a>06087             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Atom #%d at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l06088"></a>06088                       atomID, apos[0], apos[1], apos[2]);
<a name="l06089"></a>06089             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:    xmin = %g, xmax = %g\n&quot;</span>,
<a name="l06090"></a>06090                       xmin, xmax);
<a name="l06091"></a>06091             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:    ymin = %g, ymax = %g\n&quot;</span>,
<a name="l06092"></a>06092                       ymin, ymax);
<a name="l06093"></a>06093             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:    zmin = %g, zmax = %g\n&quot;</span>,
<a name="l06094"></a>06094                       zmin, zmax);
<a name="l06095"></a>06095         }
<a name="l06096"></a>06096         fflush(stderr);
<a name="l06097"></a>06097     } <span class="keywordflow">else</span> {
<a name="l06098"></a>06098 
<a name="l06099"></a>06099         <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l06100"></a>06100         position[0] = apos[0] - xmin;
<a name="l06101"></a>06101         position[1] = apos[1] - ymin;
<a name="l06102"></a>06102         position[2] = apos[2] - zmin;
<a name="l06103"></a>06103 
<a name="l06104"></a>06104         <span class="comment">/* Integrate over points within this atom&#39;s (inflated) radius */</span>
<a name="l06105"></a>06105         rtot2 = VSQR(rtot);
<a name="l06106"></a>06106         dx = rtot/hx;
<a name="l06107"></a>06107         imin = (int)floor((position[0]-rtot)/hx);
<a name="l06108"></a>06108         <span class="keywordflow">if</span> (imin &lt; 1) {
<a name="l06109"></a>06109             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l06110"></a>06110             <span class="keywordflow">return</span> 0;
<a name="l06111"></a>06111         }
<a name="l06112"></a>06112         imax = (int)ceil((position[0]+rtot)/hx);
<a name="l06113"></a>06113         <span class="keywordflow">if</span> (imax &gt; (nx-2)) {
<a name="l06114"></a>06114             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l06115"></a>06115             <span class="keywordflow">return</span> 0;
<a name="l06116"></a>06116         }
<a name="l06117"></a>06117         jmin = (int)floor((position[1]-rtot)/hy);
<a name="l06118"></a>06118         <span class="keywordflow">if</span> (jmin &lt; 1) {
<a name="l06119"></a>06119             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l06120"></a>06120             <span class="keywordflow">return</span> 0;
<a name="l06121"></a>06121         }
<a name="l06122"></a>06122         jmax = (int)ceil((position[1]+rtot)/hy);
<a name="l06123"></a>06123         <span class="keywordflow">if</span> (jmax &gt; (ny-2)) {
<a name="l06124"></a>06124             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l06125"></a>06125             <span class="keywordflow">return</span> 0;
<a name="l06126"></a>06126         }
<a name="l06127"></a>06127         kmin = (int)floor((position[2]-rtot)/hzed);
<a name="l06128"></a>06128         <span class="keywordflow">if</span> (kmin &lt; 1) {
<a name="l06129"></a>06129             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l06130"></a>06130             <span class="keywordflow">return</span> 0;
<a name="l06131"></a>06131         }
<a name="l06132"></a>06132         kmax = (int)ceil((position[2]+rtot)/hzed);
<a name="l06133"></a>06133         <span class="keywordflow">if</span> (kmax &gt; (nz-2)) {
<a name="l06134"></a>06134             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l06135"></a>06135             <span class="keywordflow">return</span> 0;
<a name="l06136"></a>06136         }
<a name="l06137"></a>06137         <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l06138"></a>06138             <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l06139"></a>06139                 <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l06140"></a>06140                     <span class="comment">/* i,j,k */</span>
<a name="l06141"></a>06141                     gpos[0] = (i+0.5)*hx + xmin;
<a name="l06142"></a>06142                     gpos[1] = j*hy + ymin;
<a name="l06143"></a>06143                     gpos[2] = k*hzed + zmin;
<a name="l06144"></a>06144                     Hxijk = (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l06145"></a>06145 
<a name="l06146"></a>06146                     <span class="comment">/* Select the correct function based on the surface definition</span>
<a name="l06147"></a>06147 <span class="comment">                        * (now including the 7th order polynomial) */</span>
<a name="l06148"></a>06148                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm,acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,atom, dHxijk);
<a name="l06149"></a>06149                     <span class="comment">/*</span>
<a name="l06150"></a>06150 <span class="comment">                     switch (srfm) {</span>
<a name="l06151"></a>06151 <span class="comment">                         case VSM_SPLINE :</span>
<a name="l06152"></a>06152 <span class="comment">                             Vacc_splineAccGradAtomNorm(acc, gpos, thee-&gt;splineWin, 0.,</span>
<a name="l06153"></a>06153 <span class="comment">                                                        atom, dHxijk);</span>
<a name="l06154"></a>06154 <span class="comment">                             break;</span>
<a name="l06155"></a>06155 <span class="comment">                         case VSM_SPLINE4 :</span>
<a name="l06156"></a>06156 <span class="comment">                             Vacc_splineAccGradAtomNorm4(acc, gpos, thee-&gt;splineWin, 0.,</span>
<a name="l06157"></a>06157 <span class="comment">                                                         atom, dHxijk);</span>
<a name="l06158"></a>06158 <span class="comment">                             break;</span>
<a name="l06159"></a>06159 <span class="comment">                         default:</span>
<a name="l06160"></a>06160 <span class="comment">                             Vnm_print(2, &quot;Vpmg_dbnbForce: Unknown surface method.\n&quot;);</span>
<a name="l06161"></a>06161 <span class="comment">                             return;</span>
<a name="l06162"></a>06162 <span class="comment">                     }</span>
<a name="l06163"></a>06163 <span class="comment">                     */</span>
<a name="l06164"></a>06164                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHxijk[l] *= Hxijk;
<a name="l06165"></a>06165                     gpos[0] = i*hx + xmin;
<a name="l06166"></a>06166                     gpos[1] = (j+0.5)*hy + ymin;
<a name="l06167"></a>06167                     gpos[2] = k*hzed + zmin;
<a name="l06168"></a>06168                     Hyijk = (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l06169"></a>06169 
<a name="l06170"></a>06170                     <span class="comment">/* Select the correct function based on the surface definition</span>
<a name="l06171"></a>06171 <span class="comment">                        * (now including the 7th order polynomial) */</span>
<a name="l06172"></a>06172                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm,acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,atom, dHyijk);
<a name="l06173"></a>06173 
<a name="l06174"></a>06174                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHyijk[l] *= Hyijk;
<a name="l06175"></a>06175                     gpos[0] = i*hx + xmin;
<a name="l06176"></a>06176                     gpos[1] = j*hy + ymin;
<a name="l06177"></a>06177                     gpos[2] = (k+0.5)*hzed + zmin;
<a name="l06178"></a>06178                     Hzijk = (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l06179"></a>06179 
<a name="l06180"></a>06180                     <span class="comment">/* Select the correct function based on the surface definition</span>
<a name="l06181"></a>06181 <span class="comment">                        * (now including the 7th order polynomial) */</span>
<a name="l06182"></a>06182                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm,acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,atom, dHzijk);
<a name="l06183"></a>06183 
<a name="l06184"></a>06184                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHzijk[l] *= Hzijk;
<a name="l06185"></a>06185                     <span class="comment">/* i-1,j,k */</span>
<a name="l06186"></a>06186                     gpos[0] = (i-0.5)*hx + xmin;
<a name="l06187"></a>06187                     gpos[1] = j*hy + ymin;
<a name="l06188"></a>06188                     gpos[2] = k*hzed + zmin;
<a name="l06189"></a>06189                     Hxim1jk = (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i-1,j,k)] - epsp)*depsi;
<a name="l06190"></a>06190 
<a name="l06191"></a>06191                     <span class="comment">/* Select the correct function based on the surface definition</span>
<a name="l06192"></a>06192 <span class="comment">                        * (now including the 7th order polynomial) */</span>
<a name="l06193"></a>06193                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm,acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,atom, dHxim1jk);
<a name="l06194"></a>06194 
<a name="l06195"></a>06195                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHxim1jk[l] *= Hxim1jk;
<a name="l06196"></a>06196                     <span class="comment">/* i,j-1,k */</span>
<a name="l06197"></a>06197                     gpos[0] = i*hx + xmin;
<a name="l06198"></a>06198                     gpos[1] = (j-0.5)*hy + ymin;
<a name="l06199"></a>06199                     gpos[2] = k*hzed + zmin;
<a name="l06200"></a>06200                     Hyijm1k = (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j-1,k)] - epsp)*depsi;
<a name="l06201"></a>06201 
<a name="l06202"></a>06202                     <span class="comment">/* Select the correct function based on the surface definition</span>
<a name="l06203"></a>06203 <span class="comment">                        * (now including the 7th order polynomial) */</span>
<a name="l06204"></a>06204                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm,acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,atom, dHyijm1k);
<a name="l06205"></a>06205 
<a name="l06206"></a>06206                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHyijm1k[l] *= Hyijm1k;
<a name="l06207"></a>06207                     <span class="comment">/* i,j,k-1 */</span>
<a name="l06208"></a>06208                     gpos[0] = i*hx + xmin;
<a name="l06209"></a>06209                     gpos[1] = j*hy + ymin;
<a name="l06210"></a>06210                     gpos[2] = (k-0.5)*hzed + zmin;
<a name="l06211"></a>06211                     Hzijkm1 = (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k-1)] - epsp)*depsi;
<a name="l06212"></a>06212 
<a name="l06213"></a>06213                     <span class="comment">/* Select the correct function based on the surface definition</span>
<a name="l06214"></a>06214 <span class="comment">                        * (now including the 7th order polynomial) */</span>
<a name="l06215"></a>06215                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm,acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,atom, dHzijkm1);
<a name="l06216"></a>06216 
<a name="l06217"></a>06217                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHzijkm1[l] *= Hzijkm1;
<a name="l06218"></a>06218                     <span class="comment">/* *** CALCULATE DIELECTRIC BOUNDARY FORCES *** */</span>
<a name="l06219"></a>06219                     dbFmag = u[IJK(i,j,k)];
<a name="l06220"></a>06220                     tgrad[0] =
<a name="l06221"></a>06221                         (dHxijk[0]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l06222"></a>06222                          +  dHxim1jk[0]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l06223"></a>06223                         + (dHyijk[0]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l06224"></a>06224                            +  dHyijm1k[0]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l06225"></a>06225                         + (dHzijk[0]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l06226"></a>06226                            + dHzijkm1[0]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l06227"></a>06227                     tgrad[1] =
<a name="l06228"></a>06228                         (dHxijk[1]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l06229"></a>06229                          +  dHxim1jk[1]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l06230"></a>06230                         + (dHyijk[1]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l06231"></a>06231                            +  dHyijm1k[1]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l06232"></a>06232                         + (dHzijk[1]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l06233"></a>06233                            + dHzijkm1[1]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l06234"></a>06234                     tgrad[2] =
<a name="l06235"></a>06235                         (dHxijk[2]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l06236"></a>06236                          +  dHxim1jk[2]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l06237"></a>06237                         + (dHyijk[2]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l06238"></a>06238                            +  dHyijm1k[2]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l06239"></a>06239                         + (dHzijk[2]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l06240"></a>06240                            + dHzijkm1[2]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l06241"></a>06241                     dbForce[0] += (dbFmag*tgrad[0]);
<a name="l06242"></a>06242                     dbForce[1] += (dbFmag*tgrad[1]);
<a name="l06243"></a>06243                     dbForce[2] += (dbFmag*tgrad[2]);
<a name="l06244"></a>06244 
<a name="l06245"></a>06245                 } <span class="comment">/* k loop */</span>
<a name="l06246"></a>06246             } <span class="comment">/* j loop */</span>
<a name="l06247"></a>06247         } <span class="comment">/* i loop */</span>
<a name="l06248"></a>06248 
<a name="l06249"></a>06249         dbForce[0] = -dbForce[0]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l06250"></a>06250         dbForce[1] = -dbForce[1]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l06251"></a>06251         dbForce[2] = -dbForce[2]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l06252"></a>06252     }
<a name="l06253"></a>06253 
<a name="l06254"></a>06254     <span class="keywordflow">return</span> 1;
<a name="l06255"></a>06255 }
<a name="l06256"></a>06256 
<a name="l06257"></a><a class="code" href="group___vpmg.html#gaf3bc9840c1d9ab92eddbfd5f798ae0b6">06257</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#gaf3bc9840c1d9ab92eddbfd5f798ae0b6" title="Calculate the &quot;charge-field&quot; force on the specified atom in units of k_B T/AA.">Vpmg_qfForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> *force, <span class="keywordtype">int</span> atomID,
<a name="l06258"></a>06258   <a class="code" href="group___vhal.html#gadd887856f01d4328b9a028110a5488a6" title="Declaration of the Vchrg_Meth type as the Vchrg_Meth enum.">Vchrg_Meth</a> chgm) {
<a name="l06259"></a>06259 
<a name="l06260"></a>06260     <span class="keywordtype">double</span> tforce[3];
<a name="l06261"></a>06261 
<a name="l06262"></a>06262     <span class="comment">/* Reset force */</span>
<a name="l06263"></a>06263     force[0] = 0.0;
<a name="l06264"></a>06264     force[1] = 0.0;
<a name="l06265"></a>06265     force[2] = 0.0;
<a name="l06266"></a>06266 
<a name="l06267"></a>06267     <span class="comment">/* Check surface definition */</span>
<a name="l06268"></a>06268     <span class="keywordflow">if</span> (chgm != <a class="code" href="group___vhal.html#gga3008c37bfa581864fd3dd8a61f10aa1cacd947c58b709cba6c3df8f56785db184">VCM_BSPL2</a>) {
<a name="l06269"></a>06269         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfForce:  It is recommended that forces be \</span>
<a name="l06270"></a>06270 <span class="stringliteral">calculated with the\n&quot;</span>);
<a name="l06271"></a>06271         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfForce:  cubic spline charge discretization \</span>
<a name="l06272"></a>06272 <span class="stringliteral">scheme\n&quot;</span>);
<a name="l06273"></a>06273     }
<a name="l06274"></a>06274 
<a name="l06275"></a>06275     <span class="keywordflow">switch</span> (chgm) {
<a name="l06276"></a>06276         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga3008c37bfa581864fd3dd8a61f10aa1caec4ace101ce9fb196f683f2f0b49f288">VCM_TRIL</a>:
<a name="l06277"></a>06277             <a class="code" href="vpmg_8c.html#a68e3819e4049a4b0c194289a2afb32ea" title="Charge-field force due to a linear spline charge function.">qfForceSpline1</a>(thee, tforce, atomID);
<a name="l06278"></a>06278             <span class="keywordflow">break</span>;
<a name="l06279"></a>06279         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga3008c37bfa581864fd3dd8a61f10aa1cacd947c58b709cba6c3df8f56785db184">VCM_BSPL2</a>:
<a name="l06280"></a>06280             <a class="code" href="vpmg_8c.html#ac55adeb810c3e971ebe1bf9b3a137246" title="Charge-field force due to a cubic spline charge function.">qfForceSpline2</a>(thee, tforce, atomID);
<a name="l06281"></a>06281             <span class="keywordflow">break</span>;
<a name="l06282"></a>06282         <span class="keywordflow">case</span> <a class="code" href="group___vhal.html#gga3008c37bfa581864fd3dd8a61f10aa1caf886afdc9765c36571359ce9d2764ca1">VCM_BSPL4</a>:
<a name="l06283"></a>06283             <a class="code" href="vpmg_8c.html#a682bb08f7ef2b312b9da1c2ba6e0a25b" title="Charge-field force due to a quintic spline charge function.">qfForceSpline4</a>(thee, tforce, atomID);
<a name="l06284"></a>06284             <span class="keywordflow">break</span>;
<a name="l06285"></a>06285         <span class="keywordflow">default</span>:
<a name="l06286"></a>06286             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfForce:  Undefined charge discretization \</span>
<a name="l06287"></a>06287 <span class="stringliteral">method (%d)!\n&quot;</span>, chgm);
<a name="l06288"></a>06288             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfForce:  Forces not calculated!\n&quot;</span>);
<a name="l06289"></a>06289             <span class="keywordflow">return</span> 0;
<a name="l06290"></a>06290     }
<a name="l06291"></a>06291 
<a name="l06292"></a>06292     <span class="comment">/* Assign forces */</span>
<a name="l06293"></a>06293     force[0] = tforce[0];
<a name="l06294"></a>06294     force[1] = tforce[1];
<a name="l06295"></a>06295     force[2] = tforce[2];
<a name="l06296"></a>06296 
<a name="l06297"></a>06297     <span class="keywordflow">return</span> 1;
<a name="l06298"></a>06298 }
<a name="l06299"></a>06299 
<a name="l06300"></a>06300 
<a name="l06301"></a><a class="code" href="vpmg_8h.html#a68e3819e4049a4b0c194289a2afb32ea">06301</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a68e3819e4049a4b0c194289a2afb32ea" title="Charge-field force due to a linear spline charge function.">qfForceSpline1</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> *force, <span class="keywordtype">int</span> atomID) {
<a name="l06302"></a>06302 
<a name="l06303"></a>06303     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l06304"></a>06304 
<a name="l06305"></a>06305     <span class="keywordtype">double</span> *apos, position[3], hx, hy, hzed;
<a name="l06306"></a>06306     <span class="keywordtype">double</span> xmin, ymin, zmin, xmax, ymax, zmax;
<a name="l06307"></a>06307     <span class="keywordtype">double</span> dx, dy, dz;
<a name="l06308"></a>06308     <span class="keywordtype">double</span> *u, charge, ifloat, jfloat, kfloat;
<a name="l06309"></a>06309     <span class="keywordtype">int</span> nx, ny, nz, ihi, ilo, jhi, jlo, khi, klo;
<a name="l06310"></a>06310 
<a name="l06311"></a>06311     VASSERT(thee != VNULL);
<a name="l06312"></a>06312 
<a name="l06313"></a>06313     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l06314"></a>06314     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l06315"></a>06315     charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l06316"></a>06316 
<a name="l06317"></a>06317     <span class="comment">/* Reset force */</span>
<a name="l06318"></a>06318     force[0] = 0.0;
<a name="l06319"></a>06319     force[1] = 0.0;
<a name="l06320"></a>06320     force[2] = 0.0;
<a name="l06321"></a>06321 
<a name="l06322"></a>06322     <span class="comment">/* If we aren&#39;t in the current position, then we&#39;re done */</span>
<a name="l06323"></a>06323     <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> == 0) <span class="keywordflow">return</span>;
<a name="l06324"></a>06324 
<a name="l06325"></a>06325     <span class="comment">/* Mesh info */</span>
<a name="l06326"></a>06326     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l06327"></a>06327     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l06328"></a>06328     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l06329"></a>06329     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l06330"></a>06330     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l06331"></a>06331     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l06332"></a>06332     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l06333"></a>06333     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l06334"></a>06334     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l06335"></a>06335     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l06336"></a>06336     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l06337"></a>06337     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l06338"></a>06338     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l06339"></a>06339 
<a name="l06340"></a>06340     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l06341"></a>06341     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax) || (apos[1]&lt;=ymin) || \
<a name="l06342"></a>06342         (apos[1]&gt;=ymax) || (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l06343"></a>06343         <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l06344"></a>06344             (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l06345"></a>06345             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfForce:  Atom #%d at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>, atomID, apos[0], apos[1], apos[2]);
<a name="l06346"></a>06346             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfForce:    xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l06347"></a>06347             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfForce:    ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l06348"></a>06348             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_qfForce:    zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l06349"></a>06349         }
<a name="l06350"></a>06350         fflush(stderr);
<a name="l06351"></a>06351     } <span class="keywordflow">else</span> {
<a name="l06352"></a>06352 
<a name="l06353"></a>06353         <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l06354"></a>06354         position[0] = apos[0] - xmin;
<a name="l06355"></a>06355         position[1] = apos[1] - ymin;
<a name="l06356"></a>06356         position[2] = apos[2] - zmin;
<a name="l06357"></a>06357         ifloat = position[0]/hx;
<a name="l06358"></a>06358         jfloat = position[1]/hy;
<a name="l06359"></a>06359         kfloat = position[2]/hzed;
<a name="l06360"></a>06360         ihi = (int)ceil(ifloat);
<a name="l06361"></a>06361         ilo = (int)floor(ifloat);
<a name="l06362"></a>06362         jhi = (int)ceil(jfloat);
<a name="l06363"></a>06363         jlo = (int)floor(jfloat);
<a name="l06364"></a>06364         khi = (int)ceil(kfloat);
<a name="l06365"></a>06365         klo = (int)floor(kfloat);
<a name="l06366"></a>06366         VASSERT((ihi &lt; nx) &amp;&amp; (ihi &gt;=0));
<a name="l06367"></a>06367         VASSERT((ilo &lt; nx) &amp;&amp; (ilo &gt;=0));
<a name="l06368"></a>06368         VASSERT((jhi &lt; ny) &amp;&amp; (jhi &gt;=0));
<a name="l06369"></a>06369         VASSERT((jlo &lt; ny) &amp;&amp; (jlo &gt;=0));
<a name="l06370"></a>06370         VASSERT((khi &lt; nz) &amp;&amp; (khi &gt;=0));
<a name="l06371"></a>06371         VASSERT((klo &lt; nz) &amp;&amp; (klo &gt;=0));
<a name="l06372"></a>06372         dx = ifloat - (double)(ilo);
<a name="l06373"></a>06373         dy = jfloat - (double)(jlo);
<a name="l06374"></a>06374         dz = kfloat - (double)(klo);
<a name="l06375"></a>06375 
<a name="l06376"></a>06376 
<a name="l06377"></a>06377 <span class="preprocessor">#if 0</span>
<a name="l06378"></a>06378 <span class="preprocessor"></span>        Vnm_print(1, <span class="stringliteral">&quot;Vpmg_qfForce: (DEBUG) u ~ %g\n&quot;</span>,
<a name="l06379"></a>06379           dx    *dy    *dz    *u[IJK(ihi,jhi,khi)]
<a name="l06380"></a>06380          +dx    *dy    *(1-dz)*u[IJK(ihi,jhi,klo)]
<a name="l06381"></a>06381          +dx    *(1-dy)*dz    *u[IJK(ihi,jlo,khi)]
<a name="l06382"></a>06382          +dx    *(1-dy)*(1-dz)*u[IJK(ihi,jlo,klo)]
<a name="l06383"></a>06383          +(1-dx)*dy    *dz    *u[IJK(ilo,jhi,khi)]
<a name="l06384"></a>06384          +(1-dx)*dy    *(1-dz)*u[IJK(ilo,jhi,klo)]
<a name="l06385"></a>06385          +(1-dx)*(1-dy)*dz    *u[IJK(ilo,jlo,khi)]
<a name="l06386"></a>06386          +(1-dx)*(1-dy)*(1-dz)*u[IJK(ilo,jlo,klo)]);
<a name="l06387"></a>06387 <span class="preprocessor">#endif</span>
<a name="l06388"></a>06388 <span class="preprocessor"></span>
<a name="l06389"></a>06389 
<a name="l06390"></a>06390         <span class="keywordflow">if</span> ((dx &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp; (VABS(1.0-dx) &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>)) {
<a name="l06391"></a>06391             force[0] =
<a name="l06392"></a>06392               -charge*(dy    *dz    *u[IJK(ihi,jhi,khi)]
<a name="l06393"></a>06393                      + dy    *(1-dz)*u[IJK(ihi,jhi,klo)]
<a name="l06394"></a>06394                      + (1-dy)*dz    *u[IJK(ihi,jlo,khi)]
<a name="l06395"></a>06395                      + (1-dy)*(1-dz)*u[IJK(ihi,jlo,klo)]
<a name="l06396"></a>06396                      - dy    *dz    *u[IJK(ilo,jhi,khi)]
<a name="l06397"></a>06397                      - dy    *(1-dz)*u[IJK(ilo,jhi,klo)]
<a name="l06398"></a>06398                      - (1-dy)*dz    *u[IJK(ilo,jlo,khi)]
<a name="l06399"></a>06399                      - (1-dy)*(1-dz)*u[IJK(ilo,jlo,klo)])/hx;
<a name="l06400"></a>06400         } <span class="keywordflow">else</span> {
<a name="l06401"></a>06401             force[0] = 0;
<a name="l06402"></a>06402             Vnm_print(0,
<a name="l06403"></a>06403               <span class="stringliteral">&quot;Vpmg_qfForce:  Atom %d on x gridline; zero x-force\n&quot;</span>, atomID);
<a name="l06404"></a>06404         }
<a name="l06405"></a>06405         <span class="keywordflow">if</span> ((dy &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp; (VABS(1.0-dy) &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>)) {
<a name="l06406"></a>06406             force[1] =
<a name="l06407"></a>06407               -charge*(dx    *dz    *u[IJK(ihi,jhi,khi)]
<a name="l06408"></a>06408                      + dx    *(1-dz)*u[IJK(ihi,jhi,klo)]
<a name="l06409"></a>06409                      - dx    *dz    *u[IJK(ihi,jlo,khi)]
<a name="l06410"></a>06410                      - dx    *(1-dz)*u[IJK(ihi,jlo,klo)]
<a name="l06411"></a>06411                      + (1-dx)*dz    *u[IJK(ilo,jhi,khi)]
<a name="l06412"></a>06412                      + (1-dx)*(1-dz)*u[IJK(ilo,jhi,klo)]
<a name="l06413"></a>06413                      - (1-dx)*dz    *u[IJK(ilo,jlo,khi)]
<a name="l06414"></a>06414                      - (1-dx)*(1-dz)*u[IJK(ilo,jlo,klo)])/hy;
<a name="l06415"></a>06415         } <span class="keywordflow">else</span> {
<a name="l06416"></a>06416             force[1] = 0;
<a name="l06417"></a>06417             Vnm_print(0,
<a name="l06418"></a>06418               <span class="stringliteral">&quot;Vpmg_qfForce:  Atom %d on y gridline; zero y-force\n&quot;</span>, atomID);
<a name="l06419"></a>06419         }
<a name="l06420"></a>06420         <span class="keywordflow">if</span> ((dz &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) &amp;&amp; (VABS(1.0-dz) &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>)) {
<a name="l06421"></a>06421             force[2] =
<a name="l06422"></a>06422               -charge*(dy    *dx    *u[IJK(ihi,jhi,khi)]
<a name="l06423"></a>06423                      - dy    *dx    *u[IJK(ihi,jhi,klo)]
<a name="l06424"></a>06424                      + (1-dy)*dx    *u[IJK(ihi,jlo,khi)]
<a name="l06425"></a>06425                      - (1-dy)*dx    *u[IJK(ihi,jlo,klo)]
<a name="l06426"></a>06426                      + dy    *(1-dx)*u[IJK(ilo,jhi,khi)]
<a name="l06427"></a>06427                      - dy    *(1-dx)*u[IJK(ilo,jhi,klo)]
<a name="l06428"></a>06428                      + (1-dy)*(1-dx)*u[IJK(ilo,jlo,khi)]
<a name="l06429"></a>06429                      - (1-dy)*(1-dx)*u[IJK(ilo,jlo,klo)])/hzed;
<a name="l06430"></a>06430         } <span class="keywordflow">else</span> {
<a name="l06431"></a>06431             force[2] = 0;
<a name="l06432"></a>06432             Vnm_print(0,
<a name="l06433"></a>06433               <span class="stringliteral">&quot;Vpmg_qfForce:  Atom %d on z gridline; zero z-force\n&quot;</span>, atomID);
<a name="l06434"></a>06434         }
<a name="l06435"></a>06435     }
<a name="l06436"></a>06436 }
<a name="l06437"></a>06437 
<a name="l06438"></a><a class="code" href="vpmg_8h.html#ac55adeb810c3e971ebe1bf9b3a137246">06438</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#ac55adeb810c3e971ebe1bf9b3a137246" title="Charge-field force due to a cubic spline charge function.">qfForceSpline2</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> *force, <span class="keywordtype">int</span> atomID) {
<a name="l06439"></a>06439 
<a name="l06440"></a>06440     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l06441"></a>06441 
<a name="l06442"></a>06442     <span class="keywordtype">double</span> *apos, position[3], hx, hy, hzed;
<a name="l06443"></a>06443     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax;
<a name="l06444"></a>06444     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz;
<a name="l06445"></a>06445     <span class="keywordtype">double</span> *u, charge, ifloat, jfloat, kfloat;
<a name="l06446"></a>06446     <span class="keywordtype">int</span> nx, ny, nz, im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1;
<a name="l06447"></a>06447     <span class="keywordtype">int</span> kp1, kp2, ii, jj, kk;
<a name="l06448"></a>06448 
<a name="l06449"></a>06449     VASSERT(thee != VNULL);
<a name="l06450"></a>06450 
<a name="l06451"></a>06451     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l06452"></a>06452     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l06453"></a>06453     charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l06454"></a>06454 
<a name="l06455"></a>06455     <span class="comment">/* Reset force */</span>
<a name="l06456"></a>06456     force[0] = 0.0;
<a name="l06457"></a>06457     force[1] = 0.0;
<a name="l06458"></a>06458     force[2] = 0.0;
<a name="l06459"></a>06459 
<a name="l06460"></a>06460     <span class="comment">/* If we aren&#39;t in the current position, then we&#39;re done */</span>
<a name="l06461"></a>06461     <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> == 0) <span class="keywordflow">return</span>;
<a name="l06462"></a>06462 
<a name="l06463"></a>06463     <span class="comment">/* Mesh info */</span>
<a name="l06464"></a>06464     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l06465"></a>06465     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l06466"></a>06466     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l06467"></a>06467     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l06468"></a>06468     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l06469"></a>06469     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l06470"></a>06470     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l06471"></a>06471     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l06472"></a>06472     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l06473"></a>06473     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l06474"></a>06474     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l06475"></a>06475     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l06476"></a>06476     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l06477"></a>06477     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l06478"></a>06478     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l06479"></a>06479     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l06480"></a>06480 
<a name="l06481"></a>06481     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l06482"></a>06482     <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin+hx))   || (apos[0]&gt;=(xmax-hx)) \
<a name="l06483"></a>06483      || (apos[1]&lt;=(ymin+hy))   || (apos[1]&gt;=(ymax-hy)) \
<a name="l06484"></a>06484      || (apos[2]&lt;=(zmin+hzed)) || (apos[2]&gt;=(zmax-hzed))) {
<a name="l06485"></a>06485         <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l06486"></a>06486             (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l06487"></a>06487             Vnm_print(2, <span class="stringliteral">&quot;qfForceSpline2:  Atom #%d off the mesh \</span>
<a name="l06488"></a>06488 <span class="stringliteral">                (ignoring)\n&quot;</span>, atomID);
<a name="l06489"></a>06489         }
<a name="l06490"></a>06490         fflush(stderr);
<a name="l06491"></a>06491 
<a name="l06492"></a>06492     } <span class="keywordflow">else</span> {
<a name="l06493"></a>06493 
<a name="l06494"></a>06494         <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l06495"></a>06495         position[0] = apos[0] - xmin;
<a name="l06496"></a>06496         position[1] = apos[1] - ymin;
<a name="l06497"></a>06497         position[2] = apos[2] - zmin;
<a name="l06498"></a>06498         ifloat = position[0]/hx;
<a name="l06499"></a>06499         jfloat = position[1]/hy;
<a name="l06500"></a>06500         kfloat = position[2]/hzed;
<a name="l06501"></a>06501         ip1 = (int)ceil(ifloat);
<a name="l06502"></a>06502         ip2 = ip1 + 1;
<a name="l06503"></a>06503         im1 = (int)floor(ifloat);
<a name="l06504"></a>06504         im2 = im1 - 1;
<a name="l06505"></a>06505         jp1 = (int)ceil(jfloat);
<a name="l06506"></a>06506         jp2 = jp1 + 1;
<a name="l06507"></a>06507         jm1 = (int)floor(jfloat);
<a name="l06508"></a>06508         jm2 = jm1 - 1;
<a name="l06509"></a>06509         kp1 = (int)ceil(kfloat);
<a name="l06510"></a>06510         kp2 = kp1 + 1;
<a name="l06511"></a>06511         km1 = (int)floor(kfloat);
<a name="l06512"></a>06512         km2 = km1 - 1;
<a name="l06513"></a>06513 
<a name="l06514"></a>06514         <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l06515"></a>06515 <span class="comment">         * later on if something goes wrong */</span>
<a name="l06516"></a>06516         ip2 = VMIN2(ip2,nx-1);
<a name="l06517"></a>06517         ip1 = VMIN2(ip1,nx-1);
<a name="l06518"></a>06518         im1 = VMAX2(im1,0);
<a name="l06519"></a>06519         im2 = VMAX2(im2,0);
<a name="l06520"></a>06520         jp2 = VMIN2(jp2,ny-1);
<a name="l06521"></a>06521         jp1 = VMIN2(jp1,ny-1);
<a name="l06522"></a>06522         jm1 = VMAX2(jm1,0);
<a name="l06523"></a>06523         jm2 = VMAX2(jm2,0);
<a name="l06524"></a>06524         kp2 = VMIN2(kp2,nz-1);
<a name="l06525"></a>06525         kp1 = VMIN2(kp1,nz-1);
<a name="l06526"></a>06526         km1 = VMAX2(km1,0);
<a name="l06527"></a>06527         km2 = VMAX2(km2,0);
<a name="l06528"></a>06528 
<a name="l06529"></a>06529 
<a name="l06530"></a>06530         <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l06531"></a>06531             mx = <a class="code" href="vpmg_8c.html#a50d8ef438d4a7a76d869fb256b24d372" title="Evaluate a cubic B-spline.">bspline2</a>(VFCHI(ii,ifloat));
<a name="l06532"></a>06532             dmx = <a class="code" href="vpmg_8c.html#a8a4a959a2448c20bfc3660f04077892e" title="Evaluate a cubic B-spline derivative.">dbspline2</a>(VFCHI(ii,ifloat));
<a name="l06533"></a>06533             <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l06534"></a>06534                 my = <a class="code" href="vpmg_8c.html#a50d8ef438d4a7a76d869fb256b24d372" title="Evaluate a cubic B-spline.">bspline2</a>(VFCHI(jj,jfloat));
<a name="l06535"></a>06535                 dmy = <a class="code" href="vpmg_8c.html#a8a4a959a2448c20bfc3660f04077892e" title="Evaluate a cubic B-spline derivative.">dbspline2</a>(VFCHI(jj,jfloat));
<a name="l06536"></a>06536                 <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l06537"></a>06537                     mz = <a class="code" href="vpmg_8c.html#a50d8ef438d4a7a76d869fb256b24d372" title="Evaluate a cubic B-spline.">bspline2</a>(VFCHI(kk,kfloat));
<a name="l06538"></a>06538                     dmz = <a class="code" href="vpmg_8c.html#a8a4a959a2448c20bfc3660f04077892e" title="Evaluate a cubic B-spline derivative.">dbspline2</a>(VFCHI(kk,kfloat));
<a name="l06539"></a>06539 
<a name="l06540"></a>06540                     force[0] += (charge*dmx*my*mz*u[IJK(ii,jj,kk)])/hx;
<a name="l06541"></a>06541                     force[1] += (charge*mx*dmy*mz*u[IJK(ii,jj,kk)])/hy;
<a name="l06542"></a>06542                     force[2] += (charge*mx*my*dmz*u[IJK(ii,jj,kk)])/hzed;
<a name="l06543"></a>06543 
<a name="l06544"></a>06544                 }
<a name="l06545"></a>06545             }
<a name="l06546"></a>06546         }
<a name="l06547"></a>06547 
<a name="l06548"></a>06548     }
<a name="l06549"></a>06549 }
<a name="l06550"></a>06550 
<a name="l06551"></a><a class="code" href="vpmg_8h.html#a682bb08f7ef2b312b9da1c2ba6e0a25b">06551</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a682bb08f7ef2b312b9da1c2ba6e0a25b" title="Charge-field force due to a quintic spline charge function.">qfForceSpline4</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">double</span> *force, <span class="keywordtype">int</span> atomID) {
<a name="l06552"></a>06552 
<a name="l06553"></a>06553     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l06554"></a>06554     <span class="keywordtype">double</span> f, c, *u, *apos, position[3];
<a name="l06555"></a>06555 
<a name="l06556"></a>06556     <span class="comment">/* Grid variables */</span>
<a name="l06557"></a>06557     <span class="keywordtype">int</span> nx,ny,nz;
<a name="l06558"></a>06558     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax;
<a name="l06559"></a>06559     <span class="keywordtype">double</span> hx, hy, hzed, ifloat, jfloat, kfloat;
<a name="l06560"></a>06560 
<a name="l06561"></a>06561     <span class="comment">/* B-spline weights */</span>
<a name="l06562"></a>06562     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz;
<a name="l06563"></a>06563     <span class="keywordtype">double</span> mi, mj, mk;
<a name="l06564"></a>06564 
<a name="l06565"></a>06565     <span class="comment">/* Loop indeces */</span>
<a name="l06566"></a>06566     <span class="keywordtype">int</span> i, j, k, ii, jj, kk;
<a name="l06567"></a>06567     <span class="keywordtype">int</span> im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1, kp1, kp2;
<a name="l06568"></a>06568 
<a name="l06569"></a>06569     <span class="comment">/* field */</span>
<a name="l06570"></a>06570     <span class="keywordtype">double</span> e[3];
<a name="l06571"></a>06571 
<a name="l06572"></a>06572     VASSERT(thee != VNULL);
<a name="l06573"></a>06573     VASSERT(thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>);
<a name="l06574"></a>06574 
<a name="l06575"></a>06575     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l06576"></a>06576     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l06577"></a>06577     c = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l06578"></a>06578 
<a name="l06579"></a>06579     <span class="keywordflow">for</span> (i=0;i&lt;3;i++){
<a name="l06580"></a>06580         e[i] = 0.0;
<a name="l06581"></a>06581     }
<a name="l06582"></a>06582 
<a name="l06583"></a>06583     <span class="comment">/* Mesh info */</span>
<a name="l06584"></a>06584     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l06585"></a>06585     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l06586"></a>06586     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l06587"></a>06587     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l06588"></a>06588     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l06589"></a>06589     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l06590"></a>06590     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l06591"></a>06591     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l06592"></a>06592     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l06593"></a>06593     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l06594"></a>06594     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l06595"></a>06595     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l06596"></a>06596     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l06597"></a>06597     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l06598"></a>06598     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l06599"></a>06599     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l06600"></a>06600 
<a name="l06601"></a>06601     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l06602"></a>06602     <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin+2*hx))   || (apos[0]&gt;=(xmax-2*hx)) \
<a name="l06603"></a>06603         || (apos[1]&lt;=(ymin+2*hy))   || (apos[1]&gt;=(ymax-2*hy)) \
<a name="l06604"></a>06604         || (apos[2]&lt;=(zmin+2*hzed)) || (apos[2]&gt;=(zmax-2*hzed))) {
<a name="l06605"></a>06605         Vnm_print(2, <span class="stringliteral">&quot;qfForceSpline4:  Atom off the mesh \</span>
<a name="l06606"></a>06606 <span class="stringliteral">            (ignoring) %6.3f %6.3f %6.3f\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l06607"></a>06607         fflush(stderr);
<a name="l06608"></a>06608     } <span class="keywordflow">else</span> {
<a name="l06609"></a>06609 
<a name="l06610"></a>06610         <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l06611"></a>06611         position[0] = apos[0] - xmin;
<a name="l06612"></a>06612         position[1] = apos[1] - ymin;
<a name="l06613"></a>06613         position[2] = apos[2] - zmin;
<a name="l06614"></a>06614         ifloat = position[0]/hx;
<a name="l06615"></a>06615         jfloat = position[1]/hy;
<a name="l06616"></a>06616         kfloat = position[2]/hzed;
<a name="l06617"></a>06617         ip1 = (int)ceil(ifloat);
<a name="l06618"></a>06618         ip2 = ip1 + 2;
<a name="l06619"></a>06619         im1 = (int)floor(ifloat);
<a name="l06620"></a>06620         im2 = im1 - 2;
<a name="l06621"></a>06621         jp1 = (int)ceil(jfloat);
<a name="l06622"></a>06622         jp2 = jp1 + 2;
<a name="l06623"></a>06623         jm1 = (int)floor(jfloat);
<a name="l06624"></a>06624         jm2 = jm1 - 2;
<a name="l06625"></a>06625         kp1 = (int)ceil(kfloat);
<a name="l06626"></a>06626         kp2 = kp1 + 2;
<a name="l06627"></a>06627         km1 = (int)floor(kfloat);
<a name="l06628"></a>06628         km2 = km1 - 2;
<a name="l06629"></a>06629 
<a name="l06630"></a>06630         <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l06631"></a>06631 <span class="comment">            * later on if something goes wrong */</span>
<a name="l06632"></a>06632         ip2 = VMIN2(ip2,nx-1);
<a name="l06633"></a>06633         ip1 = VMIN2(ip1,nx-1);
<a name="l06634"></a>06634         im1 = VMAX2(im1,0);
<a name="l06635"></a>06635         im2 = VMAX2(im2,0);
<a name="l06636"></a>06636         jp2 = VMIN2(jp2,ny-1);
<a name="l06637"></a>06637         jp1 = VMIN2(jp1,ny-1);
<a name="l06638"></a>06638         jm1 = VMAX2(jm1,0);
<a name="l06639"></a>06639         jm2 = VMAX2(jm2,0);
<a name="l06640"></a>06640         kp2 = VMIN2(kp2,nz-1);
<a name="l06641"></a>06641         kp1 = VMIN2(kp1,nz-1);
<a name="l06642"></a>06642         km1 = VMAX2(km1,0);
<a name="l06643"></a>06643         km2 = VMAX2(km2,0);
<a name="l06644"></a>06644 
<a name="l06645"></a>06645         <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l06646"></a>06646             mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l06647"></a>06647             mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l06648"></a>06648             dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l06649"></a>06649             <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l06650"></a>06650                 mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l06651"></a>06651                 my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l06652"></a>06652                 dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l06653"></a>06653                 <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l06654"></a>06654                     mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l06655"></a>06655                     mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l06656"></a>06656                     dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l06657"></a>06657                     f = u[IJK(ii,jj,kk)];
<a name="l06658"></a>06658                     <span class="comment">/* Field */</span>
<a name="l06659"></a>06659                     e[0] += f*dmx*my*mz/hx;
<a name="l06660"></a>06660                     e[1] += f*mx*dmy*mz/hy;
<a name="l06661"></a>06661                     e[2] += f*mx*my*dmz/hzed;
<a name="l06662"></a>06662                 }
<a name="l06663"></a>06663             }
<a name="l06664"></a>06664         }
<a name="l06665"></a>06665     }
<a name="l06666"></a>06666 
<a name="l06667"></a>06667     <span class="comment">/* Monopole Force */</span>
<a name="l06668"></a>06668     force[0] = e[0]*c;
<a name="l06669"></a>06669     force[1] = e[1]*c;
<a name="l06670"></a>06670     force[2] = e[2]*c;
<a name="l06671"></a>06671 
<a name="l06672"></a>06672 }
<a name="l06673"></a>06673 
<a name="l06674"></a>06674 VPRIVATE <span class="keywordtype">void</span> markFrac(
<a name="l06675"></a>06675         <span class="keywordtype">double</span> rtot, <span class="keywordtype">double</span> *tpos,
<a name="l06676"></a>06676         <span class="keywordtype">int</span> nx, <span class="keywordtype">int</span> ny, <span class="keywordtype">int</span> nz,
<a name="l06677"></a>06677         <span class="keywordtype">double</span> hx, <span class="keywordtype">double</span> hy, <span class="keywordtype">double</span> hzed,
<a name="l06678"></a>06678         <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> zmin,
<a name="l06679"></a>06679         <span class="keywordtype">double</span> *xarray, <span class="keywordtype">double</span> *yarray, <span class="keywordtype">double</span> *zarray) {
<a name="l06680"></a>06680 
<a name="l06681"></a>06681     <span class="keywordtype">int</span> i, j, k, imin, imax, jmin, jmax, kmin, kmax;
<a name="l06682"></a>06682     <span class="keywordtype">double</span> dx, dx2, dy, dy2, dz, dz2, a000, a001, a010, a100, r2;
<a name="l06683"></a>06683     <span class="keywordtype">double</span> x, xp, xm, y, yp, ym, zp, z, zm, xspan, yspan, zspan;
<a name="l06684"></a>06684     <span class="keywordtype">double</span> rtot2, pos[3];
<a name="l06685"></a>06685 
<a name="l06686"></a>06686     <span class="comment">/* Convert to grid reference frame */</span>
<a name="l06687"></a>06687     pos[0] = tpos[0] - xmin;
<a name="l06688"></a>06688     pos[1] = tpos[1] - ymin;
<a name="l06689"></a>06689     pos[2] = tpos[2] - zmin;
<a name="l06690"></a>06690 
<a name="l06691"></a>06691     rtot2 = VSQR(rtot);
<a name="l06692"></a>06692 
<a name="l06693"></a>06693     xspan = rtot + 2*hx;
<a name="l06694"></a>06694     imin = VMAX2(0, (<span class="keywordtype">int</span>)ceil((pos[0] - xspan)/hx));
<a name="l06695"></a>06695     imax = VMIN2(nx-1, (<span class="keywordtype">int</span>)floor((pos[0] + xspan)/hx));
<a name="l06696"></a>06696     <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l06697"></a>06697         x = hx*i;
<a name="l06698"></a>06698         dx2 = VSQR(pos[0] - x);
<a name="l06699"></a>06699         <span class="keywordflow">if</span> (rtot2 &gt; dx2) {
<a name="l06700"></a>06700             yspan = VSQRT(rtot2 - dx2) + 2*hy;
<a name="l06701"></a>06701         } <span class="keywordflow">else</span> {
<a name="l06702"></a>06702             yspan = 2*hy;
<a name="l06703"></a>06703         }
<a name="l06704"></a>06704         jmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((pos[1] - yspan)/hy));
<a name="l06705"></a>06705         jmax = VMIN2(ny-1,(<span class="keywordtype">int</span>)floor((pos[1] + yspan)/hy));
<a name="l06706"></a>06706         <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l06707"></a>06707             y = hy*j;
<a name="l06708"></a>06708             dy2 = VSQR(pos[1] - y);
<a name="l06709"></a>06709             <span class="keywordflow">if</span> (rtot2 &gt; (dx2+dy2)) {
<a name="l06710"></a>06710                 zspan = VSQRT(rtot2-dx2-dy2) + 2*hzed;
<a name="l06711"></a>06711             } <span class="keywordflow">else</span> {
<a name="l06712"></a>06712                 zspan = 2*hzed;
<a name="l06713"></a>06713             }
<a name="l06714"></a>06714             kmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((pos[2] - zspan)/hzed));
<a name="l06715"></a>06715             kmax = VMIN2(nz-1,(<span class="keywordtype">int</span>)floor((pos[2] + zspan)/hzed));
<a name="l06716"></a>06716             <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l06717"></a>06717                 z = hzed*k;
<a name="l06718"></a>06718                 dz2 = VSQR(pos[2] - z);
<a name="l06719"></a>06719 
<a name="l06720"></a>06720                 r2 = dx2 + dy2 + dz2;
<a name="l06721"></a>06721 
<a name="l06722"></a>06722                 <span class="comment">/* We need to determine the inclusion value a000 at (i,j,k) */</span>
<a name="l06723"></a>06723                 <span class="keywordflow">if</span> (r2 &lt; rtot2) a000 = 1.0;
<a name="l06724"></a>06724                 <span class="keywordflow">else</span> a000 = 0.0;
<a name="l06725"></a>06725 
<a name="l06726"></a>06726                 <span class="comment">/* We need to evaluate the values of x which intersect the</span>
<a name="l06727"></a>06727 <span class="comment">                 * sphere and determine if these are in the interval</span>
<a name="l06728"></a>06728 <span class="comment">                 * [(i,j,k), (i+1,j,k)] */</span>
<a name="l06729"></a>06729                 <span class="keywordflow">if</span> (r2 &lt; (rtot2 - hx*hx)) a100 = 1.0;
<a name="l06730"></a>06730                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r2 &gt; (rtot2 + hx*hx)) a100 = 0.0;
<a name="l06731"></a>06731                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rtot2 &gt; (dy2 + dz2)) {
<a name="l06732"></a>06732                     dx = VSQRT(rtot2 - dy2 - dz2);
<a name="l06733"></a>06733                     xm = pos[0] - dx;
<a name="l06734"></a>06734                     xp = pos[0] + dx;
<a name="l06735"></a>06735                     <span class="keywordflow">if</span> ((xm &lt; x+hx) &amp;&amp; (xm &gt; x)) {
<a name="l06736"></a>06736                         a100 = (xm - x)/hx;
<a name="l06737"></a>06737                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((xp &lt; x+hx) &amp;&amp; (xp &gt; x)) {
<a name="l06738"></a>06738                         a100 = (xp - x)/hx;
<a name="l06739"></a>06739                     }
<a name="l06740"></a>06740                 } <span class="keywordflow">else</span> a100 = 0.0;
<a name="l06741"></a>06741 
<a name="l06742"></a>06742                 <span class="comment">/* We need to evaluate the values of y which intersect the</span>
<a name="l06743"></a>06743 <span class="comment">                 * sphere and determine if these are in the interval</span>
<a name="l06744"></a>06744 <span class="comment">                 * [(i,j,k), (i,j+1,k)] */</span>
<a name="l06745"></a>06745                 <span class="keywordflow">if</span> (r2 &lt; (rtot2 - hy*hy)) a010 = 1.0;
<a name="l06746"></a>06746                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r2 &gt; (rtot2 + hy*hy)) a010 = 0.0;
<a name="l06747"></a>06747                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rtot2 &gt; (dx2 + dz2)) {
<a name="l06748"></a>06748                     dy = VSQRT(rtot2 - dx2 - dz2);
<a name="l06749"></a>06749                     ym = pos[1] - dy;
<a name="l06750"></a>06750                     yp = pos[1] + dy;
<a name="l06751"></a>06751                     <span class="keywordflow">if</span> ((ym &lt; y+hy) &amp;&amp; (ym &gt; y)) {
<a name="l06752"></a>06752                         a010 = (ym - y)/hy;
<a name="l06753"></a>06753                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((yp &lt; y+hy) &amp;&amp; (yp &gt; y)) {
<a name="l06754"></a>06754                         a010 = (yp - y)/hy;
<a name="l06755"></a>06755                     }
<a name="l06756"></a>06756                 } <span class="keywordflow">else</span> a010 = 0.0;
<a name="l06757"></a>06757 
<a name="l06758"></a>06758                 <span class="comment">/* We need to evaluate the values of y which intersect the</span>
<a name="l06759"></a>06759 <span class="comment">                 * sphere and determine if these are in the interval</span>
<a name="l06760"></a>06760 <span class="comment">                 * [(i,j,k), (i,j,k+1)] */</span>
<a name="l06761"></a>06761                 <span class="keywordflow">if</span> (r2 &lt; (rtot2 - hzed*hzed)) a001 = 1.0;
<a name="l06762"></a>06762                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r2 &gt; (rtot2 + hzed*hzed)) a001 = 0.0;
<a name="l06763"></a>06763                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rtot2 &gt; (dx2 + dy2)) {
<a name="l06764"></a>06764                     dz = VSQRT(rtot2 - dx2 - dy2);
<a name="l06765"></a>06765                     zm = pos[2] - dz;
<a name="l06766"></a>06766                     zp = pos[2] + dz;
<a name="l06767"></a>06767                     <span class="keywordflow">if</span> ((zm &lt; z+hzed) &amp;&amp; (zm &gt; z)) {
<a name="l06768"></a>06768                         a001 = (zm - z)/hzed;
<a name="l06769"></a>06769                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((zp &lt; z+hzed) &amp;&amp; (zp &gt; z)) {
<a name="l06770"></a>06770                         a001 = (zp - z)/hzed;
<a name="l06771"></a>06771                     }
<a name="l06772"></a>06772                 } <span class="keywordflow">else</span> a001 = 0.0;
<a name="l06773"></a>06773 
<a name="l06774"></a>06774                 <span class="keywordflow">if</span> (a100 &lt; xarray[IJK(i,j,k)]) xarray[IJK(i,j,k)] = a100;
<a name="l06775"></a>06775                 <span class="keywordflow">if</span> (a010 &lt; yarray[IJK(i,j,k)]) yarray[IJK(i,j,k)] = a010;
<a name="l06776"></a>06776                 <span class="keywordflow">if</span> (a001 &lt; zarray[IJK(i,j,k)]) zarray[IJK(i,j,k)] = a001;
<a name="l06777"></a>06777 
<a name="l06778"></a>06778             } <span class="comment">/* k loop */</span>
<a name="l06779"></a>06779         } <span class="comment">/* j loop */</span>
<a name="l06780"></a>06780     } <span class="comment">/* i loop */</span>
<a name="l06781"></a>06781 }
<a name="l06782"></a>06782 
<a name="l06783"></a>06783 <span class="comment">/*</span>
<a name="l06784"></a>06784 <span class="comment"></span>
<a name="l06785"></a>06785 <span class="comment"> NOTE: This is the original version of the markSphere function. It&#39;s in here</span>
<a name="l06786"></a>06786 <span class="comment"> for reference and in case a reversion to the original code is needed.</span>
<a name="l06787"></a>06787 <span class="comment"> D. Gohara (2/14/08)</span>
<a name="l06788"></a>06788 <span class="comment"> */</span>
<a name="l06789"></a>06789 <span class="comment">/*</span>
<a name="l06790"></a>06790 <span class="comment">VPRIVATE void markSphere(</span>
<a name="l06791"></a>06791 <span class="comment">                         double rtot, double *tpos,</span>
<a name="l06792"></a>06792 <span class="comment">                         int nx, int ny, int nz,</span>
<a name="l06793"></a>06793 <span class="comment">                         double hx, double hy, double hzed,</span>
<a name="l06794"></a>06794 <span class="comment">                         double xmin, double ymin, double zmin,</span>
<a name="l06795"></a>06795 <span class="comment">                         double *array, double markVal) {</span>
<a name="l06796"></a>06796 <span class="comment"></span>
<a name="l06797"></a>06797 <span class="comment">    int i, j, k, imin, imax, jmin, jmax, kmin, kmax;</span>
<a name="l06798"></a>06798 <span class="comment">    double dx, dx2, dy, dy2, dz, dz2;</span>
<a name="l06799"></a>06799 <span class="comment">    double rtot2, pos[3];</span>
<a name="l06800"></a>06800 <span class="comment"></span>
<a name="l06801"></a>06801 <span class="comment">    // Convert to grid reference frame</span>
<a name="l06802"></a>06802 <span class="comment">    pos[0] = tpos[0] - xmin;</span>
<a name="l06803"></a>06803 <span class="comment">    pos[1] = tpos[1] - ymin;</span>
<a name="l06804"></a>06804 <span class="comment">    pos[2] = tpos[2] - zmin;</span>
<a name="l06805"></a>06805 <span class="comment"></span>
<a name="l06806"></a>06806 <span class="comment">    rtot2 = VSQR(rtot);</span>
<a name="l06807"></a>06807 <span class="comment"></span>
<a name="l06808"></a>06808 <span class="comment">    dx = rtot + 0.5*hx;</span>
<a name="l06809"></a>06809 <span class="comment">    imin = VMAX2(0,(int)ceil((pos[0] - dx)/hx));</span>
<a name="l06810"></a>06810 <span class="comment">    imax = VMIN2(nx-1,(int)floor((pos[0] + dx)/hx));</span>
<a name="l06811"></a>06811 <span class="comment">    for (i=imin; i&lt;=imax; i++) {</span>
<a name="l06812"></a>06812 <span class="comment">        dx2 = VSQR(pos[0] - hx*i);</span>
<a name="l06813"></a>06813 <span class="comment">        if (rtot2 &gt; dx2) {</span>
<a name="l06814"></a>06814 <span class="comment">            dy = VSQRT(rtot2 - dx2) + 0.5*hy;</span>
<a name="l06815"></a>06815 <span class="comment">        } else {</span>
<a name="l06816"></a>06816 <span class="comment">            dy = 0.5*hy;</span>
<a name="l06817"></a>06817 <span class="comment">        }</span>
<a name="l06818"></a>06818 <span class="comment">        jmin = VMAX2(0,(int)ceil((pos[1] - dy)/hy));</span>
<a name="l06819"></a>06819 <span class="comment">        jmax = VMIN2(ny-1,(int)floor((pos[1] + dy)/hy));</span>
<a name="l06820"></a>06820 <span class="comment">        for (j=jmin; j&lt;=jmax; j++) {</span>
<a name="l06821"></a>06821 <span class="comment">            dy2 = VSQR(pos[1] - hy*j);</span>
<a name="l06822"></a>06822 <span class="comment">            if (rtot2 &gt; (dx2+dy2)) {</span>
<a name="l06823"></a>06823 <span class="comment">                dz = VSQRT(rtot2-dx2-dy2)+0.5*hzed;</span>
<a name="l06824"></a>06824 <span class="comment">            } else {</span>
<a name="l06825"></a>06825 <span class="comment">                dz = 0.5*hzed;</span>
<a name="l06826"></a>06826 <span class="comment">            }</span>
<a name="l06827"></a>06827 <span class="comment">            kmin = VMAX2(0,(int)ceil((pos[2] - dz)/hzed));</span>
<a name="l06828"></a>06828 <span class="comment">            kmax = VMIN2(nz-1,(int)floor((pos[2] + dz)/hzed));</span>
<a name="l06829"></a>06829 <span class="comment">            for (k=kmin; k&lt;=kmax; k++) {</span>
<a name="l06830"></a>06830 <span class="comment">                dz2 = VSQR(k*hzed - pos[2]);</span>
<a name="l06831"></a>06831 <span class="comment">                if ((dz2 + dy2 + dx2) &lt;= rtot2) {</span>
<a name="l06832"></a>06832 <span class="comment">                    array[IJK(i,j,k)] = markVal;</span>
<a name="l06833"></a>06833 <span class="comment">                }</span>
<a name="l06834"></a>06834 <span class="comment">            } // k loop</span>
<a name="l06835"></a>06835 <span class="comment">        } // j loop</span>
<a name="l06836"></a>06836 <span class="comment">    } // i loop</span>
<a name="l06837"></a>06837 <span class="comment">}</span>
<a name="l06838"></a>06838 <span class="comment">*/</span>
<a name="l06839"></a><a class="code" href="vpmg_8h.html#aac867a97b6a1b573c285c846237837a5">06839</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#af4f11e78d20500aa43167eab5e52752f" title="Mark the grid points inside a sphere with a particular value. This marks by resetting the the grid po...">markSphere</a>(<span class="keywordtype">double</span> rtot, <span class="keywordtype">double</span> *tpos,
<a name="l06840"></a>06840                          <span class="keywordtype">int</span> nx, <span class="keywordtype">int</span> ny, <span class="keywordtype">int</span> nz,
<a name="l06841"></a>06841                          <span class="keywordtype">double</span> hx, <span class="keywordtype">double</span> hy, <span class="keywordtype">double</span> hz,
<a name="l06842"></a>06842                          <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> zmin,
<a name="l06843"></a>06843                          <span class="keywordtype">double</span> *array, <span class="keywordtype">double</span> markVal) {
<a name="l06844"></a>06844 
<a name="l06845"></a>06845     <span class="keywordtype">int</span> i, j, k;
<a name="l06846"></a>06846     <span class="keywordtype">double</span> fi,fj,fk;
<a name="l06847"></a>06847     <span class="keywordtype">int</span> imin, imax;
<a name="l06848"></a>06848     <span class="keywordtype">int</span> jmin, jmax;
<a name="l06849"></a>06849     <span class="keywordtype">int</span> kmin, kmax;
<a name="l06850"></a>06850     <span class="keywordtype">double</span> dx2, dy2, dz2;
<a name="l06851"></a>06851     <span class="keywordtype">double</span> xrange, yrange, zrange;
<a name="l06852"></a>06852     <span class="keywordtype">double</span> rtot2, posx, posy, posz;
<a name="l06853"></a>06853 
<a name="l06854"></a>06854     <span class="comment">/* Convert to grid reference frame */</span>
<a name="l06855"></a>06855     posx = tpos[0] - xmin;
<a name="l06856"></a>06856     posy = tpos[1] - ymin;
<a name="l06857"></a>06857     posz = tpos[2] - zmin;
<a name="l06858"></a>06858 
<a name="l06859"></a>06859     rtot2 = VSQR(rtot);
<a name="l06860"></a>06860 
<a name="l06861"></a>06861     xrange = rtot + 0.5 * hx;
<a name="l06862"></a>06862     yrange = rtot + 0.5 * hy;
<a name="l06863"></a>06863     zrange = rtot + 0.5 * hz;
<a name="l06864"></a>06864 
<a name="l06865"></a>06865     imin = VMAX2(0, (<span class="keywordtype">int</span>)ceil((posx - xrange)/hx));
<a name="l06866"></a>06866     jmin = VMAX2(0, (<span class="keywordtype">int</span>)ceil((posy - yrange)/hy));
<a name="l06867"></a>06867     kmin = VMAX2(0, (<span class="keywordtype">int</span>)ceil((posz - zrange)/hz));
<a name="l06868"></a>06868 
<a name="l06869"></a>06869     imax = VMIN2(nx-1, (<span class="keywordtype">int</span>)floor((posx + xrange)/hx));
<a name="l06870"></a>06870     jmax = VMIN2(ny-1, (<span class="keywordtype">int</span>)floor((posy + yrange)/hy));
<a name="l06871"></a>06871     kmax = VMIN2(nz-1, (<span class="keywordtype">int</span>)floor((posz + zrange)/hz));
<a name="l06872"></a>06872 
<a name="l06873"></a>06873     <span class="keywordflow">for</span> (i=imin,fi=imin; i&lt;=imax; i++, fi+=1.) {
<a name="l06874"></a>06874         dx2 = VSQR(posx - hx*fi);
<a name="l06875"></a>06875         <span class="keywordflow">for</span> (j=jmin,fj=jmin; j&lt;=jmax; j++, fj+=1.) {
<a name="l06876"></a>06876             dy2 = VSQR(posy - hy*fj);
<a name="l06877"></a>06877             <span class="keywordflow">if</span>((dx2 + dy2) &gt; rtot2) <span class="keywordflow">continue</span>;
<a name="l06878"></a>06878             <span class="keywordflow">for</span> (k=kmin, fk=kmin; k&lt;=kmax; k++, fk+=1.) {
<a name="l06879"></a>06879                 dz2 = VSQR(posz - hz*fk);
<a name="l06880"></a>06880                 <span class="keywordflow">if</span> ((dz2 + dy2 + dx2) &lt;= rtot2) {
<a name="l06881"></a>06881                     array[IJK(i,j,k)] = markVal;
<a name="l06882"></a>06882                 }
<a name="l06883"></a>06883             }
<a name="l06884"></a>06884         }
<a name="l06885"></a>06885     }
<a name="l06886"></a>06886 }
<a name="l06887"></a>06887 
<a name="l06888"></a><a class="code" href="vpmg_8h.html#a3667719ad7b6d35bb4ac587513be8b5c">06888</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a3667719ad7b6d35bb4ac587513be8b5c" title="Calculate the solution to Poisson&#39;s equation with a simple Laplacian operator and zero-valued Dirichl...">zlapSolve</a>(
<a name="l06889"></a>06889         <a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee,
<a name="l06890"></a>06890         <span class="keywordtype">double</span> **solution,
<a name="l06891"></a>06891         <span class="keywordtype">double</span> **source,
<a name="l06892"></a>06892         <span class="keywordtype">double</span> **work1
<a name="l06893"></a>06893         ) {
<a name="l06894"></a>06894 
<a name="l06895"></a>06895     <span class="comment">/* NOTE:  this is an incredibly inefficient algorithm.  The next</span>
<a name="l06896"></a>06896 <span class="comment">     * improvement is to focus on only non-zero entries in the source term.</span>
<a name="l06897"></a>06897 <span class="comment">     * The best improvement is to use a fast sine transform */</span>
<a name="l06898"></a>06898 
<a name="l06899"></a>06899     <span class="keywordtype">int</span> n, nx, ny, nz, i, j, k, kx, ky, kz;
<a name="l06900"></a>06900     <span class="keywordtype">double</span> hx, hy, hzed, wx, wy, wz, xlen, ylen, zlen;
<a name="l06901"></a>06901     <span class="keywordtype">double</span> phix, phixp1, phixm1, phiy, phiym1, phiyp1, phiz, phizm1, phizp1;
<a name="l06902"></a>06902     <span class="keywordtype">double</span> norm, coef, proj, eigx, eigy, eigz;
<a name="l06903"></a>06903     <span class="keywordtype">double</span> ihx2, ihy2, ihzed2;
<a name="l06904"></a>06904     <span class="keywordtype">double</span> *u, *f, *phi;
<a name="l06905"></a>06905 
<a name="l06906"></a>06906     <span class="comment">/* Snarf grid parameters */</span>
<a name="l06907"></a>06907     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l06908"></a>06908     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l06909"></a>06909     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l06910"></a>06910     n = nx*ny*nz;
<a name="l06911"></a>06911     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l06912"></a>06912     ihx2 = 1.0/hx/hx;
<a name="l06913"></a>06913     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l06914"></a>06914     ihy2 = 1.0/hy/hy;
<a name="l06915"></a>06915     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l06916"></a>06916     ihzed2 = 1.0/hzed/hzed;
<a name="l06917"></a>06917     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l06918"></a>06918     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l06919"></a>06919     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l06920"></a>06920 
<a name="l06921"></a>06921     <span class="comment">/* Set solution and source array pointers */</span>
<a name="l06922"></a>06922     u = *solution;
<a name="l06923"></a>06923     f = *source;
<a name="l06924"></a>06924     phi = *work1;
<a name="l06925"></a>06925 
<a name="l06926"></a>06926     <span class="comment">/* Zero out the solution vector */</span>
<a name="l06927"></a>06927     <span class="keywordflow">for</span> (i=0; i&lt;n; i++) thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[i] = 0.0;
<a name="l06928"></a>06928 
<a name="l06929"></a>06929     <span class="comment">/* Iterate through the wavenumbers */</span>
<a name="l06930"></a>06930     for (kx=1; kx&lt;(nx-1); kx++) {
<a name="l06931"></a>06931 
<a name="l06932"></a>06932         wx = (VPI*(double)kx)/((double)nx - 1.0);
<a name="l06933"></a>06933         eigx = 2.0*ihx2*(1.0 - cos(wx));
<a name="l06934"></a>06934 
<a name="l06935"></a>06935         <span class="keywordflow">for</span> (ky=1; ky&lt;(ny-1); ky++) {
<a name="l06936"></a>06936 
<a name="l06937"></a>06937             wy = (VPI*(double)ky)/((double)ny - 1.0);
<a name="l06938"></a>06938             eigy = 2.0*ihy2*(1.0 - cos(wy));
<a name="l06939"></a>06939 
<a name="l06940"></a>06940             <span class="keywordflow">for</span> (kz=1; kz&lt;(nz-1); kz++) {
<a name="l06941"></a>06941 
<a name="l06942"></a>06942                 wz = (VPI*(double)kz)/((double)nz - 1.0);
<a name="l06943"></a>06943                 eigz = 2.0*ihzed2*(1.0 - cos(wz));
<a name="l06944"></a>06944 
<a name="l06945"></a>06945                 <span class="comment">/* Calculate the basis function.</span>
<a name="l06946"></a>06946 <span class="comment">                 * We could calculate each basis function as</span>
<a name="l06947"></a>06947 <span class="comment">                 *   phix(i) = sin(wx*i)</span>
<a name="l06948"></a>06948 <span class="comment">                 *   phiy(j) = sin(wy*j)</span>
<a name="l06949"></a>06949 <span class="comment">                 *   phiz(k) = sin(wz*k)</span>
<a name="l06950"></a>06950 <span class="comment">                 * However, this is likely to be very expensive.</span>
<a name="l06951"></a>06951 <span class="comment">                 * Therefore, we can use the fact that</span>
<a name="l06952"></a>06952 <span class="comment">                 *   phix(i+1) = (2-hx*hx*eigx)*phix(i) - phix(i-1)</span>
<a name="l06953"></a>06953 <span class="comment">                 * */</span>
<a name="l06954"></a>06954                 <span class="keywordflow">for</span> (i=1; i&lt;(nx-1); i++) {
<a name="l06955"></a>06955                     <span class="keywordflow">if</span> (i == 1) {
<a name="l06956"></a>06956                         phix = sin(wx*(<span class="keywordtype">double</span>)i);
<a name="l06957"></a>06957                         phixm1 = 0.0;
<a name="l06958"></a>06958                     } <span class="keywordflow">else</span> {
<a name="l06959"></a>06959                         phixp1 = (2.0-hx*hx*eigx)*phix - phixm1;
<a name="l06960"></a>06960                         phixm1 = phix;
<a name="l06961"></a>06961                         phix = phixp1;
<a name="l06962"></a>06962                     }
<a name="l06963"></a>06963                     <span class="comment">/* phix = sin(wx*(double)i); */</span>
<a name="l06964"></a>06964                     <span class="keywordflow">for</span> (j=1; j&lt;(ny-1); j++) {
<a name="l06965"></a>06965                         <span class="keywordflow">if</span> (j == 1) {
<a name="l06966"></a>06966                             phiy = sin(wy*(<span class="keywordtype">double</span>)j);
<a name="l06967"></a>06967                             phiym1 = 0.0;
<a name="l06968"></a>06968                         } <span class="keywordflow">else</span> {
<a name="l06969"></a>06969                             phiyp1 = (2.0-hy*hy*eigy)*phiy - phiym1;
<a name="l06970"></a>06970                             phiym1 = phiy;
<a name="l06971"></a>06971                             phiy = phiyp1;
<a name="l06972"></a>06972                         }
<a name="l06973"></a>06973                         <span class="comment">/* phiy = sin(wy*(double)j); */</span>
<a name="l06974"></a>06974                         <span class="keywordflow">for</span> (k=1; k&lt;(nz-1); k++) {
<a name="l06975"></a>06975                             <span class="keywordflow">if</span> (k == 1) {
<a name="l06976"></a>06976                                 phiz = sin(wz*(<span class="keywordtype">double</span>)k);
<a name="l06977"></a>06977                                 phizm1 = 0.0;
<a name="l06978"></a>06978                             } <span class="keywordflow">else</span> {
<a name="l06979"></a>06979                                 phizp1 = (2.0-hzed*hzed*eigz)*phiz - phizm1;
<a name="l06980"></a>06980                                 phizm1 = phiz;
<a name="l06981"></a>06981                                 phiz = phizp1;
<a name="l06982"></a>06982                             }
<a name="l06983"></a>06983                             <span class="comment">/* phiz = sin(wz*(double)k); */</span>
<a name="l06984"></a>06984 
<a name="l06985"></a>06985                             phi[IJK(i,j,k)] = phix*phiy*phiz;
<a name="l06986"></a>06986 
<a name="l06987"></a>06987                         }
<a name="l06988"></a>06988                     }
<a name="l06989"></a>06989                 }
<a name="l06990"></a>06990 
<a name="l06991"></a>06991                 <span class="comment">/* Calculate the projection of the source function on this</span>
<a name="l06992"></a>06992 <span class="comment">                 * basis function */</span>
<a name="l06993"></a>06993                 proj = 0.0;
<a name="l06994"></a>06994                 <span class="keywordflow">for</span> (i=1; i&lt;(nx-1); i++) {
<a name="l06995"></a>06995                     <span class="keywordflow">for</span> (j=1; j&lt;(ny-1); j++) {
<a name="l06996"></a>06996                         <span class="keywordflow">for</span> (k=1; k&lt;(nz-1); k++) {
<a name="l06997"></a>06997 
<a name="l06998"></a>06998                             proj += f[IJK(i,j,k)]*phi[IJK(i,j,k)];
<a name="l06999"></a>06999 
<a name="l07000"></a>07000                         } <span class="comment">/* k loop */</span>
<a name="l07001"></a>07001                     } <span class="comment">/* j loop */</span>
<a name="l07002"></a>07002                 } <span class="comment">/* i loop */</span>
<a name="l07003"></a>07003 
<a name="l07004"></a>07004                 <span class="comment">/* Assemble the coefficient to weight the contribution of this</span>
<a name="l07005"></a>07005 <span class="comment">                 * basis function to the solution */</span>
<a name="l07006"></a>07006                 <span class="comment">/* The first contribution is the projection */</span>
<a name="l07007"></a>07007                 coef = proj;
<a name="l07008"></a>07008                 <span class="comment">/* The second contribution is the eigenvalue */</span>
<a name="l07009"></a>07009                 coef = coef/(eigx + eigy + eigz);
<a name="l07010"></a>07010                 <span class="comment">/* The third contribution is the normalization factor */</span>
<a name="l07011"></a>07011                 coef = (8.0/xlen/ylen/zlen)*coef;
<a name="l07012"></a>07012                 <span class="comment">/* The fourth contribution is from scaling the diagonal */</span>
<a name="l07013"></a>07013                 <span class="comment">/* coef = hx*hy*hzed*coef; */</span>
<a name="l07014"></a>07014 
<a name="l07015"></a>07015                 <span class="comment">/* Evaluate the basis function at each grid point */</span>
<a name="l07016"></a>07016                 <span class="keywordflow">for</span> (i=1; i&lt;(nx-1); i++) {
<a name="l07017"></a>07017                     <span class="keywordflow">for</span> (j=1; j&lt;(ny-1); j++) {
<a name="l07018"></a>07018                         <span class="keywordflow">for</span> (k=1; k&lt;(nz-1); k++) {
<a name="l07019"></a>07019 
<a name="l07020"></a>07020                             u[IJK(i,j,k)] += coef*phi[IJK(i,j,k)];
<a name="l07021"></a>07021 
<a name="l07022"></a>07022                         } <span class="comment">/* k loop */</span>
<a name="l07023"></a>07023                     } <span class="comment">/* j loop */</span>
<a name="l07024"></a>07024                 } <span class="comment">/* i loop */</span>
<a name="l07025"></a>07025 
<a name="l07026"></a>07026             } <span class="comment">/* kz loop */</span>
<a name="l07027"></a>07027         } <span class="comment">/* ky loop */</span>
<a name="l07028"></a>07028     } <span class="comment">/* kx loop */</span>
<a name="l07029"></a>07029 
<a name="l07030"></a>07030 }
<a name="l07031"></a>07031 
<a name="l07032"></a><a class="code" href="group___vpmg.html#ga4818d4f326a707af2f27b05161805c52">07032</a> VPUBLIC <span class="keywordtype">int</span> <a class="code" href="group___vpmg.html#ga4818d4f326a707af2f27b05161805c52" title="Solve Poisson&#39;s equation with a homogeneous Laplacian operator using the solvent dielectric constant...">Vpmg_solveLaplace</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l07033"></a>07033 
<a name="l07034"></a>07034     <span class="keywordtype">int</span> i, j, k, ijk, nx, ny, nz, n, dilo, dihi, djlo, djhi, dklo, dkhi;
<a name="l07035"></a>07035     <span class="keywordtype">double</span> hx, hy, hzed, epsw, iepsw, scal, scalx, scaly, scalz;
<a name="l07036"></a>07036 
<a name="l07037"></a>07037     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l07038"></a>07038     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l07039"></a>07039     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l07040"></a>07040     n = nx*ny*nz;
<a name="l07041"></a>07041     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l07042"></a>07042     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l07043"></a>07043     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l07044"></a>07044     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>);
<a name="l07045"></a>07045     iepsw = 1.0/epsw;
<a name="l07046"></a>07046     scal = hx*hy*hzed;
<a name="l07047"></a>07047     scalx = hx*hy/hzed;
<a name="l07048"></a>07048     scaly = hx*hzed/hy;
<a name="l07049"></a>07049     scalz = hx*hy/hzed;
<a name="l07050"></a>07050 
<a name="l07051"></a>07051     <span class="keywordflow">if</span> (!(thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>)) {
<a name="l07052"></a>07052         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_solve:  Need to call Vpmg_fillco()!\n&quot;</span>);
<a name="l07053"></a>07053         <span class="keywordflow">return</span> 0;
<a name="l07054"></a>07054     }
<a name="l07055"></a>07055 
<a name="l07056"></a>07056     <span class="comment">/* Load boundary conditions into the RHS array */</span>
<a name="l07057"></a>07057     <span class="keywordflow">for</span> (i=1; i&lt;(nx-1); i++) {
<a name="l07058"></a>07058 
<a name="l07059"></a>07059         <span class="keywordflow">if</span> (i == 1) dilo = 1;
<a name="l07060"></a>07060         <span class="keywordflow">else</span> dilo = 0;
<a name="l07061"></a>07061         <span class="keywordflow">if</span> (i == nx-2) dihi = 1;
<a name="l07062"></a>07062         <span class="keywordflow">else</span> dihi = 0;
<a name="l07063"></a>07063 
<a name="l07064"></a>07064         <span class="keywordflow">for</span> (j=1; j&lt;(ny-1); j++) {
<a name="l07065"></a>07065 
<a name="l07066"></a>07066             <span class="keywordflow">if</span> (j == 1) djlo = 1;
<a name="l07067"></a>07067             <span class="keywordflow">else</span> djlo = 0;
<a name="l07068"></a>07068             <span class="keywordflow">if</span> (j == ny-2) djhi = 1;
<a name="l07069"></a>07069             <span class="keywordflow">else</span> djhi = 0;
<a name="l07070"></a>07070 
<a name="l07071"></a>07071             <span class="keywordflow">for</span> (k=1; k&lt;(nz-1); k++) {
<a name="l07072"></a>07072 
<a name="l07073"></a>07073                 <span class="keywordflow">if</span> (k == 1) dklo = 1;
<a name="l07074"></a>07074                 <span class="keywordflow">else</span> dklo = 0;
<a name="l07075"></a>07075                 <span class="keywordflow">if</span> (k == nz-2) dkhi = 1;
<a name="l07076"></a>07076                 <span class="keywordflow">else</span> dkhi = 0;
<a name="l07077"></a>07077 
<a name="l07079"></a>07079                 thee-&gt;<a class="code" href="structs_vpmg.html#a52279f4736f2cd888d764c049517a68b">fcf</a>[IJK(i,j,k)] = \
<a name="l07080"></a>07080                       iepsw*scal*thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(i,j,k)] \
<a name="l07081"></a>07081                     + dilo*scalx*thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,0)] \
<a name="l07082"></a>07082                     + dihi*scalx*thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,1)] \
<a name="l07083"></a>07083                     + djlo*scaly*thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,0)] \
<a name="l07084"></a>07084                     + djhi*scaly*thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,1)] \
<a name="l07085"></a>07085                     + dklo*scalz*thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,0)] \
<a name="l07086"></a>07086                     + dkhi*scalz*thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,1)] ;
<a name="l07087"></a>07087 
<a name="l07088"></a>07088             }
<a name="l07089"></a>07089         }
<a name="l07090"></a>07090     }
<a name="l07091"></a>07091 
<a name="l07092"></a>07092     <span class="comment">/* Solve */</span>
<a name="l07093"></a>07093     <a class="code" href="vpmg_8c.html#a3667719ad7b6d35bb4ac587513be8b5c" title="Calculate the solution to Poisson&#39;s equation with a simple Laplacian operator and zero-valued Dirichl...">zlapSolve</a>( thee, &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a52279f4736f2cd888d764c049517a68b">fcf</a>), &amp;(thee-&gt;<a class="code" href="structs_vpmg.html#a4340bbd780d87a004aa32f56db41e63c">tcf</a>) );
<a name="l07094"></a>07094 
<a name="l07095"></a>07095     <span class="comment">/* Add boundary conditions to solution */</span>
<a name="l07096"></a>07096     <span class="comment">/* i faces */</span>
<a name="l07097"></a>07097     <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l07098"></a>07098         <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l07099"></a>07099             thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(0,j,k)] = thee-&gt;<a class="code" href="structs_vpmg.html#ade4e19b8d885c96c176c6625e965aaef">gxcf</a>[IJKx(j,k,0)];
<a name="l07100"></a>07100             thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(nx-1,j,k)] = thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKx(j,k,1)];
<a name="l07101"></a>07101         }
<a name="l07102"></a>07102     }
<a name="l07103"></a>07103     <span class="comment">/* j faces */</span>
<a name="l07104"></a>07104     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l07105"></a>07105         <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l07106"></a>07106             thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,0,k)] = thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,0)];
<a name="l07107"></a>07107             thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,ny-1,k)] = thee-&gt;<a class="code" href="structs_vpmg.html#a154aa335a0c87d6d7c8ed2c15323c3af">gycf</a>[IJKy(i,k,1)];
<a name="l07108"></a>07108         }
<a name="l07109"></a>07109     }
<a name="l07110"></a>07110     <span class="comment">/* k faces */</span>
<a name="l07111"></a>07111     <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l07112"></a>07112         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l07113"></a>07113             thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,0)] = thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,0)];
<a name="l07114"></a>07114             thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,nz-1)] = thee-&gt;<a class="code" href="structs_vpmg.html#afdd0523460568b764d76c7fef50f5c36">gzcf</a>[IJKz(i,j,1)];
<a name="l07115"></a>07115         }
<a name="l07116"></a>07116     }
<a name="l07117"></a>07117 
<a name="l07118"></a>07118     <span class="keywordflow">return</span> 1;
<a name="l07119"></a>07119 
<a name="l07120"></a>07120 }
<a name="l07121"></a>07121 
<a name="l07122"></a><a class="code" href="vpmg_8h.html#afcf864c3b65f0d536a2985d931dc4692">07122</a> VPRIVATE <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(<span class="keywordtype">int</span> i, <span class="keywordtype">double</span> f) {
<a name="l07123"></a>07123   <span class="keywordflow">return</span> (2.5+((<span class="keywordtype">double</span>)(i)-(f)));
<a name="l07124"></a>07124 }
<a name="l07125"></a>07125 
<a name="l07126"></a><a class="code" href="vpmg_8h.html#ac953c7091df8e4a1df53463baf8fe7ee">07126</a> VPRIVATE <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(<span class="keywordtype">double</span> x) {
<a name="l07127"></a>07127 
<a name="l07128"></a>07128     <span class="keywordtype">double</span> m, m2;
<a name="l07129"></a>07129     <span class="keyword">static</span> <span class="keywordtype">double</span> one6 = 1.0/6.0;
<a name="l07130"></a>07130     <span class="keyword">static</span> <span class="keywordtype">double</span> one8 = 1.0/8.0;
<a name="l07131"></a>07131     <span class="keyword">static</span> <span class="keywordtype">double</span> one24 = 1.0/24.0;
<a name="l07132"></a>07132     <span class="keyword">static</span> <span class="keywordtype">double</span> thirteen24 = 13.0/24.0;
<a name="l07133"></a>07133     <span class="keyword">static</span> <span class="keywordtype">double</span> fourtyseven24 = 47.0/24.0;
<a name="l07134"></a>07134     <span class="keyword">static</span> <span class="keywordtype">double</span> seventeen24 = 17.0/24.0;
<a name="l07135"></a>07135 
<a name="l07136"></a>07136     <span class="keywordflow">if</span> ((x &gt; 0.0) &amp;&amp; (x &lt;= 1.0)){
<a name="l07137"></a>07137       m = x*x;
<a name="l07138"></a>07138       <span class="keywordflow">return</span> one24*m*m;
<a name="l07139"></a>07139     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 1.0) &amp;&amp; (x &lt;= 2.0)){
<a name="l07140"></a>07140       m = x - 1.0;
<a name="l07141"></a>07141       m2 = m*m;
<a name="l07142"></a>07142       <span class="keywordflow">return</span> -one8 + one6*x + m2*(0.25 + one6*m - one6*m2);
<a name="l07143"></a>07143     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 2.0) &amp;&amp; (x &lt;= 3.0)){
<a name="l07144"></a>07144       m = x - 2.0;
<a name="l07145"></a>07145       m2 = m*m;
<a name="l07146"></a>07146       <span class="keywordflow">return</span> -thirteen24 + 0.5*x + m2*(-0.25 - 0.5*m + 0.25*m2);
<a name="l07147"></a>07147     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 3.0) &amp;&amp; (x &lt;= 4.0)){
<a name="l07148"></a>07148       m = x - 3.0;
<a name="l07149"></a>07149       m2 = m*m;
<a name="l07150"></a>07150       <span class="keywordflow">return</span> fourtyseven24 - 0.5*x + m2*(-0.25 + 0.5*m - one6*m2);
<a name="l07151"></a>07151     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 4.0) &amp;&amp; (x &lt;= 5.0)){
<a name="l07152"></a>07152       m = x - 4.0;
<a name="l07153"></a>07153       m2 = m*m;
<a name="l07154"></a>07154       <span class="keywordflow">return</span> seventeen24 - one6*x + m2*(0.25 - one6*m + one24*m2);
<a name="l07155"></a>07155     } <span class="keywordflow">else</span> {
<a name="l07156"></a>07156       <span class="keywordflow">return</span> 0.0;
<a name="l07157"></a>07157     }
<a name="l07158"></a>07158 }
<a name="l07159"></a>07159 
<a name="l07160"></a><a class="code" href="vpmg_8h.html#a91d1557ecff0ea7809aface06c0c179e">07160</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(<span class="keywordtype">double</span> x) {
<a name="l07161"></a>07161 
<a name="l07162"></a>07162     <span class="keywordtype">double</span> m, m2;
<a name="l07163"></a>07163     <span class="keyword">static</span> <span class="keywordtype">double</span> one6 = 1.0/6.0;
<a name="l07164"></a>07164     <span class="keyword">static</span> <span class="keywordtype">double</span> one3 = 1.0/3.0;
<a name="l07165"></a>07165     <span class="keyword">static</span> <span class="keywordtype">double</span> two3 = 2.0/3.0;
<a name="l07166"></a>07166     <span class="keyword">static</span> <span class="keywordtype">double</span> thirteen6 = 13.0/6.0;
<a name="l07167"></a>07167 
<a name="l07168"></a>07168     <span class="keywordflow">if</span> ((x &gt; 0.0) &amp;&amp; (x &lt;= 1.0)){
<a name="l07169"></a>07169       m2 = x*x;
<a name="l07170"></a>07170       <span class="keywordflow">return</span> one6*x*m2;
<a name="l07171"></a>07171     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 1.0) &amp;&amp; (x &lt;= 2.0)){
<a name="l07172"></a>07172       m = x - 1.0;
<a name="l07173"></a>07173       m2 = m*m;
<a name="l07174"></a>07174       <span class="keywordflow">return</span> -one3 + 0.5*x + m2*(0.5 - two3*m);
<a name="l07175"></a>07175     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 2.0) &amp;&amp; (x &lt;= 3.0)){
<a name="l07176"></a>07176       m = x - 2.0;
<a name="l07177"></a>07177       m2 = m*m;
<a name="l07178"></a>07178       <span class="keywordflow">return</span> 1.5 - 0.5*x + m2*(-1.5 + m);
<a name="l07179"></a>07179     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 3.0) &amp;&amp; (x &lt;= 4.0)){
<a name="l07180"></a>07180       m = x - 3.0;
<a name="l07181"></a>07181       m2 = m*m;
<a name="l07182"></a>07182       <span class="keywordflow">return</span> 1.0 - 0.5*x + m2*(1.5 - two3*m);
<a name="l07183"></a>07183     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 4.0) &amp;&amp; (x &lt;= 5.0)){
<a name="l07184"></a>07184       m = x - 4.0;
<a name="l07185"></a>07185       m2 = m*m;
<a name="l07186"></a>07186       <span class="keywordflow">return</span> -thirteen6 + 0.5*x + m2*(-0.5 + one6*m);
<a name="l07187"></a>07187     } <span class="keywordflow">else</span> {
<a name="l07188"></a>07188       <span class="keywordflow">return</span> 0.0;
<a name="l07189"></a>07189     }
<a name="l07190"></a>07190 }
<a name="l07191"></a>07191 
<a name="l07192"></a><a class="code" href="vpmg_8h.html#afa58365e9d16b810f6fe926558650108">07192</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(<span class="keywordtype">double</span> x) {
<a name="l07193"></a>07193 
<a name="l07194"></a>07194     <span class="keywordtype">double</span> m, m2;
<a name="l07195"></a>07195 
<a name="l07196"></a>07196     <span class="keywordflow">if</span> ((x &gt; 0.0) &amp;&amp; (x &lt;= 1.0)){
<a name="l07197"></a>07197       <span class="keywordflow">return</span> 0.5*x*x;
<a name="l07198"></a>07198     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 1.0) &amp;&amp; (x &lt;= 2.0)){
<a name="l07199"></a>07199       m = x - 1.0;
<a name="l07200"></a>07200       m2 = m*m;
<a name="l07201"></a>07201       <span class="keywordflow">return</span> -0.5 + x - 2.0*m2;
<a name="l07202"></a>07202     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 2.0) &amp;&amp; (x &lt;= 3.0)){
<a name="l07203"></a>07203       m = x - 2.0;
<a name="l07204"></a>07204       m2 = m*m;
<a name="l07205"></a>07205       <span class="keywordflow">return</span> 5.5 - 3.0*x + 3.0*m2;
<a name="l07206"></a>07206     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 3.0) &amp;&amp; (x &lt;= 4.0)){
<a name="l07207"></a>07207       m = x - 3.0;
<a name="l07208"></a>07208       m2 = m*m;
<a name="l07209"></a>07209       <span class="keywordflow">return</span> -9.5 + 3.0*x - 2.0*m2;
<a name="l07210"></a>07210     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 4.0) &amp;&amp; (x &lt;= 5.0)){
<a name="l07211"></a>07211       m = x - 4.0;
<a name="l07212"></a>07212       m2 = m*m;
<a name="l07213"></a>07213       <span class="keywordflow">return</span> 4.5 - x + 0.5*m2;
<a name="l07214"></a>07214     } <span class="keywordflow">else</span> {
<a name="l07215"></a>07215       <span class="keywordflow">return</span> 0.0;
<a name="l07216"></a>07216     }
<a name="l07217"></a>07217 }
<a name="l07218"></a>07218 
<a name="l07219"></a><a class="code" href="vpmg_8h.html#a1d34366ccb5b81c8d1ad1826aea7003e">07219</a> VPUBLIC <span class="keywordtype">double</span> <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(<span class="keywordtype">double</span> x) {
<a name="l07220"></a>07220 
<a name="l07221"></a>07221     <span class="keywordflow">if</span>      ((x &gt; 0.0) &amp;&amp; (x &lt;= 1.0)) <span class="keywordflow">return</span> x;
<a name="l07222"></a>07222     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 1.0) &amp;&amp; (x &lt;= 2.0)) <span class="keywordflow">return</span> 5.0 - 4.0 * x;
<a name="l07223"></a>07223     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 2.0) &amp;&amp; (x &lt;= 3.0)) <span class="keywordflow">return</span> -15.0 + 6.0 * x;
<a name="l07224"></a>07224     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 3.0) &amp;&amp; (x &lt;= 4.0)) <span class="keywordflow">return</span> 15.0 - 4.0 * x;
<a name="l07225"></a>07225     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x &gt; 4.0) &amp;&amp; (x &lt;= 5.0)) <span class="keywordflow">return</span> x - 5.0;
<a name="l07226"></a>07226     <span class="keywordflow">else</span>                              <span class="keywordflow">return</span> 0.0;
<a name="l07227"></a>07227 
<a name="l07228"></a>07228 }
<a name="l07229"></a>07229 
<a name="l07230"></a><a class="code" href="vpmg_8h.html#aa349fa04ad1c57df769345d4bcad28ce">07230</a> VPUBLIC <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#a45c2c05ddfc0c4e4aea3be668137d2e0" title="Fill source term charge array for the use of permanent multipoles.">fillcoPermanentMultipole</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l07231"></a>07231 
<a name="l07232"></a>07232     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l07233"></a>07233     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l07234"></a>07234     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l07235"></a>07235     <span class="comment">/* Coversions */</span>
<a name="l07236"></a>07236     <span class="keywordtype">double</span> zmagic, f;
<a name="l07237"></a>07237     <span class="comment">/* Grid */</span>
<a name="l07238"></a>07238     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax;
<a name="l07239"></a>07239     <span class="keywordtype">double</span> xlen, ylen, zlen, position[3], ifloat, jfloat, kfloat;
<a name="l07240"></a>07240     <span class="keywordtype">double</span> hx, hy, hzed, *apos;
<a name="l07241"></a>07241     <span class="comment">/* Multipole */</span>
<a name="l07242"></a>07242     <span class="keywordtype">double</span> charge, *dipole,*quad;
<a name="l07243"></a>07243     <span class="keywordtype">double</span> c,ux,uy,uz,qxx,qyx,qyy,qzx,qzy,qzz,qave;
<a name="l07244"></a>07244     <span class="comment">/* B-spline weights */</span>
<a name="l07245"></a>07245     <span class="keywordtype">double</span> mx,my,mz,dmx,dmy,dmz,d2mx,d2my,d2mz;
<a name="l07246"></a>07246     <span class="keywordtype">double</span> mi,mj,mk;
<a name="l07247"></a>07247     <span class="comment">/* Loop variables */</span>
<a name="l07248"></a>07248     <span class="keywordtype">int</span> i, ii, jj, kk, nx, ny, nz, iatom;
<a name="l07249"></a>07249     <span class="keywordtype">int</span> im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1, kp1, kp2;
<a name="l07250"></a>07250 
<a name="l07251"></a>07251     <span class="comment">/* sanity check */</span>
<a name="l07252"></a>07252     <span class="keywordtype">double</span> mir,mjr,mkr,mr2;
<a name="l07253"></a>07253     <span class="keywordtype">double</span> debye,mc,mux,muy,muz,mqxx,mqyx,mqyy,mqzx,mqzy,mqzz;
<a name="l07254"></a>07254 
<a name="l07255"></a>07255     VASSERT(thee != VNULL);
<a name="l07256"></a>07256 
<a name="l07257"></a>07257     <span class="comment">/* Get PBE info */</span>
<a name="l07258"></a>07258     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l07259"></a>07259     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l07260"></a>07260     zmagic = <a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l07261"></a>07261 
<a name="l07262"></a>07262     <span class="comment">/* Mesh info */</span>
<a name="l07263"></a>07263     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l07264"></a>07264     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l07265"></a>07265     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l07266"></a>07266     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l07267"></a>07267     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l07268"></a>07268     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l07269"></a>07269 
<a name="l07270"></a>07270     <span class="comment">/* Conversion */</span>
<a name="l07271"></a>07271     f = zmagic/(hx*hy*hzed);
<a name="l07272"></a>07272 
<a name="l07273"></a>07273     <span class="comment">/* Define the total domain size */</span>
<a name="l07274"></a>07274     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l07275"></a>07275     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l07276"></a>07276     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l07277"></a>07277 
<a name="l07278"></a>07278     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l07279"></a>07279     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l07280"></a>07280     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l07281"></a>07281     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l07282"></a>07282     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l07283"></a>07283     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l07284"></a>07284     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l07285"></a>07285 
<a name="l07286"></a>07286     <span class="comment">/* Fill in the source term (permanent atomic multipoles) */</span>
<a name="l07287"></a>07287     Vnm_print(0, <span class="stringliteral">&quot;fillcoPermanentMultipole:  filling in source term.\n&quot;</span>);
<a name="l07288"></a>07288     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l07289"></a>07289 
<a name="l07290"></a>07290         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l07291"></a>07291         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l07292"></a>07292 
<a name="l07293"></a>07293         c = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom)*f;
<a name="l07294"></a>07294 
<a name="l07295"></a>07295 <span class="preprocessor">#if defined(WITH_TINKER)</span>
<a name="l07296"></a>07296 <span class="preprocessor"></span>        dipole = Vatom_getDipole(atom);
<a name="l07297"></a>07297         ux = dipole[0]/hx*f;
<a name="l07298"></a>07298         uy = dipole[1]/hy*f;
<a name="l07299"></a>07299         uz = dipole[2]/hzed*f;
<a name="l07300"></a>07300         quad = Vatom_getQuadrupole(atom);
<a name="l07301"></a>07301         qxx = (1.0/3.0)*quad[0]/(hx*hx)*f;
<a name="l07302"></a>07302         qyx = (2.0/3.0)*quad[3]/(hx*hy)*f;
<a name="l07303"></a>07303         qyy = (1.0/3.0)*quad[4]/(hy*hy)*f;
<a name="l07304"></a>07304         qzx = (2.0/3.0)*quad[6]/(hzed*hx)*f;
<a name="l07305"></a>07305         qzy = (2.0/3.0)*quad[7]/(hzed*hy)*f;
<a name="l07306"></a>07306         qzz = (1.0/3.0)*quad[8]/(hzed*hzed)*f;
<a name="l07307"></a>07307 <span class="preprocessor">#else</span>
<a name="l07308"></a>07308 <span class="preprocessor"></span>        ux = 0.0;
<a name="l07309"></a>07309         uy = 0.0;
<a name="l07310"></a>07310         uz = 0.0;
<a name="l07311"></a>07311         qxx = 0.0;
<a name="l07312"></a>07312         qyx = 0.0;
<a name="l07313"></a>07313         qyy = 0.0;
<a name="l07314"></a>07314         qzx = 0.0;
<a name="l07315"></a>07315         qzy = 0.0;
<a name="l07316"></a>07316         qzz = 0.0;
<a name="l07317"></a>07317 <span class="preprocessor">#endif </span><span class="comment">/* if defined(WITH_TINKER) */</span>
<a name="l07318"></a>07318 
<a name="l07319"></a>07319         <span class="comment">/* check</span>
<a name="l07320"></a>07320 <span class="comment">        mc = 0.0;</span>
<a name="l07321"></a>07321 <span class="comment">        mux = 0.0;</span>
<a name="l07322"></a>07322 <span class="comment">        muy = 0.0;</span>
<a name="l07323"></a>07323 <span class="comment">        muz = 0.0;</span>
<a name="l07324"></a>07324 <span class="comment">        mqxx = 0.0;</span>
<a name="l07325"></a>07325 <span class="comment">        mqyx = 0.0;</span>
<a name="l07326"></a>07326 <span class="comment">        mqyy = 0.0;</span>
<a name="l07327"></a>07327 <span class="comment">        mqzx = 0.0;</span>
<a name="l07328"></a>07328 <span class="comment">        mqzy = 0.0;</span>
<a name="l07329"></a>07329 <span class="comment">        mqzz = 0.0; */</span>
<a name="l07330"></a>07330 
<a name="l07331"></a>07331         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l07332"></a>07332         <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin-2*hx)) || (apos[0]&gt;=(xmax+2*hx))  || \
<a name="l07333"></a>07333             (apos[1]&lt;=(ymin-2*hy)) || (apos[1]&gt;=(ymax+2*hy))  || \
<a name="l07334"></a>07334             (apos[2]&lt;=(zmin-2*hzed)) || (apos[2]&gt;=(zmax+2*hzed))) {
<a name="l07335"></a>07335             Vnm_print(2, <span class="stringliteral">&quot;fillcoPermanentMultipole: Atom #%d at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring this atom):\n&quot;</span>, iatom, apos[0], apos[1], apos[2]);
<a name="l07336"></a>07336             Vnm_print(2, <span class="stringliteral">&quot;fillcoPermanentMultipole: xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l07337"></a>07337             Vnm_print(2, <span class="stringliteral">&quot;fillcoPermanentMultipole: ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l07338"></a>07338             Vnm_print(2, <span class="stringliteral">&quot;fillcoPermanentMultipole: zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l07339"></a>07339             fflush(stderr);
<a name="l07340"></a>07340         } <span class="keywordflow">else</span> {
<a name="l07341"></a>07341 
<a name="l07342"></a>07342             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l07343"></a>07343             position[0] = apos[0] - xmin;
<a name="l07344"></a>07344             position[1] = apos[1] - ymin;
<a name="l07345"></a>07345             position[2] = apos[2] - zmin;
<a name="l07346"></a>07346 
<a name="l07347"></a>07347             <span class="comment">/* Figure out which vertices we&#39;re next to */</span>
<a name="l07348"></a>07348             ifloat = position[0]/hx;
<a name="l07349"></a>07349             jfloat = position[1]/hy;
<a name="l07350"></a>07350             kfloat = position[2]/hzed;
<a name="l07351"></a>07351 
<a name="l07352"></a>07352             ip1   = (int)ceil(ifloat);
<a name="l07353"></a>07353             ip2   = ip1 + 2;
<a name="l07354"></a>07354             im1   = (int)floor(ifloat);
<a name="l07355"></a>07355             im2   = im1 - 2;
<a name="l07356"></a>07356             jp1   = (int)ceil(jfloat);
<a name="l07357"></a>07357             jp2   = jp1 + 2;
<a name="l07358"></a>07358             jm1   = (int)floor(jfloat);
<a name="l07359"></a>07359             jm2   = jm1 - 2;
<a name="l07360"></a>07360             kp1   = (int)ceil(kfloat);
<a name="l07361"></a>07361             kp2   = kp1 + 2;
<a name="l07362"></a>07362             km1   = (int)floor(kfloat);
<a name="l07363"></a>07363             km2   = km1 - 2;
<a name="l07364"></a>07364 
<a name="l07365"></a>07365             <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l07366"></a>07366 <span class="comment">             * later on if something goes wrong */</span>
<a name="l07367"></a>07367             ip2 = VMIN2(ip2,nx-1);
<a name="l07368"></a>07368             ip1 = VMIN2(ip1,nx-1);
<a name="l07369"></a>07369             im1 = VMAX2(im1,0);
<a name="l07370"></a>07370             im2 = VMAX2(im2,0);
<a name="l07371"></a>07371             jp2 = VMIN2(jp2,ny-1);
<a name="l07372"></a>07372             jp1 = VMIN2(jp1,ny-1);
<a name="l07373"></a>07373             jm1 = VMAX2(jm1,0);
<a name="l07374"></a>07374             jm2 = VMAX2(jm2,0);
<a name="l07375"></a>07375             kp2 = VMIN2(kp2,nz-1);
<a name="l07376"></a>07376             kp1 = VMIN2(kp1,nz-1);
<a name="l07377"></a>07377             km1 = VMAX2(km1,0);
<a name="l07378"></a>07378             km2 = VMAX2(km2,0);
<a name="l07379"></a>07379 
<a name="l07380"></a>07380             <span class="comment">/* Now assign fractions of the charge to the nearby verts */</span>
<a name="l07381"></a>07381             <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l07382"></a>07382                 mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l07383"></a>07383                 mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l07384"></a>07384                 dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l07385"></a>07385                 d2mx = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mi);
<a name="l07386"></a>07386                 <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l07387"></a>07387                     mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l07388"></a>07388                     my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l07389"></a>07389                     dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l07390"></a>07390                     d2my = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mj);
<a name="l07391"></a>07391                     <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l07392"></a>07392                         mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l07393"></a>07393                         mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l07394"></a>07394                         dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l07395"></a>07395                         d2mz = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mk);
<a name="l07396"></a>07396                         charge = mx*my*mz*c -
<a name="l07397"></a>07397                          dmx*my*mz*ux - mx*dmy*mz*uy - mx*my*dmz*uz +
<a name="l07398"></a>07398                          d2mx*my*mz*qxx +
<a name="l07399"></a>07399                          dmx*dmy*mz*qyx + mx*d2my*mz*qyy +
<a name="l07400"></a>07400                          dmx*my*dmz*qzx + mx*dmy*dmz*qzy + mx*my*d2mz*qzz;
<a name="l07401"></a>07401                         thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ii,jj,kk)] += charge;
<a name="l07402"></a>07402 
<a name="l07403"></a>07403                         <span class="comment">/* sanity check - recalculate traceless multipoles</span>
<a name="l07404"></a>07404 <span class="comment">                           from the grid charge distribution for this</span>
<a name="l07405"></a>07405 <span class="comment">                           site.</span>
<a name="l07406"></a>07406 <span class="comment"></span>
<a name="l07407"></a>07407 <span class="comment">                        mir = (mi - 2.5) * hx;</span>
<a name="l07408"></a>07408 <span class="comment">                        mjr = (mj - 2.5) * hy;</span>
<a name="l07409"></a>07409 <span class="comment">                        mkr = (mk - 2.5) * hzed;</span>
<a name="l07410"></a>07410 <span class="comment">                        mr2 = mir*mir+mjr*mjr+mkr*mkr;</span>
<a name="l07411"></a>07411 <span class="comment">                        mc += charge;</span>
<a name="l07412"></a>07412 <span class="comment">                        mux += mir * charge;</span>
<a name="l07413"></a>07413 <span class="comment">                        muy += mjr * charge;</span>
<a name="l07414"></a>07414 <span class="comment">                        muz += mkr * charge;</span>
<a name="l07415"></a>07415 <span class="comment">                        mqxx += (1.5*mir*mir - 0.5*mr2) * charge;</span>
<a name="l07416"></a>07416 <span class="comment">                        mqyx += 1.5*mjr*mir * charge;</span>
<a name="l07417"></a>07417 <span class="comment">                        mqyy += (1.5*mjr*mjr - 0.5*mr2) * charge;</span>
<a name="l07418"></a>07418 <span class="comment">                        mqzx += 1.5*mkr*mir * charge;</span>
<a name="l07419"></a>07419 <span class="comment">                        mqzy += 1.5*mkr*mjr * charge;</span>
<a name="l07420"></a>07420 <span class="comment">                        mqzz += (1.5*mkr*mkr - 0.5*mr2) * charge;</span>
<a name="l07421"></a>07421 <span class="comment">                         */</span>
<a name="l07422"></a>07422                     }
<a name="l07423"></a>07423                 }
<a name="l07424"></a>07424             }
<a name="l07425"></a>07425         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l07426"></a>07426 
<a name="l07427"></a>07427         <span class="comment">/* print out the Grid vs. Ideal Point Multipole. */</span>
<a name="l07428"></a>07428 
<a name="l07429"></a>07429         <span class="comment">/*</span>
<a name="l07430"></a>07430 <span class="comment">        debye = 4.8033324;</span>
<a name="l07431"></a>07431 <span class="comment">        mc = mc/f;</span>
<a name="l07432"></a>07432 <span class="comment">        mux = mux/f*debye;</span>
<a name="l07433"></a>07433 <span class="comment">        muy = muy/f*debye;</span>
<a name="l07434"></a>07434 <span class="comment">        muz = muz/f*debye;</span>
<a name="l07435"></a>07435 <span class="comment">        mqxx = mqxx/f*debye;</span>
<a name="l07436"></a>07436 <span class="comment">        mqyy = mqyy/f*debye;</span>
<a name="l07437"></a>07437 <span class="comment">        mqzz = mqzz/f*debye;</span>
<a name="l07438"></a>07438 <span class="comment">        mqyx = mqyx/f*debye;</span>
<a name="l07439"></a>07439 <span class="comment">        mqzx = mqzx/f*debye;</span>
<a name="l07440"></a>07440 <span class="comment">        mqzy = mqzy/f*debye;</span>
<a name="l07441"></a>07441 <span class="comment"></span>
<a name="l07442"></a>07442 <span class="comment">        printf(&quot; Grid v. Actual Permanent Multipole for Site %i\n&quot;,iatom);</span>
<a name="l07443"></a>07443 <span class="comment">        printf(&quot; G: %10.6f\n&quot;,mc);</span>
<a name="l07444"></a>07444 <span class="comment">        printf(&quot; A: %10.6f\n\n&quot;,c/f);</span>
<a name="l07445"></a>07445 <span class="comment">        printf(&quot; G: %10.6f %10.6f %10.6f\n&quot;,mux,muy,muz);</span>
<a name="l07446"></a>07446 <span class="comment">        printf(&quot; A: %10.6f %10.6f %10.6f\n\n&quot;,</span>
<a name="l07447"></a>07447 <span class="comment">                 (ux * hx / f) * debye,</span>
<a name="l07448"></a>07448 <span class="comment">                 (uy * hy / f) * debye,</span>
<a name="l07449"></a>07449 <span class="comment">                 (uz * hzed /f) * debye);</span>
<a name="l07450"></a>07450 <span class="comment">        printf(&quot; G: %10.6f\n&quot;,mqxx);</span>
<a name="l07451"></a>07451 <span class="comment">        printf(&quot; A: %10.6f\n&quot;,quad[0]*debye);</span>
<a name="l07452"></a>07452 <span class="comment">        printf(&quot; G: %10.6f %10.6f\n&quot;,mqyx,mqyy);</span>
<a name="l07453"></a>07453 <span class="comment">        printf(&quot; A: %10.6f %10.6f\n&quot;,quad[3]*debye,quad[4]*debye);</span>
<a name="l07454"></a>07454 <span class="comment">        printf(&quot; G: %10.6f %10.6f %10.6f\n&quot;,mqzx,mqzy,mqzz);</span>
<a name="l07455"></a>07455 <span class="comment">        printf(&quot; A: %10.6f %10.6f %10.6f\n\n&quot;,</span>
<a name="l07456"></a>07456 <span class="comment">                quad[6]*debye,quad[7]*debye,quad[8]*debye);  */</span>
<a name="l07457"></a>07457 
<a name="l07458"></a>07458     } <span class="comment">/* endfor (each atom) */</span>
<a name="l07459"></a>07459 }
<a name="l07460"></a>07460 
<a name="l07461"></a>07461 <span class="preprocessor">#if defined(WITH_TINKER)</span>
<a name="l07462"></a>07462 <span class="preprocessor"></span>
<a name="l07463"></a>07463 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="vpmg_8h.html#ae84de46101d6abe2046ae860b55832a0" title="Fill source term charge array for use of induced dipoles.">fillcoInducedDipole</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l07464"></a>07464 
<a name="l07465"></a>07465     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l07466"></a>07466     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l07467"></a>07467     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l07468"></a>07468     <span class="comment">/* Conversions */</span>
<a name="l07469"></a>07469     <span class="keywordtype">double</span> zmagic, f;
<a name="l07470"></a>07470     <span class="comment">/* Grid */</span>
<a name="l07471"></a>07471     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax;
<a name="l07472"></a>07472     <span class="keywordtype">double</span> xlen, ylen, zlen, ifloat, jfloat, kfloat;
<a name="l07473"></a>07473     <span class="keywordtype">double</span> hx, hy, hzed, *apos, position[3];
<a name="l07474"></a>07474     <span class="comment">/* B-spline weights */</span>
<a name="l07475"></a>07475     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz;
<a name="l07476"></a>07476     <span class="comment">/* Dipole */</span>
<a name="l07477"></a>07477     <span class="keywordtype">double</span> charge, *dipole, ux,uy,uz;
<a name="l07478"></a>07478     <span class="keywordtype">double</span> mi,mj,mk;
<a name="l07479"></a>07479     <span class="comment">/* Loop indeces */</span>
<a name="l07480"></a>07480     <span class="keywordtype">int</span> i, ii, jj, kk, nx, ny, nz, iatom;
<a name="l07481"></a>07481     <span class="keywordtype">int</span> im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1, kp1, kp2;
<a name="l07482"></a>07482 
<a name="l07483"></a>07483     <span class="keywordtype">double</span> debye;
<a name="l07484"></a>07484     <span class="keywordtype">double</span> mux,muy,muz;
<a name="l07485"></a>07485     <span class="keywordtype">double</span> mir,mjr,mkr;
<a name="l07486"></a>07486 
<a name="l07487"></a>07487     VASSERT(thee != VNULL);
<a name="l07488"></a>07488 
<a name="l07489"></a>07489     <span class="comment">/* Get PBE info */</span>
<a name="l07490"></a>07490     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l07491"></a>07491     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l07492"></a>07492     zmagic = <a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l07493"></a>07493 
<a name="l07494"></a>07494     <span class="comment">/* Mesh info */</span>
<a name="l07495"></a>07495     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l07496"></a>07496     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l07497"></a>07497     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l07498"></a>07498     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l07499"></a>07499     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l07500"></a>07500     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l07501"></a>07501 
<a name="l07502"></a>07502     <span class="comment">/* Conversion */</span>
<a name="l07503"></a>07503     f = zmagic/(hx*hy*hzed);
<a name="l07504"></a>07504 
<a name="l07505"></a>07505     <span class="comment">/* Define the total domain size */</span>
<a name="l07506"></a>07506     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l07507"></a>07507     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l07508"></a>07508     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l07509"></a>07509 
<a name="l07510"></a>07510     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l07511"></a>07511     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l07512"></a>07512     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l07513"></a>07513     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l07514"></a>07514     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l07515"></a>07515     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l07516"></a>07516     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l07517"></a>07517 
<a name="l07518"></a>07518     <span class="comment">/* Fill in the source term (induced dipoles) */</span>
<a name="l07519"></a>07519     Vnm_print(0, <span class="stringliteral">&quot;fillcoInducedDipole:  filling in the source term.\n&quot;</span>);
<a name="l07520"></a>07520     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l07521"></a>07521 
<a name="l07522"></a>07522         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l07523"></a>07523         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l07524"></a>07524 
<a name="l07525"></a>07525         dipole = Vatom_getInducedDipole(atom);
<a name="l07526"></a>07526         ux = dipole[0]/hx*f;
<a name="l07527"></a>07527         uy = dipole[1]/hy*f;
<a name="l07528"></a>07528         uz = dipole[2]/hzed*f;
<a name="l07529"></a>07529 
<a name="l07530"></a>07530         mux = 0.0;
<a name="l07531"></a>07531         muy = 0.0;
<a name="l07532"></a>07532         muz = 0.0;
<a name="l07533"></a>07533 
<a name="l07534"></a>07534         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l07535"></a>07535         <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin-2*hx)) || (apos[0]&gt;=(xmax+2*hx))  || \
<a name="l07536"></a>07536             (apos[1]&lt;=(ymin-2*hy)) || (apos[1]&gt;=(ymax+2*hy))  || \
<a name="l07537"></a>07537             (apos[2]&lt;=(zmin-2*hzed)) || (apos[2]&gt;=(zmax+2*hzed))) {
<a name="l07538"></a>07538             Vnm_print(2, <span class="stringliteral">&quot;fillcoInducedDipole: Atom #%d at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring this atom):\n&quot;</span>, iatom, apos[0], apos[1], apos[2]);
<a name="l07539"></a>07539             Vnm_print(2, <span class="stringliteral">&quot;fillcoInducedDipole: xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l07540"></a>07540             Vnm_print(2, <span class="stringliteral">&quot;fillcoInducedDipole: ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l07541"></a>07541             Vnm_print(2, <span class="stringliteral">&quot;fillcoInducedDipole: zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l07542"></a>07542             fflush(stderr);
<a name="l07543"></a>07543         } <span class="keywordflow">else</span> {
<a name="l07544"></a>07544 
<a name="l07545"></a>07545             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l07546"></a>07546             position[0] = apos[0] - xmin;
<a name="l07547"></a>07547             position[1] = apos[1] - ymin;
<a name="l07548"></a>07548             position[2] = apos[2] - zmin;
<a name="l07549"></a>07549 
<a name="l07550"></a>07550             <span class="comment">/* Figure out which vertices we&#39;re next to */</span>
<a name="l07551"></a>07551             ifloat = position[0]/hx;
<a name="l07552"></a>07552             jfloat = position[1]/hy;
<a name="l07553"></a>07553             kfloat = position[2]/hzed;
<a name="l07554"></a>07554 
<a name="l07555"></a>07555             ip1   = (int)ceil(ifloat);
<a name="l07556"></a>07556             ip2   = ip1 + 2;
<a name="l07557"></a>07557             im1   = (int)floor(ifloat);
<a name="l07558"></a>07558             im2   = im1 - 2;
<a name="l07559"></a>07559             jp1   = (int)ceil(jfloat);
<a name="l07560"></a>07560             jp2   = jp1 + 2;
<a name="l07561"></a>07561             jm1   = (int)floor(jfloat);
<a name="l07562"></a>07562             jm2   = jm1 - 2;
<a name="l07563"></a>07563             kp1   = (int)ceil(kfloat);
<a name="l07564"></a>07564             kp2   = kp1 + 2;
<a name="l07565"></a>07565             km1   = (int)floor(kfloat);
<a name="l07566"></a>07566             km2   = km1 - 2;
<a name="l07567"></a>07567 
<a name="l07568"></a>07568             <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l07569"></a>07569 <span class="comment">             * later on if something goes wrong */</span>
<a name="l07570"></a>07570             ip2 = VMIN2(ip2,nx-1);
<a name="l07571"></a>07571             ip1 = VMIN2(ip1,nx-1);
<a name="l07572"></a>07572             im1 = VMAX2(im1,0);
<a name="l07573"></a>07573             im2 = VMAX2(im2,0);
<a name="l07574"></a>07574             jp2 = VMIN2(jp2,ny-1);
<a name="l07575"></a>07575             jp1 = VMIN2(jp1,ny-1);
<a name="l07576"></a>07576             jm1 = VMAX2(jm1,0);
<a name="l07577"></a>07577             jm2 = VMAX2(jm2,0);
<a name="l07578"></a>07578             kp2 = VMIN2(kp2,nz-1);
<a name="l07579"></a>07579             kp1 = VMIN2(kp1,nz-1);
<a name="l07580"></a>07580             km1 = VMAX2(km1,0);
<a name="l07581"></a>07581             km2 = VMAX2(km2,0);
<a name="l07582"></a>07582 
<a name="l07583"></a>07583             <span class="comment">/* Now assign fractions of the dipole to the nearby verts */</span>
<a name="l07584"></a>07584             <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l07585"></a>07585                 mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l07586"></a>07586                 mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l07587"></a>07587                 dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l07588"></a>07588                 <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l07589"></a>07589                     mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l07590"></a>07590                     my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l07591"></a>07591                     dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l07592"></a>07592                     <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l07593"></a>07593                         mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l07594"></a>07594                         mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l07595"></a>07595                         dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l07596"></a>07596                         charge = -dmx*my*mz*ux - mx*dmy*mz*uy - mx*my*dmz*uz;
<a name="l07597"></a>07597                         thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ii,jj,kk)] += charge;
<a name="l07598"></a>07598 
<a name="l07599"></a>07599                         <span class="comment">/*</span>
<a name="l07600"></a>07600 <span class="comment">                        mir = (mi - 2.5) * hx;</span>
<a name="l07601"></a>07601 <span class="comment">                        mjr = (mj - 2.5) * hy;</span>
<a name="l07602"></a>07602 <span class="comment">                        mkr = (mk - 2.5) * hzed;</span>
<a name="l07603"></a>07603 <span class="comment">                        mux += mir * charge;</span>
<a name="l07604"></a>07604 <span class="comment">                        muy += mjr * charge;</span>
<a name="l07605"></a>07605 <span class="comment">                        muz += mkr * charge;</span>
<a name="l07606"></a>07606 <span class="comment">                        */</span>
<a name="l07607"></a>07607                     }
<a name="l07608"></a>07608                 }
<a name="l07609"></a>07609             }
<a name="l07610"></a>07610         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l07611"></a>07611 
<a name="l07612"></a>07612         <span class="comment">/* check</span>
<a name="l07613"></a>07613 <span class="comment">        debye = 4.8033324;</span>
<a name="l07614"></a>07614 <span class="comment">        mux = mux/f*debye;</span>
<a name="l07615"></a>07615 <span class="comment">        muy = muy/f*debye;</span>
<a name="l07616"></a>07616 <span class="comment">        muz = muz/f*debye;</span>
<a name="l07617"></a>07617 <span class="comment"></span>
<a name="l07618"></a>07618 <span class="comment">        printf(&quot; Grid v. Actual Induced Dipole for Site %i\n&quot;,iatom);</span>
<a name="l07619"></a>07619 <span class="comment">        printf(&quot; G: %10.6f %10.6f %10.6f\n&quot;,mux,muy,muz);</span>
<a name="l07620"></a>07620 <span class="comment">        printf(&quot; A: %10.6f %10.6f %10.6f\n\n&quot;,</span>
<a name="l07621"></a>07621 <span class="comment">                 (ux * hx / f) * debye,</span>
<a name="l07622"></a>07622 <span class="comment">                 (uy * hy / f) * debye,</span>
<a name="l07623"></a>07623 <span class="comment">                 (uz * hzed /f) * debye);</span>
<a name="l07624"></a>07624 <span class="comment">         */</span>
<a name="l07625"></a>07625 
<a name="l07626"></a>07626     } <span class="comment">/* endfor (each atom) */</span>
<a name="l07627"></a>07627 }
<a name="l07628"></a>07628 
<a name="l07629"></a>07629 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="vpmg_8h.html#a6139befcbac10d86518d7b4cd397204a" title="Fill source term charge array for non-local induced dipoles.">fillcoNLInducedDipole</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l07630"></a>07630 
<a name="l07631"></a>07631     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l07632"></a>07632     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l07633"></a>07633     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l07634"></a>07634     <span class="comment">/* Conversions */</span>
<a name="l07635"></a>07635     <span class="keywordtype">double</span> zmagic, f;
<a name="l07636"></a>07636     <span class="comment">/* Grid */</span>
<a name="l07637"></a>07637     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax;
<a name="l07638"></a>07638     <span class="keywordtype">double</span> xlen, ylen, zlen, ifloat, jfloat, kfloat;
<a name="l07639"></a>07639     <span class="keywordtype">double</span> hx, hy, hzed, *apos, position[3];
<a name="l07640"></a>07640     <span class="comment">/* B-spline weights */</span>
<a name="l07641"></a>07641     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz;
<a name="l07642"></a>07642     <span class="comment">/* Dipole */</span>
<a name="l07643"></a>07643     <span class="keywordtype">double</span> charge, *dipole, ux,uy,uz;
<a name="l07644"></a>07644     <span class="keywordtype">double</span> mi,mj,mk;
<a name="l07645"></a>07645     <span class="comment">/* Loop indeces */</span>
<a name="l07646"></a>07646     <span class="keywordtype">int</span> i, ii, jj, kk, nx, ny, nz, iatom;
<a name="l07647"></a>07647     <span class="keywordtype">int</span> im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1, kp1, kp2;
<a name="l07648"></a>07648 
<a name="l07649"></a>07649     <span class="comment">/* sanity check</span>
<a name="l07650"></a>07650 <span class="comment">    double debye;</span>
<a name="l07651"></a>07651 <span class="comment">    double mux,muy,muz;</span>
<a name="l07652"></a>07652 <span class="comment">    double mir,mjr,mkr;</span>
<a name="l07653"></a>07653 <span class="comment">     */</span>
<a name="l07654"></a>07654 
<a name="l07655"></a>07655     VASSERT(thee != VNULL);
<a name="l07656"></a>07656 
<a name="l07657"></a>07657     <span class="comment">/* Get PBE info */</span>
<a name="l07658"></a>07658     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l07659"></a>07659     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l07660"></a>07660     zmagic = <a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l07661"></a>07661 
<a name="l07662"></a>07662     <span class="comment">/* Mesh info */</span>
<a name="l07663"></a>07663     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l07664"></a>07664     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l07665"></a>07665     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l07666"></a>07666     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l07667"></a>07667     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l07668"></a>07668     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l07669"></a>07669 
<a name="l07670"></a>07670     <span class="comment">/* Conversion */</span>
<a name="l07671"></a>07671     f = zmagic/(hx*hy*hzed);
<a name="l07672"></a>07672 
<a name="l07673"></a>07673     <span class="comment">/* Define the total domain size */</span>
<a name="l07674"></a>07674     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l07675"></a>07675     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l07676"></a>07676     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l07677"></a>07677 
<a name="l07678"></a>07678     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l07679"></a>07679     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l07680"></a>07680     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l07681"></a>07681     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l07682"></a>07682     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l07683"></a>07683     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l07684"></a>07684     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l07685"></a>07685 
<a name="l07686"></a>07686     <span class="comment">/* Fill in the source term (non-local induced dipoles) */</span>
<a name="l07687"></a>07687     Vnm_print(0, <span class="stringliteral">&quot;fillcoNLInducedDipole:  filling in source term.\n&quot;</span>);
<a name="l07688"></a>07688     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l07689"></a>07689 
<a name="l07690"></a>07690         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l07691"></a>07691         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l07692"></a>07692 
<a name="l07693"></a>07693         dipole = Vatom_getNLInducedDipole(atom);
<a name="l07694"></a>07694         ux = dipole[0]/hx*f;
<a name="l07695"></a>07695         uy = dipole[1]/hy*f;
<a name="l07696"></a>07696         uz = dipole[2]/hzed*f;
<a name="l07697"></a>07697 
<a name="l07698"></a>07698         <span class="comment">/*</span>
<a name="l07699"></a>07699 <span class="comment">        mux = 0.0;</span>
<a name="l07700"></a>07700 <span class="comment">        muy = 0.0;</span>
<a name="l07701"></a>07701 <span class="comment">        muz = 0.0;</span>
<a name="l07702"></a>07702 <span class="comment">         */</span>
<a name="l07703"></a>07703 
<a name="l07704"></a>07704         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l07705"></a>07705         <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin-2*hx)) || (apos[0]&gt;=(xmax+2*hx))  || \
<a name="l07706"></a>07706             (apos[1]&lt;=(ymin-2*hy)) || (apos[1]&gt;=(ymax+2*hy))  || \
<a name="l07707"></a>07707             (apos[2]&lt;=(zmin-2*hzed)) || (apos[2]&gt;=(zmax+2*hzed))) {
<a name="l07708"></a>07708             Vnm_print(2, <span class="stringliteral">&quot;fillcoNLInducedDipole: Atom #%d at (%4.3f, %4.3f,%4.3f) is off the mesh (ignoring this atom):\n&quot;</span>, iatom, apos[0], apos[1], apos[2]);
<a name="l07709"></a>07709             Vnm_print(2, <span class="stringliteral">&quot;fillcoNLInducedDipole: xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l07710"></a>07710             Vnm_print(2, <span class="stringliteral">&quot;fillcoNLInducedDipole: ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l07711"></a>07711             Vnm_print(2, <span class="stringliteral">&quot;fillcoNLInducedDipole: zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l07712"></a>07712             fflush(stderr);
<a name="l07713"></a>07713         } <span class="keywordflow">else</span> {
<a name="l07714"></a>07714 
<a name="l07715"></a>07715             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l07716"></a>07716             position[0] = apos[0] - xmin;
<a name="l07717"></a>07717             position[1] = apos[1] - ymin;
<a name="l07718"></a>07718             position[2] = apos[2] - zmin;
<a name="l07719"></a>07719 
<a name="l07720"></a>07720             <span class="comment">/* Figure out which vertices we&#39;re next to */</span>
<a name="l07721"></a>07721             ifloat = position[0]/hx;
<a name="l07722"></a>07722             jfloat = position[1]/hy;
<a name="l07723"></a>07723             kfloat = position[2]/hzed;
<a name="l07724"></a>07724 
<a name="l07725"></a>07725             ip1   = (int)ceil(ifloat);
<a name="l07726"></a>07726             ip2   = ip1 + 2;
<a name="l07727"></a>07727             im1   = (int)floor(ifloat);
<a name="l07728"></a>07728             im2   = im1 - 2;
<a name="l07729"></a>07729             jp1   = (int)ceil(jfloat);
<a name="l07730"></a>07730             jp2   = jp1 + 2;
<a name="l07731"></a>07731             jm1   = (int)floor(jfloat);
<a name="l07732"></a>07732             jm2   = jm1 - 2;
<a name="l07733"></a>07733             kp1   = (int)ceil(kfloat);
<a name="l07734"></a>07734             kp2   = kp1 + 2;
<a name="l07735"></a>07735             km1   = (int)floor(kfloat);
<a name="l07736"></a>07736             km2   = km1 - 2;
<a name="l07737"></a>07737 
<a name="l07738"></a>07738             <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l07739"></a>07739 <span class="comment">             * later on if something goes wrong */</span>
<a name="l07740"></a>07740             ip2 = VMIN2(ip2,nx-1);
<a name="l07741"></a>07741             ip1 = VMIN2(ip1,nx-1);
<a name="l07742"></a>07742             im1 = VMAX2(im1,0);
<a name="l07743"></a>07743             im2 = VMAX2(im2,0);
<a name="l07744"></a>07744             jp2 = VMIN2(jp2,ny-1);
<a name="l07745"></a>07745             jp1 = VMIN2(jp1,ny-1);
<a name="l07746"></a>07746             jm1 = VMAX2(jm1,0);
<a name="l07747"></a>07747             jm2 = VMAX2(jm2,0);
<a name="l07748"></a>07748             kp2 = VMIN2(kp2,nz-1);
<a name="l07749"></a>07749             kp1 = VMIN2(kp1,nz-1);
<a name="l07750"></a>07750             km1 = VMAX2(km1,0);
<a name="l07751"></a>07751             km2 = VMAX2(km2,0);
<a name="l07752"></a>07752 
<a name="l07753"></a>07753             <span class="comment">/* Now assign fractions of the non local induced dipole</span>
<a name="l07754"></a>07754 <span class="comment">               to the nearby verts */</span>
<a name="l07755"></a>07755             <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l07756"></a>07756                 mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l07757"></a>07757                 mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l07758"></a>07758                 dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l07759"></a>07759                 <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l07760"></a>07760                     mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l07761"></a>07761                     my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l07762"></a>07762                     dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l07763"></a>07763                     <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l07764"></a>07764                         mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l07765"></a>07765                         mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l07766"></a>07766                         dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l07767"></a>07767                         charge = -dmx*my*mz*ux - mx*dmy*mz*uy - mx*my*dmz*uz;
<a name="l07768"></a>07768                         thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ii,jj,kk)] += charge;
<a name="l07769"></a>07769 
<a name="l07770"></a>07770                         <span class="comment">/*</span>
<a name="l07771"></a>07771 <span class="comment">                        mir = (mi - 2.5) * hx;</span>
<a name="l07772"></a>07772 <span class="comment">                        mjr = (mj - 2.5) * hy;</span>
<a name="l07773"></a>07773 <span class="comment">                        mkr = (mk - 2.5) * hzed;</span>
<a name="l07774"></a>07774 <span class="comment">                        mux += mir * charge;</span>
<a name="l07775"></a>07775 <span class="comment">                        muy += mjr * charge;</span>
<a name="l07776"></a>07776 <span class="comment">                        muz += mkr * charge;</span>
<a name="l07777"></a>07777 <span class="comment">                         */</span>
<a name="l07778"></a>07778                     }
<a name="l07779"></a>07779                 }
<a name="l07780"></a>07780             }
<a name="l07781"></a>07781         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l07782"></a>07782 
<a name="l07783"></a>07783         <span class="comment">/*</span>
<a name="l07784"></a>07784 <span class="comment">        debye = 4.8033324;</span>
<a name="l07785"></a>07785 <span class="comment">        mux = mux/f*debye;</span>
<a name="l07786"></a>07786 <span class="comment">        muy = muy/f*debye;</span>
<a name="l07787"></a>07787 <span class="comment">        muz = muz/f*debye;</span>
<a name="l07788"></a>07788 <span class="comment"></span>
<a name="l07789"></a>07789 <span class="comment">        printf(&quot; Grid v. Actual Non-Local Induced Dipole for Site %i\n&quot;,iatom);</span>
<a name="l07790"></a>07790 <span class="comment">        printf(&quot; G: %10.6f %10.6f %10.6f\n&quot;,mux,muy,muz);</span>
<a name="l07791"></a>07791 <span class="comment">        printf(&quot; A: %10.6f %10.6f %10.6f\n\n&quot;,</span>
<a name="l07792"></a>07792 <span class="comment">                 (ux * hx / f) * debye,</span>
<a name="l07793"></a>07793 <span class="comment">                 (uy * hy / f) * debye,</span>
<a name="l07794"></a>07794 <span class="comment">                 (uz * hzed /f) * debye); */</span>
<a name="l07795"></a>07795 
<a name="l07796"></a>07796     } <span class="comment">/* endfor (each atom) */</span>
<a name="l07797"></a>07797 }
<a name="l07798"></a>07798 
<a name="l07799"></a>07799 VPUBLIC <span class="keywordtype">double</span> <a class="code" href="group___vpmg.html#ga206a127cf0431a06eb196f6c21ea0d88" title="Computes the permanent multipole electrostatic hydration energy (the polarization component of the hy...">Vpmg_qfPermanentMultipoleEnergy</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">int</span> atomID) {
<a name="l07800"></a>07800 
<a name="l07801"></a>07801     <span class="keywordtype">double</span> *u;
<a name="l07802"></a>07802     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l07803"></a>07803     <span class="comment">/* Grid variables */</span>
<a name="l07804"></a>07804     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l07805"></a>07805     <span class="keywordtype">double</span> xmax, xmin, ymax, ymin, zmax, zmin;
<a name="l07806"></a>07806     <span class="keywordtype">double</span> hx, hy, hzed, ifloat, jfloat, kfloat;
<a name="l07807"></a>07807     <span class="keywordtype">double</span> mi, mj, mk;
<a name="l07808"></a>07808     <span class="keywordtype">double</span> *position;
<a name="l07809"></a>07809     <span class="comment">/* B-spline weights */</span>
<a name="l07810"></a>07810     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz, d2mx, d2my, d2mz;
<a name="l07811"></a>07811     <span class="comment">/* Loop indeces */</span>
<a name="l07812"></a>07812     <span class="keywordtype">int</span> ip1,ip2,im1,im2,jp1,jp2,jm1,jm2,kp1,kp2,km1,km2;
<a name="l07813"></a>07813     <span class="keywordtype">int</span> i,j,ii,jj,kk;
<a name="l07814"></a>07814     <span class="comment">/* Potential, field, field gradient and multipole components */</span>
<a name="l07815"></a>07815     <span class="keywordtype">double</span> pot, rfe[3], rfde[3][3], energy;
<a name="l07816"></a>07816     <span class="keywordtype">double</span> f, charge, *dipole, *quad;
<a name="l07817"></a>07817     <span class="keywordtype">double</span> qxx, qyx, qyy, qzx, qzy, qzz;
<a name="l07818"></a>07818 
<a name="l07819"></a>07819 
<a name="l07820"></a>07820     VASSERT(thee != VNULL);
<a name="l07821"></a>07821     VASSERT(thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>);
<a name="l07822"></a>07822 
<a name="l07823"></a>07823     <span class="comment">/* Get the mesh information */</span>
<a name="l07824"></a>07824     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l07825"></a>07825     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l07826"></a>07826     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l07827"></a>07827     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l07828"></a>07828     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l07829"></a>07829     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l07830"></a>07830     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[nx-1];
<a name="l07831"></a>07831     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[ny-1];
<a name="l07832"></a>07832     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[nz-1];
<a name="l07833"></a>07833     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[0];
<a name="l07834"></a>07834     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[0];
<a name="l07835"></a>07835     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[0];
<a name="l07836"></a>07836 
<a name="l07837"></a>07837     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l07838"></a>07838 
<a name="l07839"></a>07839     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l07840"></a>07840 
<a name="l07841"></a>07841     <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l07842"></a>07842 
<a name="l07843"></a>07843     VASSERT(atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);
<a name="l07844"></a>07844 
<a name="l07845"></a>07845     <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l07846"></a>07846 
<a name="l07847"></a>07847     position = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l07848"></a>07848     ifloat = (position[0] - xmin)/hx;
<a name="l07849"></a>07849     jfloat = (position[1] - ymin)/hy;
<a name="l07850"></a>07850     kfloat = (position[2] - zmin)/hzed;
<a name="l07851"></a>07851     ip1 = (int)ceil(ifloat);
<a name="l07852"></a>07852     ip2 = ip1 + 2;
<a name="l07853"></a>07853     im1 = (int)floor(ifloat);
<a name="l07854"></a>07854     im2 = im1 - 2;
<a name="l07855"></a>07855     jp1 = (int)ceil(jfloat);
<a name="l07856"></a>07856     jp2 = jp1 + 2;
<a name="l07857"></a>07857     jm1 = (int)floor(jfloat);
<a name="l07858"></a>07858     jm2 = jm1 - 2;
<a name="l07859"></a>07859     kp1 = (int)ceil(kfloat);
<a name="l07860"></a>07860     kp2 = kp1 + 2;
<a name="l07861"></a>07861     km1 = (int)floor(kfloat);
<a name="l07862"></a>07862     km2 = km1 - 2;
<a name="l07863"></a>07863 
<a name="l07864"></a>07864     <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l07865"></a>07865 <span class="comment">     * later on if something goes wrong */</span>
<a name="l07866"></a>07866     ip2 = VMIN2(ip2,nx-1);
<a name="l07867"></a>07867     ip1 = VMIN2(ip1,nx-1);
<a name="l07868"></a>07868     im1 = VMAX2(im1,0);
<a name="l07869"></a>07869     im2 = VMAX2(im2,0);
<a name="l07870"></a>07870     jp2 = VMIN2(jp2,ny-1);
<a name="l07871"></a>07871     jp1 = VMIN2(jp1,ny-1);
<a name="l07872"></a>07872     jm1 = VMAX2(jm1,0);
<a name="l07873"></a>07873     jm2 = VMAX2(jm2,0);
<a name="l07874"></a>07874     kp2 = VMIN2(kp2,nz-1);
<a name="l07875"></a>07875     kp1 = VMIN2(kp1,nz-1);
<a name="l07876"></a>07876     km1 = VMAX2(km1,0);
<a name="l07877"></a>07877     km2 = VMAX2(km2,0);
<a name="l07878"></a>07878 
<a name="l07879"></a>07879     <span class="comment">/* Initialize observables to zero */</span>
<a name="l07880"></a>07880     energy = 0.0;
<a name="l07881"></a>07881     pot = 0.0;
<a name="l07882"></a>07882     <span class="keywordflow">for</span> (i=0;i&lt;3;i++){
<a name="l07883"></a>07883        rfe[i] = 0.0;
<a name="l07884"></a>07884        <span class="keywordflow">for</span> (j=0;j&lt;3;j++){
<a name="l07885"></a>07885          rfde[i][j] = 0.0;
<a name="l07886"></a>07886        }
<a name="l07887"></a>07887     }
<a name="l07888"></a>07888 
<a name="l07889"></a>07889     <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l07890"></a>07890       mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l07891"></a>07891       mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l07892"></a>07892       dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l07893"></a>07893       d2mx = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mi);
<a name="l07894"></a>07894       <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l07895"></a>07895         mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l07896"></a>07896         my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l07897"></a>07897         dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l07898"></a>07898         d2my = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mj);
<a name="l07899"></a>07899         <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l07900"></a>07900           mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l07901"></a>07901           mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l07902"></a>07902           dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l07903"></a>07903           d2mz = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mk);
<a name="l07904"></a>07904           f = u[IJK(ii,jj,kk)];
<a name="l07905"></a>07905           <span class="comment">/* potential */</span>
<a name="l07906"></a>07906           pot  += f*mx*my*mz;
<a name="l07907"></a>07907           <span class="comment">/* field */</span>
<a name="l07908"></a>07908           rfe[0] += f*dmx*my*mz/hx;
<a name="l07909"></a>07909           rfe[1] += f*mx*dmy*mz/hy;
<a name="l07910"></a>07910           rfe[2] += f*mx*my*dmz/hzed;
<a name="l07911"></a>07911           <span class="comment">/* field gradient */</span>
<a name="l07912"></a>07912           rfde[0][0] += f*d2mx*my*mz/(hx*hx);
<a name="l07913"></a>07913           rfde[1][0] += f*dmx*dmy*mz/(hy*hx);
<a name="l07914"></a>07914           rfde[1][1] += f*mx*d2my*mz/(hy*hy);
<a name="l07915"></a>07915           rfde[2][0] += f*dmx*my*dmz/(hx*hzed);
<a name="l07916"></a>07916           rfde[2][1] += f*mx*dmy*dmz/(hy*hzed);
<a name="l07917"></a>07917           rfde[2][2] += f*mx*my*d2mz/(hzed*hzed);
<a name="l07918"></a>07918         }
<a name="l07919"></a>07919       }
<a name="l07920"></a>07920     }
<a name="l07921"></a>07921 
<a name="l07922"></a>07922     charge = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l07923"></a>07923     dipole = Vatom_getDipole(atom);
<a name="l07924"></a>07924     quad = Vatom_getQuadrupole(atom);
<a name="l07925"></a>07925     qxx = quad[0]/3.0;
<a name="l07926"></a>07926     qyx = quad[3]/3.0;
<a name="l07927"></a>07927     qyy = quad[4]/3.0;
<a name="l07928"></a>07928     qzx = quad[6]/3.0;
<a name="l07929"></a>07929     qzy = quad[7]/3.0;
<a name="l07930"></a>07930     qzz = quad[8]/3.0;
<a name="l07931"></a>07931 
<a name="l07932"></a>07932     energy =   pot * charge
<a name="l07933"></a>07933              - rfe[0] * dipole[0]
<a name="l07934"></a>07934              - rfe[1] * dipole[1]
<a name="l07935"></a>07935              - rfe[2] * dipole[2]
<a name="l07936"></a>07936              +     rfde[0][0]*qxx
<a name="l07937"></a>07937              + 2.0*rfde[1][0]*qyx +     rfde[1][1]*qyy
<a name="l07938"></a>07938              + 2.0*rfde[2][0]*qzx + 2.0*rfde[2][1]*qzy + rfde[2][2]*qzz;
<a name="l07939"></a>07939 
<a name="l07940"></a>07940     <span class="keywordflow">return</span> energy;
<a name="l07941"></a>07941 }
<a name="l07942"></a>07942 
<a name="l07943"></a>07943 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gad5c70d5a39760387658c5eb1eae982b6" title="Computes the field at an atomic center using a stencil based on the first derivative of a 5th order B...">Vpmg_fieldSpline4</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> field[3]) {
<a name="l07944"></a>07944 
<a name="l07945"></a>07945     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l07946"></a>07946     <span class="keywordtype">double</span> *u, f;
<a name="l07947"></a>07947     <span class="comment">/* Grid variables */</span>
<a name="l07948"></a>07948     <span class="keywordtype">int</span> nx, ny, nz;
<a name="l07949"></a>07949     <span class="keywordtype">double</span> xmax, xmin, ymax, ymin, zmax, zmin;
<a name="l07950"></a>07950     <span class="keywordtype">double</span> hx, hy, hzed, ifloat, jfloat, kfloat;
<a name="l07951"></a>07951     <span class="keywordtype">double</span> *apos, position[3];
<a name="l07952"></a>07952     <span class="comment">/* B-Spline weights */</span>
<a name="l07953"></a>07953     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz;
<a name="l07954"></a>07954     <span class="keywordtype">double</span> mi, mj, mk;
<a name="l07955"></a>07955     <span class="comment">/* Loop indeces */</span>
<a name="l07956"></a>07956     <span class="keywordtype">int</span> ip1,ip2,im1,im2,jp1,jp2,jm1,jm2,kp1,kp2,km1,km2;
<a name="l07957"></a>07957     <span class="keywordtype">int</span> i,j,ii,jj,kk;
<a name="l07958"></a>07958 
<a name="l07959"></a>07959 
<a name="l07960"></a>07960     VASSERT (thee != VNULL);
<a name="l07961"></a>07961 
<a name="l07962"></a>07962     <span class="comment">/* Get the mesh information */</span>
<a name="l07963"></a>07963     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l07964"></a>07964     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l07965"></a>07965     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l07966"></a>07966     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l07967"></a>07967     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l07968"></a>07968     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l07969"></a>07969     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[nx-1];
<a name="l07970"></a>07970     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[ny-1];
<a name="l07971"></a>07971     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[nz-1];
<a name="l07972"></a>07972     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a9cda7e2ef5f9819681ad21169e634b50">xf</a>[0];
<a name="l07973"></a>07973     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#aa9be8f69beee9575709bbd17359770d2">yf</a>[0];
<a name="l07974"></a>07974     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#af01f76bc6c1d3036fb6be6c6c5804f35">zf</a>[0];
<a name="l07975"></a>07975 
<a name="l07976"></a>07976     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l07977"></a>07977 
<a name="l07978"></a>07978     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l07979"></a>07979 
<a name="l07980"></a>07980     <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l07981"></a>07981 
<a name="l07982"></a>07982     VASSERT (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);
<a name="l07983"></a>07983 
<a name="l07984"></a>07984     <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l07985"></a>07985 
<a name="l07986"></a>07986     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l07987"></a>07987     position[0] = apos[0] - xmin;
<a name="l07988"></a>07988     position[1] = apos[1] - ymin;
<a name="l07989"></a>07989     position[2] = apos[2] - zmin;
<a name="l07990"></a>07990     ifloat = position[0]/hx;
<a name="l07991"></a>07991     jfloat = position[1]/hy;
<a name="l07992"></a>07992     kfloat = position[2]/hzed;
<a name="l07993"></a>07993     ip1 = (int)ceil(ifloat);
<a name="l07994"></a>07994     ip2 = ip1 + 2;
<a name="l07995"></a>07995     im1 = (int)floor(ifloat);
<a name="l07996"></a>07996     im2 = im1 - 2;
<a name="l07997"></a>07997     jp1 = (int)ceil(jfloat);
<a name="l07998"></a>07998     jp2 = jp1 + 2;
<a name="l07999"></a>07999     jm1 = (int)floor(jfloat);
<a name="l08000"></a>08000     jm2 = jm1 - 2;
<a name="l08001"></a>08001     kp1 = (int)ceil(kfloat);
<a name="l08002"></a>08002     kp2 = kp1 + 2;
<a name="l08003"></a>08003     km1 = (int)floor(kfloat);
<a name="l08004"></a>08004     km2 = km1 - 2;
<a name="l08005"></a>08005 
<a name="l08006"></a>08006     <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l08007"></a>08007 <span class="comment">     * later on if something goes wrong */</span>
<a name="l08008"></a>08008     ip2 = VMIN2(ip2,nx-1);
<a name="l08009"></a>08009     ip1 = VMIN2(ip1,nx-1);
<a name="l08010"></a>08010     im1 = VMAX2(im1,0);
<a name="l08011"></a>08011     im2 = VMAX2(im2,0);
<a name="l08012"></a>08012     jp2 = VMIN2(jp2,ny-1);
<a name="l08013"></a>08013     jp1 = VMIN2(jp1,ny-1);
<a name="l08014"></a>08014     jm1 = VMAX2(jm1,0);
<a name="l08015"></a>08015     jm2 = VMAX2(jm2,0);
<a name="l08016"></a>08016     kp2 = VMIN2(kp2,nz-1);
<a name="l08017"></a>08017     kp1 = VMIN2(kp1,nz-1);
<a name="l08018"></a>08018     km1 = VMAX2(km1,0);
<a name="l08019"></a>08019     km2 = VMAX2(km2,0);
<a name="l08020"></a>08020 
<a name="l08021"></a>08021     <span class="keywordflow">for</span> (i=0;i&lt;3;i++){
<a name="l08022"></a>08022        field[i] = 0.0;
<a name="l08023"></a>08023     }
<a name="l08024"></a>08024 
<a name="l08025"></a>08025     <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l08026"></a>08026       mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l08027"></a>08027       mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l08028"></a>08028       dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l08029"></a>08029       <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l08030"></a>08030         mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l08031"></a>08031         my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l08032"></a>08032         dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l08033"></a>08033         <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l08034"></a>08034           mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l08035"></a>08035           mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l08036"></a>08036           dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l08037"></a>08037           f = u[IJK(ii,jj,kk)];
<a name="l08038"></a>08038 
<a name="l08039"></a>08039           field[0] += f*dmx*my*mz/hx;
<a name="l08040"></a>08040           field[1] += f*mx*dmy*mz/hy;
<a name="l08041"></a>08041           field[2] += f*mx*my*dmz/hzed;
<a name="l08042"></a>08042         }
<a name="l08043"></a>08043       }
<a name="l08044"></a>08044     }
<a name="l08045"></a>08045 }
<a name="l08046"></a>08046 
<a name="l08047"></a>08047 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga419834e619beb42dcaf3f9280b1e8085" title="Computes the q-Phi Force for permanent multipoles based on 5th order B-splines.">Vpmg_qfPermanentMultipoleForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">int</span> atomID,
<a name="l08048"></a>08048                                            <span class="keywordtype">double</span> force[3], <span class="keywordtype">double</span> torque[3]) {
<a name="l08049"></a>08049 
<a name="l08050"></a>08050     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l08051"></a>08051     <span class="keywordtype">double</span> f, *u, *apos, position[3];
<a name="l08052"></a>08052 
<a name="l08053"></a>08053     <span class="comment">/* Grid variables */</span>
<a name="l08054"></a>08054     <span class="keywordtype">int</span> nx,ny,nz;
<a name="l08055"></a>08055     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax;
<a name="l08056"></a>08056     <span class="keywordtype">double</span> hx, hy, hzed, ifloat, jfloat, kfloat;
<a name="l08057"></a>08057 
<a name="l08058"></a>08058     <span class="comment">/* B-spline weights */</span>
<a name="l08059"></a>08059     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz, d2mx, d2my, d2mz, d3mx, d3my, d3mz;
<a name="l08060"></a>08060     <span class="keywordtype">double</span> mi, mj, mk;
<a name="l08061"></a>08061 
<a name="l08062"></a>08062     <span class="comment">/* Loop indeces */</span>
<a name="l08063"></a>08063     <span class="keywordtype">int</span> i, j, k, ii, jj, kk;
<a name="l08064"></a>08064     <span class="keywordtype">int</span> im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1, kp1, kp2;
<a name="l08065"></a>08065 
<a name="l08066"></a>08066     <span class="comment">/* Potential, field, field gradient and 2nd field gradient */</span>
<a name="l08067"></a>08067     <span class="keywordtype">double</span> pot, e[3], de[3][3], d2e[3][3][3];
<a name="l08068"></a>08068 
<a name="l08069"></a>08069     <span class="comment">/* Permanent multipole components */</span>
<a name="l08070"></a>08070     <span class="keywordtype">double</span> *dipole, *quad;
<a name="l08071"></a>08071     <span class="keywordtype">double</span> c, ux, uy, uz, qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz;
<a name="l08072"></a>08072 
<a name="l08073"></a>08073     VASSERT(thee != VNULL);
<a name="l08074"></a>08074     VASSERT(thee-&gt;<a class="code" href="structs_vpmg.html#a3e3b491c1a251ff986d5e5536bbd5f15">filled</a>);
<a name="l08075"></a>08075 
<a name="l08076"></a>08076     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l08077"></a>08077 
<a name="l08078"></a>08078     <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l08079"></a>08079 
<a name="l08080"></a>08080     VASSERT(atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);
<a name="l08081"></a>08081 
<a name="l08082"></a>08082     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l08083"></a>08083 
<a name="l08084"></a>08084     c = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l08085"></a>08085     dipole = Vatom_getDipole(atom);
<a name="l08086"></a>08086     ux = dipole[0];
<a name="l08087"></a>08087     uy = dipole[1];
<a name="l08088"></a>08088     uz = dipole[2];
<a name="l08089"></a>08089     quad = Vatom_getQuadrupole(atom);
<a name="l08090"></a>08090     qxx = quad[0]/3.0;
<a name="l08091"></a>08091     qxy = quad[1]/3.0;
<a name="l08092"></a>08092     qxz = quad[2]/3.0;
<a name="l08093"></a>08093     qyx = quad[3]/3.0;
<a name="l08094"></a>08094     qyy = quad[4]/3.0;
<a name="l08095"></a>08095     qyz = quad[5]/3.0;
<a name="l08096"></a>08096     qzx = quad[6]/3.0;
<a name="l08097"></a>08097     qzy = quad[7]/3.0;
<a name="l08098"></a>08098     qzz = quad[8]/3.0;
<a name="l08099"></a>08099 
<a name="l08100"></a>08100     <span class="comment">/* Initialize observables */</span>
<a name="l08101"></a>08101     pot = 0.0;
<a name="l08102"></a>08102     <span class="keywordflow">for</span> (i=0;i&lt;3;i++){
<a name="l08103"></a>08103        e[i] = 0.0;
<a name="l08104"></a>08104        <span class="keywordflow">for</span> (j=0;j&lt;3;j++){
<a name="l08105"></a>08105           de[i][j] = 0.0;
<a name="l08106"></a>08106           <span class="keywordflow">for</span> (k=0;k&lt;3;k++){
<a name="l08107"></a>08107              d2e[i][j][k] = 0.0;
<a name="l08108"></a>08108           }
<a name="l08109"></a>08109        }
<a name="l08110"></a>08110     }
<a name="l08111"></a>08111 
<a name="l08112"></a>08112     <span class="comment">/* Mesh info */</span>
<a name="l08113"></a>08113     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l08114"></a>08114     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l08115"></a>08115     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l08116"></a>08116     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l08117"></a>08117     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l08118"></a>08118     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l08119"></a>08119     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l08120"></a>08120     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l08121"></a>08121     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l08122"></a>08122     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l08123"></a>08123     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l08124"></a>08124     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l08125"></a>08125     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l08126"></a>08126     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l08127"></a>08127     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l08128"></a>08128     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l08129"></a>08129 
<a name="l08130"></a>08130     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l08131"></a>08131     <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin+2*hx))   || (apos[0]&gt;=(xmax-2*hx)) \
<a name="l08132"></a>08132      || (apos[1]&lt;=(ymin+2*hy))   || (apos[1]&gt;=(ymax-2*hy)) \
<a name="l08133"></a>08133      || (apos[2]&lt;=(zmin+2*hzed)) || (apos[2]&gt;=(zmax-2*hzed))) {
<a name="l08134"></a>08134         Vnm_print(2, <span class="stringliteral">&quot;qfPermanentMultipoleForce:  Atom off the mesh (ignoring) %6.3f %6.3f %6.3f\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l08135"></a>08135         fflush(stderr);
<a name="l08136"></a>08136     } <span class="keywordflow">else</span> {
<a name="l08137"></a>08137 
<a name="l08138"></a>08138         <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l08139"></a>08139         position[0] = apos[0] - xmin;
<a name="l08140"></a>08140         position[1] = apos[1] - ymin;
<a name="l08141"></a>08141         position[2] = apos[2] - zmin;
<a name="l08142"></a>08142         ifloat = position[0]/hx;
<a name="l08143"></a>08143         jfloat = position[1]/hy;
<a name="l08144"></a>08144         kfloat = position[2]/hzed;
<a name="l08145"></a>08145         ip1 = (int)ceil(ifloat);
<a name="l08146"></a>08146         ip2 = ip1 + 2;
<a name="l08147"></a>08147         im1 = (int)floor(ifloat);
<a name="l08148"></a>08148         im2 = im1 - 2;
<a name="l08149"></a>08149         jp1 = (int)ceil(jfloat);
<a name="l08150"></a>08150         jp2 = jp1 + 2;
<a name="l08151"></a>08151         jm1 = (int)floor(jfloat);
<a name="l08152"></a>08152         jm2 = jm1 - 2;
<a name="l08153"></a>08153         kp1 = (int)ceil(kfloat);
<a name="l08154"></a>08154         kp2 = kp1 + 2;
<a name="l08155"></a>08155         km1 = (int)floor(kfloat);
<a name="l08156"></a>08156         km2 = km1 - 2;
<a name="l08157"></a>08157 
<a name="l08158"></a>08158         <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l08159"></a>08159 <span class="comment">         * later on if something goes wrong */</span>
<a name="l08160"></a>08160         ip2 = VMIN2(ip2,nx-1);
<a name="l08161"></a>08161         ip1 = VMIN2(ip1,nx-1);
<a name="l08162"></a>08162         im1 = VMAX2(im1,0);
<a name="l08163"></a>08163         im2 = VMAX2(im2,0);
<a name="l08164"></a>08164         jp2 = VMIN2(jp2,ny-1);
<a name="l08165"></a>08165         jp1 = VMIN2(jp1,ny-1);
<a name="l08166"></a>08166         jm1 = VMAX2(jm1,0);
<a name="l08167"></a>08167         jm2 = VMAX2(jm2,0);
<a name="l08168"></a>08168         kp2 = VMIN2(kp2,nz-1);
<a name="l08169"></a>08169         kp1 = VMIN2(kp1,nz-1);
<a name="l08170"></a>08170         km1 = VMAX2(km1,0);
<a name="l08171"></a>08171         km2 = VMAX2(km2,0);
<a name="l08172"></a>08172 
<a name="l08173"></a>08173         <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l08174"></a>08174             mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l08175"></a>08175             mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l08176"></a>08176             dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l08177"></a>08177             d2mx = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mi);
<a name="l08178"></a>08178             d3mx = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mi);
<a name="l08179"></a>08179             <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l08180"></a>08180                 mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l08181"></a>08181                 my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l08182"></a>08182                 dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l08183"></a>08183                 d2my = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mj);
<a name="l08184"></a>08184                 d3my = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mj);
<a name="l08185"></a>08185                 <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l08186"></a>08186                     mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l08187"></a>08187                     mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l08188"></a>08188                     dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l08189"></a>08189                     d2mz = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mk);
<a name="l08190"></a>08190                     d3mz = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mk);
<a name="l08191"></a>08191                     f = u[IJK(ii,jj,kk)];
<a name="l08192"></a>08192                     <span class="comment">/* Potential */</span>
<a name="l08193"></a>08193                     pot  += f*mx*my*mz;
<a name="l08194"></a>08194                     <span class="comment">/* Field */</span>
<a name="l08195"></a>08195                     e[0] += f*dmx*my*mz/hx;
<a name="l08196"></a>08196                     e[1] += f*mx*dmy*mz/hy;
<a name="l08197"></a>08197                     e[2] += f*mx*my*dmz/hzed;
<a name="l08198"></a>08198                     <span class="comment">/* Field gradient */</span>
<a name="l08199"></a>08199                     de[0][0] += f*d2mx*my*mz/(hx*hx);
<a name="l08200"></a>08200                     de[1][0] += f*dmx*dmy*mz/(hy*hx);
<a name="l08201"></a>08201                     de[1][1] += f*mx*d2my*mz/(hy*hy);
<a name="l08202"></a>08202                     de[2][0] += f*dmx*my*dmz/(hx*hzed);
<a name="l08203"></a>08203                     de[2][1] += f*mx*dmy*dmz/(hy*hzed);
<a name="l08204"></a>08204                     de[2][2] += f*mx*my*d2mz/(hzed*hzed);
<a name="l08205"></a>08205                     <span class="comment">/* 2nd Field Gradient</span>
<a name="l08206"></a>08206 <span class="comment">                       VxVxVa */</span>
<a name="l08207"></a>08207                     d2e[0][0][0] += f*d3mx*my*mz /(hx*hx*hx);
<a name="l08208"></a>08208                     d2e[0][0][1] += f*d2mx*dmy*mz/(hx*hy*hx);
<a name="l08209"></a>08209                     d2e[0][0][2] += f*d2mx*my*dmz/(hx*hx*hzed);
<a name="l08210"></a>08210                     <span class="comment">/* VyVxVa */</span>
<a name="l08211"></a>08211                     d2e[1][0][0] += f*d2mx*dmy*mz/(hx*hx*hy);
<a name="l08212"></a>08212                     d2e[1][0][1] += f*dmx*d2my*mz/(hx*hy*hy);
<a name="l08213"></a>08213                     d2e[1][0][2] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l08214"></a>08214                     <span class="comment">/* VyVyVa */</span>
<a name="l08215"></a>08215                     d2e[1][1][0] += f*dmx*d2my*mz/(hx*hy*hy);
<a name="l08216"></a>08216                     d2e[1][1][1] += f*mx*d3my*mz /(hy*hy*hy);
<a name="l08217"></a>08217                     d2e[1][1][2] += f*mx*d2my*dmz/(hy*hy*hzed);
<a name="l08218"></a>08218                     <span class="comment">/* VzVxVa */</span>
<a name="l08219"></a>08219                     d2e[2][0][0] += f*d2mx*my*dmz/(hx*hx*hzed);
<a name="l08220"></a>08220                     d2e[2][0][1] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l08221"></a>08221                     d2e[2][0][2] += f*dmx*my*d2mz/(hx*hzed*hzed);
<a name="l08222"></a>08222                     <span class="comment">/* VzVyVa */</span>
<a name="l08223"></a>08223                     d2e[2][1][0] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l08224"></a>08224                     d2e[2][1][1] += f*mx*d2my*dmz/(hy*hy*hzed);
<a name="l08225"></a>08225                     d2e[2][1][2] += f*mx*dmy*d2mz/(hy*hzed*hzed);
<a name="l08226"></a>08226                     <span class="comment">/* VzVzVa */</span>
<a name="l08227"></a>08227                     d2e[2][2][0] += f*dmx*my*d2mz/(hx*hzed*hzed);
<a name="l08228"></a>08228                     d2e[2][2][1] += f*mx*dmy*d2mz/(hy*hzed*hzed);
<a name="l08229"></a>08229                     d2e[2][2][2] += f*mx*my*d3mz /(hzed*hzed*hzed);
<a name="l08230"></a>08230                 }
<a name="l08231"></a>08231             }
<a name="l08232"></a>08232         }
<a name="l08233"></a>08233     }
<a name="l08234"></a>08234 
<a name="l08235"></a>08235     <span class="comment">/* Monopole Force */</span>
<a name="l08236"></a>08236     force[0] = e[0]*c;
<a name="l08237"></a>08237     force[1] = e[1]*c;
<a name="l08238"></a>08238     force[2] = e[2]*c;
<a name="l08239"></a>08239 
<a name="l08240"></a>08240     <span class="comment">/* Dipole Force */</span>
<a name="l08241"></a>08241     force[0] -= de[0][0]*ux+de[1][0]*uy+de[2][0]*uz;
<a name="l08242"></a>08242     force[1] -= de[1][0]*ux+de[1][1]*uy+de[2][1]*uz;
<a name="l08243"></a>08243     force[2] -= de[2][0]*ux+de[2][1]*uy+de[2][2]*uz;
<a name="l08244"></a>08244 
<a name="l08245"></a>08245     <span class="comment">/* Quadrupole Force */</span>
<a name="l08246"></a>08246     force[0] += d2e[0][0][0]*qxx
<a name="l08247"></a>08247              +  d2e[1][0][0]*qyx*2.0+d2e[1][1][0]*qyy
<a name="l08248"></a>08248              +  d2e[2][0][0]*qzx*2.0+d2e[2][1][0]*qzy*2.0+d2e[2][2][0]*qzz;
<a name="l08249"></a>08249     force[1] += d2e[0][0][1]*qxx
<a name="l08250"></a>08250              +  d2e[1][0][1]*qyx*2.0+d2e[1][1][1]*qyy
<a name="l08251"></a>08251              +  d2e[2][0][1]*qzx*2.0+d2e[2][1][1]*qzy*2.0+d2e[2][2][1]*qzz;
<a name="l08252"></a>08252     force[2] += d2e[0][0][2]*qxx
<a name="l08253"></a>08253              +  d2e[1][0][2]*qyx*2.0+d2e[1][1][2]*qyy
<a name="l08254"></a>08254              +  d2e[2][0][2]*qzx*2.0+d2e[2][1][2]*qzy*2.0+d2e[2][2][2]*qzz;
<a name="l08255"></a>08255 
<a name="l08256"></a>08256     <span class="comment">/* Dipole Torque */</span>
<a name="l08257"></a>08257     torque[0] = uy * e[2] - uz * e[1];
<a name="l08258"></a>08258     torque[1] = uz * e[0] - ux * e[2];
<a name="l08259"></a>08259     torque[2] = ux * e[1] - uy * e[0];
<a name="l08260"></a>08260     <span class="comment">/* Quadrupole Torque */</span>
<a name="l08261"></a>08261     de[0][1] = de[1][0];
<a name="l08262"></a>08262     de[0][2] = de[2][0];
<a name="l08263"></a>08263     de[1][2] = de[2][1];
<a name="l08264"></a>08264     torque[0] -= 2.0*(qyx*de[0][2] + qyy*de[1][2] + qyz*de[2][2]
<a name="l08265"></a>08265                     - qzx*de[0][1] - qzy*de[1][1] - qzz*de[2][1]);
<a name="l08266"></a>08266     torque[1] -= 2.0*(qzx*de[0][0] + qzy*de[1][0] + qzz*de[2][0]
<a name="l08267"></a>08267                     - qxx*de[0][2] - qxy*de[1][2] - qxz*de[2][2]);
<a name="l08268"></a>08268     torque[2] -= 2.0*(qxx*de[0][1] + qxy*de[1][1] + qxz*de[2][1]
<a name="l08269"></a>08269                     - qyx*de[0][0] - qyy*de[1][0] - qyz*de[2][0]);
<a name="l08270"></a>08270 
<a name="l08271"></a>08271 
<a name="l08272"></a>08272     <span class="comment">/* printf(&quot; qPhi Force %f %f %f\n&quot;, force[0], force[1], force[2]);</span>
<a name="l08273"></a>08273 <span class="comment">       printf(&quot; qPhi Torque %f %f %f\n&quot;, torque[0], torque[1], torque[2]); */</span>
<a name="l08274"></a>08274 }
<a name="l08275"></a>08275 
<a name="l08276"></a>08276 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga6995c161dfed91089495abd94baab3e8" title="Compute the ionic boundary force for permanent multipoles.">Vpmg_ibPermanentMultipoleForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">int</span> atomID,
<a name="l08277"></a>08277                                             <span class="keywordtype">double</span> force[3]) {
<a name="l08278"></a>08278 
<a name="l08279"></a>08279     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l08280"></a>08280     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l08281"></a>08281     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l08282"></a>08282     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l08283"></a>08283     <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm;
<a name="l08284"></a>08284 
<a name="l08285"></a>08285     <span class="comment">/* Grid variables */</span>
<a name="l08286"></a>08286     <span class="keywordtype">double</span> *apos, position[3], arad, irad, zkappa2, hx, hy, hzed;
<a name="l08287"></a>08287     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax, rtot2;
<a name="l08288"></a>08288     <span class="keywordtype">double</span> rtot, dx, dx2, dy, dy2, dz, dz2, gpos[3], tgrad[3], fmag;
<a name="l08289"></a>08289     <span class="keywordtype">double</span> izmagic;
<a name="l08290"></a>08290     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, imin, imax, jmin, jmax, kmin, kmax;
<a name="l08291"></a>08291 
<a name="l08292"></a>08292     VASSERT(thee != VNULL);
<a name="l08293"></a>08293 
<a name="l08294"></a>08294     <span class="comment">/* Nonlinear PBE is not implemented for AMOEBA */</span>
<a name="l08295"></a>08295     VASSERT(!thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>);
<a name="l08296"></a>08296 
<a name="l08297"></a>08297     acc = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l08298"></a>08298     srfm = thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>;
<a name="l08299"></a>08299     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l08300"></a>08300 
<a name="l08301"></a>08301     <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l08302"></a>08302 
<a name="l08303"></a>08303     VASSERT(atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);
<a name="l08304"></a>08304     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l08305"></a>08305     arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l08306"></a>08306 
<a name="l08307"></a>08307     <span class="comment">/* Reset force */</span>
<a name="l08308"></a>08308     force[0] = 0.0;
<a name="l08309"></a>08309     force[1] = 0.0;
<a name="l08310"></a>08310     force[2] = 0.0;
<a name="l08311"></a>08311 
<a name="l08312"></a>08312     <span class="comment">/* Get PBE info */</span>
<a name="l08313"></a>08313     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l08314"></a>08314     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l08315"></a>08315     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l08316"></a>08316     irad = <a class="code" href="group___vpbe.html#gabf77d3500a5e3b3c8673eab703bb53e0" title="Get maximum radius of ion species.">Vpbe_getMaxIonRadius</a>(pbe);
<a name="l08317"></a>08317     zkappa2 = <a class="code" href="group___vpbe.html#ga56e38face81d2d29659541b5e3f5e442" title="Get modified squared Debye-Huckel parameter.">Vpbe_getZkappa2</a>(pbe);
<a name="l08318"></a>08318     izmagic = 1.0/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l08319"></a>08319 
<a name="l08320"></a>08320     <span class="comment">/* Should be a check for this further up. */</span>
<a name="l08321"></a>08321     VASSERT (zkappa2 &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>);
<a name="l08322"></a>08322 
<a name="l08323"></a>08323     <span class="comment">/* Mesh info */</span>
<a name="l08324"></a>08324     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l08325"></a>08325     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l08326"></a>08326     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l08327"></a>08327     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l08328"></a>08328     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l08329"></a>08329     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l08330"></a>08330     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l08331"></a>08331     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l08332"></a>08332     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l08333"></a>08333     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l08334"></a>08334     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l08335"></a>08335     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l08336"></a>08336     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l08337"></a>08337     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l08338"></a>08338     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l08339"></a>08339 
<a name="l08340"></a>08340     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l08341"></a>08341     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l08342"></a>08342       (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l08343"></a>08343       (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l08344"></a>08344         Vnm_print(2, <span class="stringliteral">&quot;ibPermanentMultipoleForce:  Atom %d at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>, atomID, apos[0], apos[1], apos[2]);
<a name="l08345"></a>08345         Vnm_print(2, <span class="stringliteral">&quot;ibPermanentMultipoleForce:  xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l08346"></a>08346         Vnm_print(2, <span class="stringliteral">&quot;ibPermanentMultipoleForce:  ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l08347"></a>08347         Vnm_print(2, <span class="stringliteral">&quot;ibPermanentMultipoleForce:  zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l08348"></a>08348         fflush(stderr);
<a name="l08349"></a>08349     } <span class="keywordflow">else</span> {
<a name="l08350"></a>08350 
<a name="l08351"></a>08351         <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l08352"></a>08352         position[0] = apos[0] - xmin;
<a name="l08353"></a>08353         position[1] = apos[1] - ymin;
<a name="l08354"></a>08354         position[2] = apos[2] - zmin;
<a name="l08355"></a>08355 
<a name="l08356"></a>08356         <span class="comment">/* Integrate over points within this atom&#39;s (inflated) radius */</span>
<a name="l08357"></a>08357         rtot = (irad + arad + thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>);
<a name="l08358"></a>08358         rtot2 = VSQR(rtot);
<a name="l08359"></a>08359         dx = rtot + 0.5*hx;
<a name="l08360"></a>08360         imin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[0] - dx)/hx));
<a name="l08361"></a>08361         imax = VMIN2(nx-1,(<span class="keywordtype">int</span>)floor((position[0] + dx)/hx));
<a name="l08362"></a>08362         <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l08363"></a>08363             dx2 = VSQR(position[0] - hx*i);
<a name="l08364"></a>08364             <span class="keywordflow">if</span> (rtot2 &gt; dx2) dy = VSQRT(rtot2 - dx2) + 0.5*hy;
<a name="l08365"></a>08365             <span class="keywordflow">else</span> dy = 0.5*hy;
<a name="l08366"></a>08366             jmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[1] - dy)/hy));
<a name="l08367"></a>08367             jmax = VMIN2(ny-1,(<span class="keywordtype">int</span>)floor((position[1] + dy)/hy));
<a name="l08368"></a>08368             <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l08369"></a>08369                 dy2 = VSQR(position[1] - hy*j);
<a name="l08370"></a>08370                 <span class="keywordflow">if</span> (rtot2 &gt; (dx2+dy2)) dz = VSQRT(rtot2-dx2-dy2)+0.5*hzed;
<a name="l08371"></a>08371                 <span class="keywordflow">else</span> dz = 0.5*hzed;
<a name="l08372"></a>08372                 kmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[2] - dz)/hzed));
<a name="l08373"></a>08373                 kmax = VMIN2(nz-1,(<span class="keywordtype">int</span>)floor((position[2] + dz)/hzed));
<a name="l08374"></a>08374                 <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l08375"></a>08375                     dz2 = VSQR(k*hzed - position[2]);
<a name="l08376"></a>08376                     <span class="comment">/* See if grid point is inside ivdw radius and set ccf</span>
<a name="l08377"></a>08377 <span class="comment">                     * accordingly (do spline assignment here) */</span>
<a name="l08378"></a>08378                     <span class="keywordflow">if</span> ((dz2 + dy2 + dx2) &lt;= rtot2) {
<a name="l08379"></a>08379                         gpos[0] = i*hx + xmin;
<a name="l08380"></a>08380                         gpos[1] = j*hy + ymin;
<a name="l08381"></a>08381                         gpos[2] = k*hzed + zmin;
<a name="l08382"></a>08382                         <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, irad, atom, tgrad);
<a name="l08383"></a>08383                         fmag = VSQR(thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>[IJK(i,j,k)])*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)];
<a name="l08384"></a>08384                         force[0] += (zkappa2*fmag*tgrad[0]);
<a name="l08385"></a>08385                         force[1] += (zkappa2*fmag*tgrad[1]);
<a name="l08386"></a>08386                         force[2] += (zkappa2*fmag*tgrad[2]);
<a name="l08387"></a>08387                     }
<a name="l08388"></a>08388                 } <span class="comment">/* k loop */</span>
<a name="l08389"></a>08389             } <span class="comment">/* j loop */</span>
<a name="l08390"></a>08390         } <span class="comment">/* i loop */</span>
<a name="l08391"></a>08391     }
<a name="l08392"></a>08392 
<a name="l08393"></a>08393     force[0] = force[0] * 0.5 * hx * hy * hzed * izmagic;
<a name="l08394"></a>08394     force[1] = force[1] * 0.5 * hx * hy * hzed * izmagic;
<a name="l08395"></a>08395     force[2] = force[2] * 0.5 * hx * hy * hzed * izmagic;
<a name="l08396"></a>08396 
<a name="l08397"></a>08397 }
<a name="l08398"></a>08398 
<a name="l08399"></a>08399 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gaddb7038beac357ea0190e3e0eb9dcc64" title="Compute the dielectric boundary force for permanent multipoles.">Vpmg_dbPermanentMultipoleForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <span class="keywordtype">int</span> atomID,
<a name="l08400"></a>08400                                             <span class="keywordtype">double</span> force[3]) {
<a name="l08401"></a>08401 
<a name="l08402"></a>08402     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l08403"></a>08403     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l08404"></a>08404     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l08405"></a>08405     <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm;
<a name="l08406"></a>08406 
<a name="l08407"></a>08407     <span class="keywordtype">double</span> *apos, position[3], arad, hx, hy, hzed, izmagic, deps, depsi;
<a name="l08408"></a>08408     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax, rtot2, epsp;
<a name="l08409"></a>08409     <span class="keywordtype">double</span> rtot, dx, gpos[3], tgrad[3], dbFmag, epsw, kT;
<a name="l08410"></a>08410     <span class="keywordtype">double</span> *u, Hxijk, Hyijk, Hzijk, Hxim1jk, Hyijm1k, Hzijkm1;
<a name="l08411"></a>08411     <span class="keywordtype">double</span> dHxijk[3], dHyijk[3], dHzijk[3], dHxim1jk[3], dHyijm1k[3];
<a name="l08412"></a>08412     <span class="keywordtype">double</span> dHzijkm1[3];
<a name="l08413"></a>08413     <span class="keywordtype">int</span> i, j, k, l, nx, ny, nz, imin, imax, jmin, jmax, kmin, kmax;
<a name="l08414"></a>08414 
<a name="l08415"></a>08415     VASSERT(thee != VNULL);
<a name="l08416"></a>08416 
<a name="l08417"></a>08417     acc = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l08418"></a>08418     srfm = thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>;
<a name="l08419"></a>08419     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l08420"></a>08420 
<a name="l08421"></a>08421     <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l08422"></a>08422 
<a name="l08423"></a>08423     VASSERT(atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);
<a name="l08424"></a>08424     arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l08425"></a>08425     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l08426"></a>08426 
<a name="l08427"></a>08427     <span class="comment">/* Reset force */</span>
<a name="l08428"></a>08428     force[0] = 0.0;
<a name="l08429"></a>08429     force[1] = 0.0;
<a name="l08430"></a>08430     force[2] = 0.0;
<a name="l08431"></a>08431 
<a name="l08432"></a>08432     <span class="comment">/* Get PBE info */</span>
<a name="l08433"></a>08433     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l08434"></a>08434     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l08435"></a>08435     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l08436"></a>08436     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l08437"></a>08437     kT = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe)*(1e-3)*<a class="code" href="group___vunit.html#gae194adb8dae1861b5d34d4fc9d2afc86" title="Avogadro&#39;s number.">Vunit_Na</a>*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>;
<a name="l08438"></a>08438     izmagic = 1.0/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l08439"></a>08439 
<a name="l08440"></a>08440 
<a name="l08441"></a>08441     deps = (epsw - epsp);
<a name="l08442"></a>08442     depsi = 1.0/deps;
<a name="l08443"></a>08443 
<a name="l08444"></a>08444     VASSERT(VABS(deps) &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>);
<a name="l08445"></a>08445 
<a name="l08446"></a>08446     <span class="comment">/* Mesh info */</span>
<a name="l08447"></a>08447     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l08448"></a>08448     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l08449"></a>08449     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l08450"></a>08450     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l08451"></a>08451     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l08452"></a>08452     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l08453"></a>08453     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l08454"></a>08454     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l08455"></a>08455     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l08456"></a>08456     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l08457"></a>08457     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l08458"></a>08458     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l08459"></a>08459     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l08460"></a>08460     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l08461"></a>08461     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l08462"></a>08462     u = thee-&gt;<a class="code" href="structs_vpmg.html#a3b6b999a764f1e2ea94bb5f28c7a558c">u</a>;
<a name="l08463"></a>08463 
<a name="l08464"></a>08464     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l08465"></a>08465     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l08466"></a>08466       (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l08467"></a>08467       (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l08468"></a>08468         Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  Atom at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l08469"></a>08469         Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l08470"></a>08470         Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l08471"></a>08471         Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l08472"></a>08472         fflush(stderr);
<a name="l08473"></a>08473     } <span class="keywordflow">else</span> {
<a name="l08474"></a>08474 
<a name="l08475"></a>08475         <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l08476"></a>08476         position[0] = apos[0] - xmin;
<a name="l08477"></a>08477         position[1] = apos[1] - ymin;
<a name="l08478"></a>08478         position[2] = apos[2] - zmin;
<a name="l08479"></a>08479 
<a name="l08480"></a>08480         <span class="comment">/* Integrate over points within this atom&#39;s (inflated) radius */</span>
<a name="l08481"></a>08481         rtot = (arad + thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>);
<a name="l08482"></a>08482         rtot2 = VSQR(rtot);
<a name="l08483"></a>08483         dx = rtot/hx;
<a name="l08484"></a>08484         imin = (int)floor((position[0]-rtot)/hx);
<a name="l08485"></a>08485         <span class="keywordflow">if</span> (imin &lt; 1) {
<a name="l08486"></a>08486             Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  Atom off grid!\n&quot;</span>);
<a name="l08487"></a>08487             <span class="keywordflow">return</span>;
<a name="l08488"></a>08488         }
<a name="l08489"></a>08489         imax = (int)ceil((position[0]+rtot)/hx);
<a name="l08490"></a>08490         <span class="keywordflow">if</span> (imax &gt; (nx-2)) {
<a name="l08491"></a>08491             Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  Atom off grid!\n&quot;</span>);
<a name="l08492"></a>08492             <span class="keywordflow">return</span>;
<a name="l08493"></a>08493         }
<a name="l08494"></a>08494         jmin = (int)floor((position[1]-rtot)/hy);
<a name="l08495"></a>08495         <span class="keywordflow">if</span> (jmin &lt; 1) {
<a name="l08496"></a>08496             Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  Atom off grid!\n&quot;</span>);
<a name="l08497"></a>08497             <span class="keywordflow">return</span>;
<a name="l08498"></a>08498         }
<a name="l08499"></a>08499         jmax = (int)ceil((position[1]+rtot)/hy);
<a name="l08500"></a>08500         <span class="keywordflow">if</span> (jmax &gt; (ny-2)) {
<a name="l08501"></a>08501             Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  Atom off grid!\n&quot;</span>);
<a name="l08502"></a>08502             <span class="keywordflow">return</span>;
<a name="l08503"></a>08503         }
<a name="l08504"></a>08504         kmin = (int)floor((position[2]-rtot)/hzed);
<a name="l08505"></a>08505         <span class="keywordflow">if</span> (kmin &lt; 1) {
<a name="l08506"></a>08506             Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  Atom off grid!\n&quot;</span>);
<a name="l08507"></a>08507             <span class="keywordflow">return</span>;
<a name="l08508"></a>08508         }
<a name="l08509"></a>08509         kmax = (int)ceil((position[2]+rtot)/hzed);
<a name="l08510"></a>08510         <span class="keywordflow">if</span> (kmax &gt; (nz-2)) {
<a name="l08511"></a>08511             Vnm_print(2, <span class="stringliteral">&quot;dbPermanentMultipoleForce:  Atom off grid!\n&quot;</span>);
<a name="l08512"></a>08512             <span class="keywordflow">return</span>;
<a name="l08513"></a>08513         }
<a name="l08514"></a>08514         <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l08515"></a>08515             <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l08516"></a>08516                 <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l08517"></a>08517                     <span class="comment">/* i,j,k */</span>
<a name="l08518"></a>08518                     gpos[0] = (i+0.5)*hx + xmin;
<a name="l08519"></a>08519                     gpos[1] = j*hy + ymin;
<a name="l08520"></a>08520                     gpos[2] = k*hzed + zmin;
<a name="l08521"></a>08521                     Hxijk = (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l08522"></a>08522                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l08523"></a>08523                             atom, dHxijk);
<a name="l08524"></a>08524                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHxijk[l] *= Hxijk;
<a name="l08525"></a>08525                     gpos[0] = i*hx + xmin;
<a name="l08526"></a>08526                     gpos[1] = (j+0.5)*hy + ymin;
<a name="l08527"></a>08527                     gpos[2] = k*hzed + zmin;
<a name="l08528"></a>08528                     Hyijk = (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l08529"></a>08529                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l08530"></a>08530                             atom, dHyijk);
<a name="l08531"></a>08531                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHyijk[l] *= Hyijk;
<a name="l08532"></a>08532                     gpos[0] = i*hx + xmin;
<a name="l08533"></a>08533                     gpos[1] = j*hy + ymin;
<a name="l08534"></a>08534                     gpos[2] = (k+0.5)*hzed + zmin;
<a name="l08535"></a>08535                     Hzijk = (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l08536"></a>08536                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l08537"></a>08537                             atom, dHzijk);
<a name="l08538"></a>08538                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHzijk[l] *= Hzijk;
<a name="l08539"></a>08539                     <span class="comment">/* i-1,j,k */</span>
<a name="l08540"></a>08540                     gpos[0] = (i-0.5)*hx + xmin;
<a name="l08541"></a>08541                     gpos[1] = j*hy + ymin;
<a name="l08542"></a>08542                     gpos[2] = k*hzed + zmin;
<a name="l08543"></a>08543                     Hxim1jk = (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i-1,j,k)] - epsp)*depsi;
<a name="l08544"></a>08544                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l08545"></a>08545                             atom, dHxim1jk);
<a name="l08546"></a>08546                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHxim1jk[l] *= Hxim1jk;
<a name="l08547"></a>08547                     <span class="comment">/* i,j-1,k */</span>
<a name="l08548"></a>08548                     gpos[0] = i*hx + xmin;
<a name="l08549"></a>08549                     gpos[1] = (j-0.5)*hy + ymin;
<a name="l08550"></a>08550                     gpos[2] = k*hzed + zmin;
<a name="l08551"></a>08551                     Hyijm1k = (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j-1,k)] - epsp)*depsi;
<a name="l08552"></a>08552                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l08553"></a>08553                             atom, dHyijm1k);
<a name="l08554"></a>08554                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHyijm1k[l] *= Hyijm1k;
<a name="l08555"></a>08555                     <span class="comment">/* i,j,k-1 */</span>
<a name="l08556"></a>08556                     gpos[0] = i*hx + xmin;
<a name="l08557"></a>08557                     gpos[1] = j*hy + ymin;
<a name="l08558"></a>08558                     gpos[2] = (k-0.5)*hzed + zmin;
<a name="l08559"></a>08559                     Hzijkm1 = (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k-1)] - epsp)*depsi;
<a name="l08560"></a>08560                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l08561"></a>08561                             atom, dHzijkm1);
<a name="l08562"></a>08562                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHzijkm1[l] *= Hzijkm1;
<a name="l08563"></a>08563                     dbFmag = u[IJK(i,j,k)];
<a name="l08564"></a>08564                     tgrad[0] =
<a name="l08565"></a>08565                        (dHxijk[0]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l08566"></a>08566                      +  dHxim1jk[0]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l08567"></a>08567                      + (dHyijk[0]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l08568"></a>08568                      +  dHyijm1k[0]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l08569"></a>08569                      + (dHzijk[0]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l08570"></a>08570                      + dHzijkm1[0]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l08571"></a>08571                     tgrad[1] =
<a name="l08572"></a>08572                        (dHxijk[1]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l08573"></a>08573                      +  dHxim1jk[1]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l08574"></a>08574                      + (dHyijk[1]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l08575"></a>08575                      +  dHyijm1k[1]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l08576"></a>08576                      + (dHzijk[1]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l08577"></a>08577                      + dHzijkm1[1]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l08578"></a>08578                     tgrad[2] =
<a name="l08579"></a>08579                        (dHxijk[2]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l08580"></a>08580                      +  dHxim1jk[2]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l08581"></a>08581                      + (dHyijk[2]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l08582"></a>08582                      +  dHyijm1k[2]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l08583"></a>08583                      + (dHzijk[2]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l08584"></a>08584                      + dHzijkm1[2]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l08585"></a>08585                      force[0] += (dbFmag*tgrad[0]);
<a name="l08586"></a>08586                      force[1] += (dbFmag*tgrad[1]);
<a name="l08587"></a>08587                      force[2] += (dbFmag*tgrad[2]);
<a name="l08588"></a>08588                 } <span class="comment">/* k loop */</span>
<a name="l08589"></a>08589             } <span class="comment">/* j loop */</span>
<a name="l08590"></a>08590         } <span class="comment">/* i loop */</span>
<a name="l08591"></a>08591         force[0] = -force[0]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l08592"></a>08592         force[1] = -force[1]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l08593"></a>08593         force[2] = -force[2]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l08594"></a>08594     }
<a name="l08595"></a>08595 }
<a name="l08596"></a>08596 
<a name="l08597"></a>08597 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gae3dea198212ad46859a23c95a2447009" title="q-Phi direct polarization force between permanent multipoles and induced dipoles, which are induced b...">Vpmg_qfDirectPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a>* perm, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *induced,
<a name="l08598"></a>08598                                    <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> force[3], <span class="keywordtype">double</span> torque[3]) {
<a name="l08599"></a>08599 
<a name="l08600"></a>08600     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l08601"></a>08601     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l08602"></a>08602     <span class="keywordtype">double</span> f, fp, *u, *up, *apos, position[3];
<a name="l08603"></a>08603 
<a name="l08604"></a>08604     <span class="comment">/* Grid variables */</span>
<a name="l08605"></a>08605     <span class="keywordtype">int</span> nx,ny,nz;
<a name="l08606"></a>08606     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax;
<a name="l08607"></a>08607     <span class="keywordtype">double</span> hx, hy, hzed, ifloat, jfloat, kfloat;
<a name="l08608"></a>08608 
<a name="l08609"></a>08609     <span class="comment">/* B-spline weights */</span>
<a name="l08610"></a>08610     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz, d2mx, d2my, d2mz, d3mx, d3my, d3mz;
<a name="l08611"></a>08611     <span class="keywordtype">double</span> mi, mj, mk;
<a name="l08612"></a>08612 
<a name="l08613"></a>08613     <span class="comment">/* Loop indeces */</span>
<a name="l08614"></a>08614     <span class="keywordtype">int</span> i, j, k, ii, jj, kk;
<a name="l08615"></a>08615     <span class="keywordtype">int</span> im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1, kp1, kp2;
<a name="l08616"></a>08616 
<a name="l08617"></a>08617     <span class="comment">/* Permanent potential, field, field gradient and 2nd field gradient */</span>
<a name="l08618"></a>08618     <span class="keywordtype">double</span> pot, e[3], de[3][3], d2e[3][3][3];
<a name="l08619"></a>08619     <span class="comment">/* Induced dipole field */</span>
<a name="l08620"></a>08620     <span class="keywordtype">double</span> dep[3][3];
<a name="l08621"></a>08621 
<a name="l08622"></a>08622     <span class="comment">/* Permanent multipole components */</span>
<a name="l08623"></a>08623     <span class="keywordtype">double</span> *dipole, *quad;
<a name="l08624"></a>08624     <span class="keywordtype">double</span> c, ux, uy, uz, qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz;
<a name="l08625"></a>08625     <span class="keywordtype">double</span> uix, uiy, uiz;
<a name="l08626"></a>08626 
<a name="l08627"></a>08627     VASSERT(thee != VNULL);
<a name="l08628"></a>08628     VASSERT(induced != VNULL); <span class="comment">/* the potential due to permanent multipoles.*/</span>
<a name="l08629"></a>08629     VASSERT(induced != VNULL); <span class="comment">/* the potential due to local induced dipoles.*/</span>
<a name="l08630"></a>08630     VASSERT(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a> != VNULL);
<a name="l08631"></a>08631     VASSERT(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a> != VNULL);
<a name="l08632"></a>08632 
<a name="l08633"></a>08633     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l08634"></a>08634     VASSERT(atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0); <span class="comment">/* all atoms must be in the same partition.*/</span>
<a name="l08635"></a>08635     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l08636"></a>08636 
<a name="l08637"></a>08637     c = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l08638"></a>08638     dipole = Vatom_getDipole(atom);
<a name="l08639"></a>08639     ux = dipole[0];
<a name="l08640"></a>08640     uy = dipole[1];
<a name="l08641"></a>08641     uz = dipole[2];
<a name="l08642"></a>08642     quad = Vatom_getQuadrupole(atom);
<a name="l08643"></a>08643     qxx = quad[0]/3.0;
<a name="l08644"></a>08644     qxy = quad[1]/3.0;
<a name="l08645"></a>08645     qxz = quad[2]/3.0;
<a name="l08646"></a>08646     qyx = quad[3]/3.0;
<a name="l08647"></a>08647     qyy = quad[4]/3.0;
<a name="l08648"></a>08648     qyz = quad[5]/3.0;
<a name="l08649"></a>08649     qzx = quad[6]/3.0;
<a name="l08650"></a>08650     qzy = quad[7]/3.0;
<a name="l08651"></a>08651     qzz = quad[8]/3.0;
<a name="l08652"></a>08652 
<a name="l08653"></a>08653     dipole = Vatom_getInducedDipole(atom);
<a name="l08654"></a>08654     uix = dipole[0];
<a name="l08655"></a>08655     uiy = dipole[1];
<a name="l08656"></a>08656     uiz = dipole[2];
<a name="l08657"></a>08657 
<a name="l08658"></a>08658     <span class="comment">/* Reset Field Gradients */</span>
<a name="l08659"></a>08659     pot = 0.0;
<a name="l08660"></a>08660     <span class="keywordflow">for</span> (i=0;i&lt;3;i++){
<a name="l08661"></a>08661        e[i] = 0.0;
<a name="l08662"></a>08662        <span class="keywordflow">for</span> (j=0;j&lt;3;j++){
<a name="l08663"></a>08663           de[i][j] = 0.0;
<a name="l08664"></a>08664           dep[i][j] = 0.0;
<a name="l08665"></a>08665           <span class="keywordflow">for</span> (k=0;k&lt;3;k++){
<a name="l08666"></a>08666              d2e[i][j][k] = 0.0;
<a name="l08667"></a>08667           }
<a name="l08668"></a>08668        }
<a name="l08669"></a>08669     }
<a name="l08670"></a>08670 
<a name="l08671"></a>08671     <span class="comment">/* Mesh info */</span>
<a name="l08672"></a>08672     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l08673"></a>08673     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l08674"></a>08674     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l08675"></a>08675     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l08676"></a>08676     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l08677"></a>08677     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l08678"></a>08678     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l08679"></a>08679     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l08680"></a>08680     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l08681"></a>08681     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l08682"></a>08682     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l08683"></a>08683     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l08684"></a>08684     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l08685"></a>08685     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l08686"></a>08686     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l08687"></a>08687     u = induced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l08688"></a>08688     up = perm-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l08689"></a>08689 
<a name="l08690"></a>08690     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l08691"></a>08691     <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin+2*hx))   || (apos[0]&gt;=(xmax-2*hx)) \
<a name="l08692"></a>08692      || (apos[1]&lt;=(ymin+2*hy))   || (apos[1]&gt;=(ymax-2*hy)) \
<a name="l08693"></a>08693      || (apos[2]&lt;=(zmin+2*hzed)) || (apos[2]&gt;=(zmax-2*hzed))) {
<a name="l08694"></a>08694         Vnm_print(2, <span class="stringliteral">&quot;qfDirectPolForce:  Atom off the mesh (ignoring) %6.3f %6.3f %6.3f\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l08695"></a>08695         fflush(stderr);
<a name="l08696"></a>08696 
<a name="l08697"></a>08697     } <span class="keywordflow">else</span> {
<a name="l08698"></a>08698 
<a name="l08699"></a>08699         <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l08700"></a>08700         position[0] = apos[0] - xmin;
<a name="l08701"></a>08701         position[1] = apos[1] - ymin;
<a name="l08702"></a>08702         position[2] = apos[2] - zmin;
<a name="l08703"></a>08703         ifloat = position[0]/hx;
<a name="l08704"></a>08704         jfloat = position[1]/hy;
<a name="l08705"></a>08705         kfloat = position[2]/hzed;
<a name="l08706"></a>08706         ip1 = (int)ceil(ifloat);
<a name="l08707"></a>08707         ip2 = ip1 + 2;
<a name="l08708"></a>08708         im1 = (int)floor(ifloat);
<a name="l08709"></a>08709         im2 = im1 - 2;
<a name="l08710"></a>08710         jp1 = (int)ceil(jfloat);
<a name="l08711"></a>08711         jp2 = jp1 + 2;
<a name="l08712"></a>08712         jm1 = (int)floor(jfloat);
<a name="l08713"></a>08713         jm2 = jm1 - 2;
<a name="l08714"></a>08714         kp1 = (int)ceil(kfloat);
<a name="l08715"></a>08715         kp2 = kp1 + 2;
<a name="l08716"></a>08716         km1 = (int)floor(kfloat);
<a name="l08717"></a>08717         km2 = km1 - 2;
<a name="l08718"></a>08718 
<a name="l08719"></a>08719         <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l08720"></a>08720 <span class="comment">         * later on if something goes wrong */</span>
<a name="l08721"></a>08721         ip2 = VMIN2(ip2,nx-1);
<a name="l08722"></a>08722         ip1 = VMIN2(ip1,nx-1);
<a name="l08723"></a>08723         im1 = VMAX2(im1,0);
<a name="l08724"></a>08724         im2 = VMAX2(im2,0);
<a name="l08725"></a>08725         jp2 = VMIN2(jp2,ny-1);
<a name="l08726"></a>08726         jp1 = VMIN2(jp1,ny-1);
<a name="l08727"></a>08727         jm1 = VMAX2(jm1,0);
<a name="l08728"></a>08728         jm2 = VMAX2(jm2,0);
<a name="l08729"></a>08729         kp2 = VMIN2(kp2,nz-1);
<a name="l08730"></a>08730         kp1 = VMIN2(kp1,nz-1);
<a name="l08731"></a>08731         km1 = VMAX2(km1,0);
<a name="l08732"></a>08732         km2 = VMAX2(km2,0);
<a name="l08733"></a>08733 
<a name="l08734"></a>08734         <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l08735"></a>08735             mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l08736"></a>08736             mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l08737"></a>08737             dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l08738"></a>08738             d2mx = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mi);
<a name="l08739"></a>08739             d3mx = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mi);
<a name="l08740"></a>08740             <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l08741"></a>08741                 mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l08742"></a>08742                 my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l08743"></a>08743                 dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l08744"></a>08744                 d2my = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mj);
<a name="l08745"></a>08745                 d3my = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mj);
<a name="l08746"></a>08746                 <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l08747"></a>08747                     mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l08748"></a>08748                     mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l08749"></a>08749                     dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l08750"></a>08750                     d2mz = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mk);
<a name="l08751"></a>08751                     d3mz = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mk);
<a name="l08752"></a>08752                     f = u[IJK(ii,jj,kk)];
<a name="l08753"></a>08753                     fp = up[IJK(ii,jj,kk)];
<a name="l08754"></a>08754                     <span class="comment">/* The potential */</span>
<a name="l08755"></a>08755                     pot  += f*mx*my*mz;
<a name="l08756"></a>08756                     <span class="comment">/* The field */</span>
<a name="l08757"></a>08757                     e[0] += f*dmx*my*mz/hx;
<a name="l08758"></a>08758                     e[1] += f*mx*dmy*mz/hy;
<a name="l08759"></a>08759                     e[2] += f*mx*my*dmz/hzed;
<a name="l08760"></a>08760                     <span class="comment">/* The gradient of the field */</span>
<a name="l08761"></a>08761                     de[0][0] += f*d2mx*my*mz/(hx*hx);
<a name="l08762"></a>08762                     de[1][0] += f*dmx*dmy*mz/(hy*hx);
<a name="l08763"></a>08763                     de[1][1] += f*mx*d2my*mz/(hy*hy);
<a name="l08764"></a>08764                     de[2][0] += f*dmx*my*dmz/(hx*hzed);
<a name="l08765"></a>08765                     de[2][1] += f*mx*dmy*dmz/(hy*hzed);
<a name="l08766"></a>08766                     de[2][2] += f*mx*my*d2mz/(hzed*hzed);
<a name="l08767"></a>08767                     <span class="comment">/* The gradient of the (permanent) field */</span>
<a name="l08768"></a>08768                     dep[0][0] += fp*d2mx*my*mz/(hx*hx);
<a name="l08769"></a>08769                     dep[1][0] += fp*dmx*dmy*mz/(hy*hx);
<a name="l08770"></a>08770                     dep[1][1] += fp*mx*d2my*mz/(hy*hy);
<a name="l08771"></a>08771                     dep[2][0] += fp*dmx*my*dmz/(hx*hzed);
<a name="l08772"></a>08772                     dep[2][1] += fp*mx*dmy*dmz/(hy*hzed);
<a name="l08773"></a>08773                     dep[2][2] += fp*mx*my*d2mz/(hzed*hzed);
<a name="l08774"></a>08774                     <span class="comment">/* The 2nd gradient of the field</span>
<a name="l08775"></a>08775 <span class="comment">                       VxVxVa */</span>
<a name="l08776"></a>08776                     d2e[0][0][0] += f*d3mx*my*mz /(hx*hx*hx);
<a name="l08777"></a>08777                     d2e[0][0][1] += f*d2mx*dmy*mz/(hx*hy*hx);
<a name="l08778"></a>08778                     d2e[0][0][2] += f*d2mx*my*dmz/(hx*hx*hzed);
<a name="l08779"></a>08779                     <span class="comment">/* VyVxVa */</span>
<a name="l08780"></a>08780                     d2e[1][0][0] += f*d2mx*dmy*mz/(hx*hx*hy);
<a name="l08781"></a>08781                     d2e[1][0][1] += f*dmx*d2my*mz/(hx*hy*hy);
<a name="l08782"></a>08782                     d2e[1][0][2] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l08783"></a>08783                     <span class="comment">/* VyVyVa */</span>
<a name="l08784"></a>08784                     d2e[1][1][0] += f*dmx*d2my*mz/(hx*hy*hy);
<a name="l08785"></a>08785                     d2e[1][1][1] += f*mx*d3my*mz /(hy*hy*hy);
<a name="l08786"></a>08786                     d2e[1][1][2] += f*mx*d2my*dmz/(hy*hy*hzed);
<a name="l08787"></a>08787                     <span class="comment">/* VzVxVa */</span>
<a name="l08788"></a>08788                     d2e[2][0][0] += f*d2mx*my*dmz/(hx*hx*hzed);
<a name="l08789"></a>08789                     d2e[2][0][1] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l08790"></a>08790                     d2e[2][0][2] += f*dmx*my*d2mz/(hx*hzed*hzed);
<a name="l08791"></a>08791                     <span class="comment">/* VzVyVa */</span>
<a name="l08792"></a>08792                     d2e[2][1][0] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l08793"></a>08793                     d2e[2][1][1] += f*mx*d2my*dmz/(hy*hy*hzed);
<a name="l08794"></a>08794                     d2e[2][1][2] += f*mx*dmy*d2mz/(hy*hzed*hzed);
<a name="l08795"></a>08795                     <span class="comment">/* VzVzVa */</span>
<a name="l08796"></a>08796                     d2e[2][2][0] += f*dmx*my*d2mz/(hx*hzed*hzed);
<a name="l08797"></a>08797                     d2e[2][2][1] += f*mx*dmy*d2mz/(hy*hzed*hzed);
<a name="l08798"></a>08798                     d2e[2][2][2] += f*mx*my*d3mz /(hzed*hzed*hzed);
<a name="l08799"></a>08799                 }
<a name="l08800"></a>08800             }
<a name="l08801"></a>08801         }
<a name="l08802"></a>08802     }
<a name="l08803"></a>08803 
<a name="l08804"></a>08804     <span class="comment">/* force on permanent multipole due to induced reaction field */</span>
<a name="l08805"></a>08805 
<a name="l08806"></a>08806     <span class="comment">/* Monopole Force */</span>
<a name="l08807"></a>08807     force[0] = e[0]*c;
<a name="l08808"></a>08808     force[1] = e[1]*c;
<a name="l08809"></a>08809     force[2] = e[2]*c;
<a name="l08810"></a>08810 
<a name="l08811"></a>08811     <span class="comment">/* Dipole Force */</span>
<a name="l08812"></a>08812     force[0] -= de[0][0]*ux+de[1][0]*uy+de[2][0]*uz;
<a name="l08813"></a>08813     force[1] -= de[1][0]*ux+de[1][1]*uy+de[2][1]*uz;
<a name="l08814"></a>08814     force[2] -= de[2][0]*ux+de[2][1]*uy+de[2][2]*uz;
<a name="l08815"></a>08815 
<a name="l08816"></a>08816     <span class="comment">/* Quadrupole Force */</span>
<a name="l08817"></a>08817     force[0] += d2e[0][0][0]*qxx
<a name="l08818"></a>08818              +  d2e[1][0][0]*qyx*2.0+d2e[1][1][0]*qyy
<a name="l08819"></a>08819              +  d2e[2][0][0]*qzx*2.0+d2e[2][1][0]*qzy*2.0+d2e[2][2][0]*qzz;
<a name="l08820"></a>08820     force[1] += d2e[0][0][1]*qxx
<a name="l08821"></a>08821              +  d2e[1][0][1]*qyx*2.0+d2e[1][1][1]*qyy
<a name="l08822"></a>08822              +  d2e[2][0][1]*qzx*2.0+d2e[2][1][1]*qzy*2.0+d2e[2][2][1]*qzz;
<a name="l08823"></a>08823     force[2] += d2e[0][0][2]*qxx
<a name="l08824"></a>08824              +  d2e[1][0][2]*qyx*2.0+d2e[1][1][2]*qyy
<a name="l08825"></a>08825              +  d2e[2][0][2]*qzx*2.0+d2e[2][1][2]*qzy*2.0+d2e[2][2][2]*qzz;
<a name="l08826"></a>08826 
<a name="l08827"></a>08827     <span class="comment">/* torque on permanent mulitpole due to induced reaction field */</span>
<a name="l08828"></a>08828 
<a name="l08829"></a>08829     <span class="comment">/* Dipole Torque */</span>
<a name="l08830"></a>08830     torque[0] = uy * e[2] - uz * e[1];
<a name="l08831"></a>08831     torque[1] = uz * e[0] - ux * e[2];
<a name="l08832"></a>08832     torque[2] = ux * e[1] - uy * e[0];
<a name="l08833"></a>08833 
<a name="l08834"></a>08834     <span class="comment">/* Quadrupole Torque */</span>
<a name="l08835"></a>08835     <span class="comment">/* Tx = -2.0*(Sum_a (Qya*dEaz) + Sum_b (Qzb*dEby))</span>
<a name="l08836"></a>08836 <span class="comment">       Ty = -2.0*(Sum_a (Qza*dEax) + Sum_b (Qxb*dEbz))</span>
<a name="l08837"></a>08837 <span class="comment">       Tz = -2.0*(Sum_a (Qxa*dEay) + Sum_b (Qyb*dEbx))  */</span>
<a name="l08838"></a>08838     de[0][1] = de[1][0];
<a name="l08839"></a>08839     de[0][2] = de[2][0];
<a name="l08840"></a>08840     de[1][2] = de[2][1];
<a name="l08841"></a>08841     torque[0] -= 2.0*(qyx*de[0][2] + qyy*de[1][2] + qyz*de[2][2]
<a name="l08842"></a>08842                     - qzx*de[0][1] - qzy*de[1][1] - qzz*de[2][1]);
<a name="l08843"></a>08843     torque[1] -= 2.0*(qzx*de[0][0] + qzy*de[1][0] + qzz*de[2][0]
<a name="l08844"></a>08844                     - qxx*de[0][2] - qxy*de[1][2] - qxz*de[2][2]);
<a name="l08845"></a>08845     torque[2] -= 2.0*(qxx*de[0][1] + qxy*de[1][1] + qxz*de[2][1]
<a name="l08846"></a>08846                     - qyx*de[0][0] - qyy*de[1][0] - qyz*de[2][0]);
<a name="l08847"></a>08847 
<a name="l08848"></a>08848     <span class="comment">/* force on induced dipole due to permanent reaction field */</span>
<a name="l08849"></a>08849 
<a name="l08850"></a>08850     force[0] -= dep[0][0]*uix+dep[1][0]*uiy+dep[2][0]*uiz;
<a name="l08851"></a>08851     force[1] -= dep[1][0]*uix+dep[1][1]*uiy+dep[2][1]*uiz;
<a name="l08852"></a>08852     force[2] -= dep[2][0]*uix+dep[2][1]*uiy+dep[2][2]*uiz;
<a name="l08853"></a>08853 
<a name="l08854"></a>08854     force[0] = 0.5 * force[0];
<a name="l08855"></a>08855     force[1] = 0.5 * force[1];
<a name="l08856"></a>08856     force[2] = 0.5 * force[2];
<a name="l08857"></a>08857     torque[0] = 0.5 * torque[0];
<a name="l08858"></a>08858     torque[1] = 0.5 * torque[1];
<a name="l08859"></a>08859     torque[2] = 0.5 * torque[2];
<a name="l08860"></a>08860 
<a name="l08861"></a>08861     <span class="comment">/* printf(&quot; qPhi Force %f %f %f\n&quot;, force[0], force[1], force[2]);</span>
<a name="l08862"></a>08862 <span class="comment">      printf(&quot; qPhi Torque %f %f %f\n&quot;, torque[0], torque[1], torque[2]); */</span>
<a name="l08863"></a>08863 }
<a name="l08864"></a>08864 
<a name="l08865"></a>08865 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga58c95dcd1612660d86d1234bda4e3fc0" title="q-Phi direct polarization force between permanent multipoles and non-local induced dipoles based on 5...">Vpmg_qfNLDirectPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *perm, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *nlInduced,
<a name="l08866"></a>08866                                      <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> force[3], <span class="keywordtype">double</span> torque[3]) {
<a name="l08867"></a>08867 
<a name="l08868"></a>08868     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l08869"></a>08869     <span class="keywordtype">double</span> *apos, *dipole, *quad, position[3], hx, hy, hzed;
<a name="l08870"></a>08870     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax;
<a name="l08871"></a>08871     <span class="keywordtype">double</span> pot, e[3],de[3][3],dep[3][3],d2e[3][3][3];
<a name="l08872"></a>08872     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz, mi, mj, mk;
<a name="l08873"></a>08873     <span class="keywordtype">double</span> d2mx, d2my, d2mz, d3mx, d3my, d3mz;
<a name="l08874"></a>08874     <span class="keywordtype">double</span> *u, *up, charge, ifloat, jfloat, kfloat;
<a name="l08875"></a>08875     <span class="keywordtype">double</span> f, fp, c, ux, uy, uz, qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz;
<a name="l08876"></a>08876     <span class="keywordtype">double</span> uix, uiy, uiz;
<a name="l08877"></a>08877     <span class="keywordtype">int</span> i,j,k,nx, ny, nz, im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1;
<a name="l08878"></a>08878     <span class="keywordtype">int</span> kp1, kp2, ii, jj, kk;
<a name="l08879"></a>08879 
<a name="l08880"></a>08880     VASSERT(thee != VNULL);
<a name="l08881"></a>08881     VASSERT(perm != VNULL);      <span class="comment">/* potential due to permanent multipoles. */</span>
<a name="l08882"></a>08882     VASSERT(nlInduced != VNULL); <span class="comment">/* potential due to non-local induced dipoles */</span>
<a name="l08883"></a>08883     VASSERT(!thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>); <span class="comment">/* Nonlinear PBE is not implemented for AMOEBA */</span>
<a name="l08884"></a>08884 
<a name="l08885"></a>08885     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l08886"></a>08886     VASSERT(atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);   <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l08887"></a>08887     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l08888"></a>08888 
<a name="l08889"></a>08889     c = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom);
<a name="l08890"></a>08890     dipole = Vatom_getDipole(atom);
<a name="l08891"></a>08891     ux = dipole[0];
<a name="l08892"></a>08892     uy = dipole[1];
<a name="l08893"></a>08893     uz = dipole[2];
<a name="l08894"></a>08894     quad = Vatom_getQuadrupole(atom);
<a name="l08895"></a>08895     qxx = quad[0]/3.0;
<a name="l08896"></a>08896     qxy = quad[1]/3.0;
<a name="l08897"></a>08897     qxz = quad[2]/3.0;
<a name="l08898"></a>08898     qyx = quad[3]/3.0;
<a name="l08899"></a>08899     qyy = quad[4]/3.0;
<a name="l08900"></a>08900     qyz = quad[5]/3.0;
<a name="l08901"></a>08901     qzx = quad[6]/3.0;
<a name="l08902"></a>08902     qzy = quad[7]/3.0;
<a name="l08903"></a>08903     qzz = quad[8]/3.0;
<a name="l08904"></a>08904 
<a name="l08905"></a>08905     dipole = Vatom_getNLInducedDipole(atom);
<a name="l08906"></a>08906     uix = dipole[0];
<a name="l08907"></a>08907     uiy = dipole[1];
<a name="l08908"></a>08908     uiz = dipole[2];
<a name="l08909"></a>08909 
<a name="l08910"></a>08910     <span class="comment">/* Reset Field Gradients */</span>
<a name="l08911"></a>08911     pot = 0.0;
<a name="l08912"></a>08912     <span class="keywordflow">for</span> (i=0;i&lt;3;i++){
<a name="l08913"></a>08913        e[i] = 0.0;
<a name="l08914"></a>08914        <span class="keywordflow">for</span> (j=0;j&lt;3;j++){
<a name="l08915"></a>08915           de[i][j] = 0.0;
<a name="l08916"></a>08916           dep[i][j] = 0.0;
<a name="l08917"></a>08917           <span class="keywordflow">for</span> (k=0;k&lt;3;k++){
<a name="l08918"></a>08918              d2e[i][j][k] = 0.0;
<a name="l08919"></a>08919           }
<a name="l08920"></a>08920        }
<a name="l08921"></a>08921     }
<a name="l08922"></a>08922 
<a name="l08923"></a>08923     <span class="comment">/* Mesh info */</span>
<a name="l08924"></a>08924     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l08925"></a>08925     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l08926"></a>08926     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l08927"></a>08927     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l08928"></a>08928     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l08929"></a>08929     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l08930"></a>08930     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l08931"></a>08931     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l08932"></a>08932     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l08933"></a>08933     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l08934"></a>08934     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l08935"></a>08935     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l08936"></a>08936     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l08937"></a>08937     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l08938"></a>08938     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l08939"></a>08939     u = nlInduced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l08940"></a>08940     up = perm-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l08941"></a>08941 
<a name="l08942"></a>08942 
<a name="l08943"></a>08943     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l08944"></a>08944     <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin+2*hx))   || (apos[0]&gt;=(xmax-2*hx)) \
<a name="l08945"></a>08945      || (apos[1]&lt;=(ymin+2*hy))   || (apos[1]&gt;=(ymax-2*hy)) \
<a name="l08946"></a>08946      || (apos[2]&lt;=(zmin+2*hzed)) || (apos[2]&gt;=(zmax-2*hzed))) {
<a name="l08947"></a>08947         Vnm_print(2, <span class="stringliteral">&quot;qfNLDirectMultipoleForce:  Atom off the mesh (ignoring) %6.3f %6.3f %6.3f\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l08948"></a>08948     } <span class="keywordflow">else</span> {
<a name="l08949"></a>08949 
<a name="l08950"></a>08950         <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l08951"></a>08951         position[0] = apos[0] - xmin;
<a name="l08952"></a>08952         position[1] = apos[1] - ymin;
<a name="l08953"></a>08953         position[2] = apos[2] - zmin;
<a name="l08954"></a>08954         ifloat = position[0]/hx;
<a name="l08955"></a>08955         jfloat = position[1]/hy;
<a name="l08956"></a>08956         kfloat = position[2]/hzed;
<a name="l08957"></a>08957         ip1 = (int)ceil(ifloat);
<a name="l08958"></a>08958         ip2 = ip1 + 2;
<a name="l08959"></a>08959         im1 = (int)floor(ifloat);
<a name="l08960"></a>08960         im2 = im1 - 2;
<a name="l08961"></a>08961         jp1 = (int)ceil(jfloat);
<a name="l08962"></a>08962         jp2 = jp1 + 2;
<a name="l08963"></a>08963         jm1 = (int)floor(jfloat);
<a name="l08964"></a>08964         jm2 = jm1 - 2;
<a name="l08965"></a>08965         kp1 = (int)ceil(kfloat);
<a name="l08966"></a>08966         kp2 = kp1 + 2;
<a name="l08967"></a>08967         km1 = (int)floor(kfloat);
<a name="l08968"></a>08968         km2 = km1 - 2;
<a name="l08969"></a>08969 
<a name="l08970"></a>08970         <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l08971"></a>08971 <span class="comment">         * later on if something goes wrong */</span>
<a name="l08972"></a>08972         ip2 = VMIN2(ip2,nx-1);
<a name="l08973"></a>08973         ip1 = VMIN2(ip1,nx-1);
<a name="l08974"></a>08974         im1 = VMAX2(im1,0);
<a name="l08975"></a>08975         im2 = VMAX2(im2,0);
<a name="l08976"></a>08976         jp2 = VMIN2(jp2,ny-1);
<a name="l08977"></a>08977         jp1 = VMIN2(jp1,ny-1);
<a name="l08978"></a>08978         jm1 = VMAX2(jm1,0);
<a name="l08979"></a>08979         jm2 = VMAX2(jm2,0);
<a name="l08980"></a>08980         kp2 = VMIN2(kp2,nz-1);
<a name="l08981"></a>08981         kp1 = VMIN2(kp1,nz-1);
<a name="l08982"></a>08982         km1 = VMAX2(km1,0);
<a name="l08983"></a>08983         km2 = VMAX2(km2,0);
<a name="l08984"></a>08984 
<a name="l08985"></a>08985         <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l08986"></a>08986             mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l08987"></a>08987             mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l08988"></a>08988             dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l08989"></a>08989             d2mx = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mi);
<a name="l08990"></a>08990             d3mx = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mi);
<a name="l08991"></a>08991             <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l08992"></a>08992                 mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l08993"></a>08993                 my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l08994"></a>08994                 dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l08995"></a>08995                 d2my = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mj);
<a name="l08996"></a>08996                 d3my = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mj);
<a name="l08997"></a>08997                 <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l08998"></a>08998                     mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l08999"></a>08999                     mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l09000"></a>09000                     dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l09001"></a>09001                     d2mz = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mk);
<a name="l09002"></a>09002                     d3mz = <a class="code" href="vpmg_8c.html#addf938597bc4a997f8766856d8d59de1" title="Evaluate the 3rd derivative of a 5th Order B-Spline.">d3bspline4</a>(mk);
<a name="l09003"></a>09003                     f = u[IJK(ii,jj,kk)];
<a name="l09004"></a>09004                     fp = up[IJK(ii,jj,kk)];
<a name="l09005"></a>09005                     <span class="comment">/* The potential */</span>
<a name="l09006"></a>09006                     pot  += f*mx*my*mz;
<a name="l09007"></a>09007                     <span class="comment">/* The field */</span>
<a name="l09008"></a>09008                     e[0] += f*dmx*my*mz/hx;
<a name="l09009"></a>09009                     e[1] += f*mx*dmy*mz/hy;
<a name="l09010"></a>09010                     e[2] += f*mx*my*dmz/hzed;
<a name="l09011"></a>09011                     <span class="comment">/* The gradient of the field */</span>
<a name="l09012"></a>09012                     de[0][0] += f*d2mx*my*mz/(hx*hx);
<a name="l09013"></a>09013                     de[1][0] += f*dmx*dmy*mz/(hy*hx);
<a name="l09014"></a>09014                     de[1][1] += f*mx*d2my*mz/(hy*hy);
<a name="l09015"></a>09015                     de[2][0] += f*dmx*my*dmz/(hx*hzed);
<a name="l09016"></a>09016                     de[2][1] += f*mx*dmy*dmz/(hy*hzed);
<a name="l09017"></a>09017                     de[2][2] += f*mx*my*d2mz/(hzed*hzed);
<a name="l09018"></a>09018                     <span class="comment">/* The gradient of the (permanent) field */</span>
<a name="l09019"></a>09019                     dep[0][0] += fp*d2mx*my*mz/(hx*hx);
<a name="l09020"></a>09020                     dep[1][0] += fp*dmx*dmy*mz/(hy*hx);
<a name="l09021"></a>09021                     dep[1][1] += fp*mx*d2my*mz/(hy*hy);
<a name="l09022"></a>09022                     dep[2][0] += fp*dmx*my*dmz/(hx*hzed);
<a name="l09023"></a>09023                     dep[2][1] += fp*mx*dmy*dmz/(hy*hzed);
<a name="l09024"></a>09024                     dep[2][2] += fp*mx*my*d2mz/(hzed*hzed);
<a name="l09025"></a>09025                     <span class="comment">/* The 2nd gradient of the field */</span>
<a name="l09026"></a>09026                     <span class="comment">/* VxVxVa */</span>
<a name="l09027"></a>09027                     d2e[0][0][0] += f*d3mx*my*mz /(hx*hx*hx);
<a name="l09028"></a>09028                     d2e[0][0][1] += f*d2mx*dmy*mz/(hx*hy*hx);
<a name="l09029"></a>09029                     d2e[0][0][2] += f*d2mx*my*dmz/(hx*hx*hzed);
<a name="l09030"></a>09030                     <span class="comment">/* VyVxVa */</span>
<a name="l09031"></a>09031                     d2e[1][0][0] += f*d2mx*dmy*mz/(hx*hx*hy);
<a name="l09032"></a>09032                     d2e[1][0][1] += f*dmx*d2my*mz/(hx*hy*hy);
<a name="l09033"></a>09033                     d2e[1][0][2] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l09034"></a>09034                     <span class="comment">/* VyVyVa */</span>
<a name="l09035"></a>09035                     d2e[1][1][0] += f*dmx*d2my*mz/(hx*hy*hy);
<a name="l09036"></a>09036                     d2e[1][1][1] += f*mx*d3my*mz /(hy*hy*hy);
<a name="l09037"></a>09037                     d2e[1][1][2] += f*mx*d2my*dmz/(hy*hy*hzed);
<a name="l09038"></a>09038                     <span class="comment">/* VzVxVa */</span>
<a name="l09039"></a>09039                     d2e[2][0][0] += f*d2mx*my*dmz/(hx*hx*hzed);
<a name="l09040"></a>09040                     d2e[2][0][1] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l09041"></a>09041                     d2e[2][0][2] += f*dmx*my*d2mz/(hx*hzed*hzed);
<a name="l09042"></a>09042                     <span class="comment">/* VzVyVa */</span>
<a name="l09043"></a>09043                     d2e[2][1][0] += f*dmx*dmy*dmz/(hx*hy*hzed);
<a name="l09044"></a>09044                     d2e[2][1][1] += f*mx*d2my*dmz/(hy*hy*hzed);
<a name="l09045"></a>09045                     d2e[2][1][2] += f*mx*dmy*d2mz/(hy*hzed*hzed);
<a name="l09046"></a>09046                     <span class="comment">/* VzVzVa */</span>
<a name="l09047"></a>09047                     d2e[2][2][0] += f*dmx*my*d2mz/(hx*hzed*hzed);
<a name="l09048"></a>09048                     d2e[2][2][1] += f*mx*dmy*d2mz/(hy*hzed*hzed);
<a name="l09049"></a>09049                     d2e[2][2][2] += f*mx*my*d3mz /(hzed*hzed*hzed);
<a name="l09050"></a>09050                 }
<a name="l09051"></a>09051             }
<a name="l09052"></a>09052         }
<a name="l09053"></a>09053     }
<a name="l09054"></a>09054 
<a name="l09055"></a>09055     <span class="comment">/* force on permanent multipole due to non-local induced reaction field */</span>
<a name="l09056"></a>09056 
<a name="l09057"></a>09057     <span class="comment">/* Monopole Force */</span>
<a name="l09058"></a>09058     force[0] = e[0]*c;
<a name="l09059"></a>09059     force[1] = e[1]*c;
<a name="l09060"></a>09060     force[2] = e[2]*c;
<a name="l09061"></a>09061 
<a name="l09062"></a>09062     <span class="comment">/* Dipole Force */</span>
<a name="l09063"></a>09063     force[0] -= de[0][0]*ux+de[1][0]*uy+de[2][0]*uz;
<a name="l09064"></a>09064     force[1] -= de[1][0]*ux+de[1][1]*uy+de[2][1]*uz;
<a name="l09065"></a>09065     force[2] -= de[2][0]*ux+de[2][1]*uy+de[2][2]*uz;
<a name="l09066"></a>09066 
<a name="l09067"></a>09067     <span class="comment">/* Quadrupole Force */</span>
<a name="l09068"></a>09068     force[0] += d2e[0][0][0]*qxx
<a name="l09069"></a>09069              +  d2e[1][0][0]*qyx*2.0+d2e[1][1][0]*qyy
<a name="l09070"></a>09070              +  d2e[2][0][0]*qzx*2.0+d2e[2][1][0]*qzy*2.0+d2e[2][2][0]*qzz;
<a name="l09071"></a>09071     force[1] += d2e[0][0][1]*qxx
<a name="l09072"></a>09072              +  d2e[1][0][1]*qyx*2.0+d2e[1][1][1]*qyy
<a name="l09073"></a>09073              +  d2e[2][0][1]*qzx*2.0+d2e[2][1][1]*qzy*2.0+d2e[2][2][1]*qzz;
<a name="l09074"></a>09074     force[2] += d2e[0][0][2]*qxx
<a name="l09075"></a>09075              +  d2e[1][0][2]*qyx*2.0+d2e[1][1][2]*qyy
<a name="l09076"></a>09076              +  d2e[2][0][2]*qzx*2.0+d2e[2][1][2]*qzy*2.0+d2e[2][2][2]*qzz;
<a name="l09077"></a>09077 
<a name="l09078"></a>09078     <span class="comment">/* torque on permanent mulitpole due to non-local induced reaction field */</span>
<a name="l09079"></a>09079 
<a name="l09080"></a>09080     <span class="comment">/* Dipole Torque */</span>
<a name="l09081"></a>09081     torque[0] = uy * e[2] - uz * e[1];
<a name="l09082"></a>09082     torque[1] = uz * e[0] - ux * e[2];
<a name="l09083"></a>09083     torque[2] = ux * e[1] - uy * e[0];
<a name="l09084"></a>09084 
<a name="l09085"></a>09085     <span class="comment">/* Quadrupole Torque */</span>
<a name="l09086"></a>09086     <span class="comment">/* Tx = -2.0*(Sum_a (Qya*dEaz) + Sum_b (Qzb*dEby))</span>
<a name="l09087"></a>09087 <span class="comment">       Ty = -2.0*(Sum_a (Qza*dEax) + Sum_b (Qxb*dEbz))</span>
<a name="l09088"></a>09088 <span class="comment">       Tz = -2.0*(Sum_a (Qxa*dEay) + Sum_b (Qyb*dEbx))  */</span>
<a name="l09089"></a>09089     de[0][1] = de[1][0];
<a name="l09090"></a>09090     de[0][2] = de[2][0];
<a name="l09091"></a>09091     de[1][2] = de[2][1];
<a name="l09092"></a>09092     torque[0] -= 2.0*(qyx*de[0][2] + qyy*de[1][2] + qyz*de[2][2]
<a name="l09093"></a>09093                     - qzx*de[0][1] - qzy*de[1][1] - qzz*de[2][1]);
<a name="l09094"></a>09094     torque[1] -= 2.0*(qzx*de[0][0] + qzy*de[1][0] + qzz*de[2][0]
<a name="l09095"></a>09095                     - qxx*de[0][2] - qxy*de[1][2] - qxz*de[2][2]);
<a name="l09096"></a>09096     torque[2] -= 2.0*(qxx*de[0][1] + qxy*de[1][1] + qxz*de[2][1]
<a name="l09097"></a>09097                     - qyx*de[0][0] - qyy*de[1][0] - qyz*de[2][0]);
<a name="l09098"></a>09098 
<a name="l09099"></a>09099     <span class="comment">/* force on non-local induced dipole due to permanent reaction field */</span>
<a name="l09100"></a>09100 
<a name="l09101"></a>09101     force[0] -= dep[0][0]*uix+dep[1][0]*uiy+dep[2][0]*uiz;
<a name="l09102"></a>09102     force[1] -= dep[1][0]*uix+dep[1][1]*uiy+dep[2][1]*uiz;
<a name="l09103"></a>09103     force[2] -= dep[2][0]*uix+dep[2][1]*uiy+dep[2][2]*uiz;
<a name="l09104"></a>09104 
<a name="l09105"></a>09105     force[0] = 0.5 * force[0];
<a name="l09106"></a>09106     force[1] = 0.5 * force[1];
<a name="l09107"></a>09107     force[2] = 0.5 * force[2];
<a name="l09108"></a>09108     torque[0] = 0.5 * torque[0];
<a name="l09109"></a>09109     torque[1] = 0.5 * torque[1];
<a name="l09110"></a>09110     torque[2] = 0.5 * torque[2];
<a name="l09111"></a>09111 
<a name="l09112"></a>09112     <span class="comment">/* printf(&quot; qPhi Force %f %f %f\n&quot;, force[0], force[1], force[2]);</span>
<a name="l09113"></a>09113 <span class="comment">       printf(&quot; qPhi Torque %f %f %f\n&quot;, torque[0], torque[1], torque[2]); */</span>
<a name="l09114"></a>09114 }
<a name="l09115"></a>09115 
<a name="l09116"></a>09116 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga7d7f287b66561a35baf15ab533563333" title="Ionic boundary direct polarization force between permanent multipoles and induced dipoles...">Vpmg_ibDirectPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *perm, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *induced,
<a name="l09117"></a>09117                                    <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> force[3]) {
<a name="l09118"></a>09118 
<a name="l09119"></a>09119     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l09120"></a>09120     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l09121"></a>09121     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l09122"></a>09122     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09123"></a>09123     <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm;
<a name="l09124"></a>09124 
<a name="l09125"></a>09125     <span class="keywordtype">double</span> *apos, position[3], arad, irad, zkappa2, hx, hy, hzed;
<a name="l09126"></a>09126     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax, rtot2;
<a name="l09127"></a>09127     <span class="keywordtype">double</span> rtot, dx, dx2, dy, dy2, dz, dz2, gpos[3], tgrad[3], fmag;
<a name="l09128"></a>09128     <span class="keywordtype">double</span> izmagic;
<a name="l09129"></a>09129     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, imin, imax, jmin, jmax, kmin, kmax;
<a name="l09130"></a>09130 
<a name="l09131"></a>09131     VASSERT(thee != VNULL);
<a name="l09132"></a>09132     VASSERT(perm != VNULL);        <span class="comment">/* potential due to permanent multipoles.*/</span>
<a name="l09133"></a>09133     VASSERT(induced != VNULL);     <span class="comment">/* potential due to induced dipoles. */</span>
<a name="l09134"></a>09134     VASSERT (!thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>); <span class="comment">/* Nonlinear PBE is not implemented for AMOEBA */</span>
<a name="l09135"></a>09135 
<a name="l09136"></a>09136     acc = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l09137"></a>09137     srfm = thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>;
<a name="l09138"></a>09138     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l09139"></a>09139     VASSERT(atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);   <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l09140"></a>09140     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l09141"></a>09141     arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l09142"></a>09142 
<a name="l09143"></a>09143     <span class="comment">/* Reset force */</span>
<a name="l09144"></a>09144     force[0] = 0.0;
<a name="l09145"></a>09145     force[1] = 0.0;
<a name="l09146"></a>09146     force[2] = 0.0;
<a name="l09147"></a>09147 
<a name="l09148"></a>09148     <span class="comment">/* Get PBE info */</span>
<a name="l09149"></a>09149     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09150"></a>09150     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l09151"></a>09151     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l09152"></a>09152     irad = <a class="code" href="group___vpbe.html#gabf77d3500a5e3b3c8673eab703bb53e0" title="Get maximum radius of ion species.">Vpbe_getMaxIonRadius</a>(pbe);
<a name="l09153"></a>09153     zkappa2 = <a class="code" href="group___vpbe.html#ga56e38face81d2d29659541b5e3f5e442" title="Get modified squared Debye-Huckel parameter.">Vpbe_getZkappa2</a>(pbe);
<a name="l09154"></a>09154     izmagic = 1.0/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l09155"></a>09155 
<a name="l09156"></a>09156     VASSERT (zkappa2 &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>); <span class="comment">/* It is ok to run AMOEBA with no ions, but this is checked for higher up in the driver. */</span>
<a name="l09157"></a>09157 
<a name="l09158"></a>09158     <span class="comment">/* Mesh info */</span>
<a name="l09159"></a>09159     nx = induced-&gt;<a class="code" href="structs_vgrid.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l09160"></a>09160     ny = induced-&gt;<a class="code" href="structs_vgrid.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l09161"></a>09161     nz = induced-&gt;<a class="code" href="structs_vgrid.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l09162"></a>09162     hx = induced-&gt;<a class="code" href="structs_vgrid.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l09163"></a>09163     hy = induced-&gt;<a class="code" href="structs_vgrid.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l09164"></a>09164     hzed = induced-&gt;<a class="code" href="structs_vgrid.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l09165"></a>09165     xmin = induced-&gt;<a class="code" href="structs_vgrid.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l09166"></a>09166     ymin = induced-&gt;<a class="code" href="structs_vgrid.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l09167"></a>09167     zmin = induced-&gt;<a class="code" href="structs_vgrid.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l09168"></a>09168     xmax = induced-&gt;<a class="code" href="structs_vgrid.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l09169"></a>09169     ymax = induced-&gt;<a class="code" href="structs_vgrid.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l09170"></a>09170     zmax = induced-&gt;<a class="code" href="structs_vgrid.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l09171"></a>09171     xlen = xmax-xmin;
<a name="l09172"></a>09172     ylen = ymax-ymin;
<a name="l09173"></a>09173     zlen = zmax-zmin;
<a name="l09174"></a>09174 
<a name="l09175"></a>09175     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l09176"></a>09176     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l09177"></a>09177       (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l09178"></a>09178       (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l09179"></a>09179         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:  Atom at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l09180"></a>09180             apos[0], apos[1], apos[2]);
<a name="l09181"></a>09181         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:    xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l09182"></a>09182         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:    ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l09183"></a>09183         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibForce:    zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l09184"></a>09184         fflush(stderr);
<a name="l09185"></a>09185     } <span class="keywordflow">else</span> {
<a name="l09186"></a>09186 
<a name="l09187"></a>09187         <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l09188"></a>09188         position[0] = apos[0] - xmin;
<a name="l09189"></a>09189         position[1] = apos[1] - ymin;
<a name="l09190"></a>09190         position[2] = apos[2] - zmin;
<a name="l09191"></a>09191 
<a name="l09192"></a>09192         <span class="comment">/* Integrate over points within this atom&#39;s (inflated) radius */</span>
<a name="l09193"></a>09193         rtot = (irad + arad + thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>);
<a name="l09194"></a>09194         rtot2 = VSQR(rtot);
<a name="l09195"></a>09195         dx = rtot + 0.5*hx;
<a name="l09196"></a>09196         imin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[0] - dx)/hx));
<a name="l09197"></a>09197         imax = VMIN2(nx-1,(<span class="keywordtype">int</span>)floor((position[0] + dx)/hx));
<a name="l09198"></a>09198         <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l09199"></a>09199             dx2 = VSQR(position[0] - hx*i);
<a name="l09200"></a>09200             <span class="keywordflow">if</span> (rtot2 &gt; dx2) dy = VSQRT(rtot2 - dx2) + 0.5*hy;
<a name="l09201"></a>09201             <span class="keywordflow">else</span> dy = 0.5*hy;
<a name="l09202"></a>09202             jmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[1] - dy)/hy));
<a name="l09203"></a>09203             jmax = VMIN2(ny-1,(<span class="keywordtype">int</span>)floor((position[1] + dy)/hy));
<a name="l09204"></a>09204             <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l09205"></a>09205                 dy2 = VSQR(position[1] - hy*j);
<a name="l09206"></a>09206                 <span class="keywordflow">if</span> (rtot2 &gt; (dx2+dy2)) dz = VSQRT(rtot2-dx2-dy2)+0.5*hzed;
<a name="l09207"></a>09207                 <span class="keywordflow">else</span> dz = 0.5*hzed;
<a name="l09208"></a>09208                 kmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[2] - dz)/hzed));
<a name="l09209"></a>09209                 kmax = VMIN2(nz-1,(<span class="keywordtype">int</span>)floor((position[2] + dz)/hzed));
<a name="l09210"></a>09210                 <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l09211"></a>09211                     dz2 = VSQR(k*hzed - position[2]);
<a name="l09212"></a>09212                     <span class="comment">/* See if grid point is inside ivdw radius and set ccf</span>
<a name="l09213"></a>09213 <span class="comment">                     * accordingly (do spline assignment here) */</span>
<a name="l09214"></a>09214                     <span class="keywordflow">if</span> ((dz2 + dy2 + dx2) &lt;= rtot2) {
<a name="l09215"></a>09215                         gpos[0] = i*hx + xmin;
<a name="l09216"></a>09216                         gpos[1] = j*hy + ymin;
<a name="l09217"></a>09217                         gpos[2] = k*hzed + zmin;
<a name="l09218"></a>09218                         <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, irad,
<a name="l09219"></a>09219                           atom, tgrad);
<a name="l09220"></a>09220                         fmag = induced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>[IJK(i,j,k)];
<a name="l09221"></a>09221                         fmag *= perm-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>[IJK(i,j,k)];
<a name="l09222"></a>09222                         fmag *= thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)];
<a name="l09223"></a>09223                         force[0] += (zkappa2*fmag*tgrad[0]);
<a name="l09224"></a>09224                         force[1] += (zkappa2*fmag*tgrad[1]);
<a name="l09225"></a>09225                         force[2] += (zkappa2*fmag*tgrad[2]);
<a name="l09226"></a>09226                     }
<a name="l09227"></a>09227                 } <span class="comment">/* k loop */</span>
<a name="l09228"></a>09228             } <span class="comment">/* j loop */</span>
<a name="l09229"></a>09229         } <span class="comment">/* i loop */</span>
<a name="l09230"></a>09230     }
<a name="l09231"></a>09231 
<a name="l09232"></a>09232     force[0] = force[0] * 0.5 * hx * hy * hzed * izmagic;
<a name="l09233"></a>09233     force[1] = force[1] * 0.5 * hx * hy * hzed * izmagic;
<a name="l09234"></a>09234     force[2] = force[2] * 0.5 * hx * hy * hzed * izmagic;
<a name="l09235"></a>09235 
<a name="l09236"></a>09236 }
<a name="l09237"></a>09237 
<a name="l09238"></a>09238 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga10bc9ab3cf7aba4fac7c7d611728cf0a" title="Ionic boundary direct polarization force between permanent multipoles and non-local induced dipoles b...">Vpmg_ibNLDirectPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *perm, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *nlInduced,
<a name="l09239"></a>09239                                      <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> force[3]) {
<a name="l09240"></a>09240      <a class="code" href="group___vpmg.html#ga7d7f287b66561a35baf15ab533563333" title="Ionic boundary direct polarization force between permanent multipoles and induced dipoles...">Vpmg_ibDirectPolForce</a>(thee, perm, nlInduced, atomID, force);
<a name="l09241"></a>09241 }
<a name="l09242"></a>09242 
<a name="l09243"></a>09243 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga3002128af85e2b38031ae380432fe735" title="Dielectric boundary direct polarization force between permanent multipoles and induced dipoles...">Vpmg_dbDirectPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *perm, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *induced,
<a name="l09244"></a>09244                                    <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> force[3]) {
<a name="l09245"></a>09245 
<a name="l09246"></a>09246     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l09247"></a>09247     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l09248"></a>09248     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09249"></a>09249     <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm;
<a name="l09250"></a>09250 
<a name="l09251"></a>09251     <span class="keywordtype">double</span> *apos, position[3], arad, hx, hy, hzed, izmagic, deps, depsi;
<a name="l09252"></a>09252     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax, rtot2, epsp;
<a name="l09253"></a>09253     <span class="keywordtype">double</span> rtot, dx, gpos[3], tgrad[3], dbFmag, epsw, kT;
<a name="l09254"></a>09254     <span class="keywordtype">double</span> *u, *up, Hxijk, Hyijk, Hzijk, Hxim1jk, Hyijm1k, Hzijkm1;
<a name="l09255"></a>09255     <span class="keywordtype">double</span> dHxijk[3], dHyijk[3], dHzijk[3], dHxim1jk[3], dHyijm1k[3];
<a name="l09256"></a>09256     <span class="keywordtype">double</span> dHzijkm1[3];
<a name="l09257"></a>09257     <span class="keywordtype">int</span> i, j, k, l, nx, ny, nz, imin, imax, jmin, jmax, kmin, kmax;
<a name="l09258"></a>09258 
<a name="l09259"></a>09259     VASSERT(thee != VNULL);
<a name="l09260"></a>09260     VASSERT(perm != VNULL);    <span class="comment">/* permanent multipole PMG solution. */</span>
<a name="l09261"></a>09261     VASSERT(induced != VNULL); <span class="comment">/* potential due to induced dipoles. */</span>
<a name="l09262"></a>09262 
<a name="l09263"></a>09263     acc = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l09264"></a>09264     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l09265"></a>09265     VASSERT (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);   <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l09266"></a>09266     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l09267"></a>09267     arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l09268"></a>09268 
<a name="l09269"></a>09269     <span class="comment">/* Reset force */</span>
<a name="l09270"></a>09270     force[0] = 0.0;
<a name="l09271"></a>09271     force[1] = 0.0;
<a name="l09272"></a>09272     force[2] = 0.0;
<a name="l09273"></a>09273 
<a name="l09274"></a>09274     <span class="comment">/* Get PBE info */</span>
<a name="l09275"></a>09275     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09276"></a>09276     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l09277"></a>09277     srfm = thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>;
<a name="l09278"></a>09278     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l09279"></a>09279     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l09280"></a>09280     kT = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe)*(1e-3)*<a class="code" href="group___vunit.html#gae194adb8dae1861b5d34d4fc9d2afc86" title="Avogadro&#39;s number.">Vunit_Na</a>*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>;
<a name="l09281"></a>09281     izmagic = 1.0/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l09282"></a>09282 
<a name="l09283"></a>09283     deps = (epsw - epsp);
<a name="l09284"></a>09284     depsi = 1.0/deps;
<a name="l09285"></a>09285     VASSERT(VABS(deps) &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>);
<a name="l09286"></a>09286 
<a name="l09287"></a>09287     <span class="comment">/* Mesh info */</span>
<a name="l09288"></a>09288     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l09289"></a>09289     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l09290"></a>09290     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l09291"></a>09291     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l09292"></a>09292     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l09293"></a>09293     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l09294"></a>09294     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l09295"></a>09295     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l09296"></a>09296     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l09297"></a>09297     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l09298"></a>09298     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l09299"></a>09299     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l09300"></a>09300     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l09301"></a>09301     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l09302"></a>09302     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l09303"></a>09303     <span class="comment">/* If the permanent and induced potentials are flipped the</span>
<a name="l09304"></a>09304 <span class="comment">       results are exactly the same. */</span>
<a name="l09305"></a>09305     u = induced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l09306"></a>09306     up = perm-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l09307"></a>09307 
<a name="l09308"></a>09308     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l09309"></a>09309     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l09310"></a>09310       (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l09311"></a>09311       (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l09312"></a>09312          Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:  Atom at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l09313"></a>09313          Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:    xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l09314"></a>09314          Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:    ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l09315"></a>09315          Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:    zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l09316"></a>09316          fflush(stderr);
<a name="l09317"></a>09317     } <span class="keywordflow">else</span> {
<a name="l09318"></a>09318 
<a name="l09319"></a>09319         <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l09320"></a>09320         position[0] = apos[0] - xmin;
<a name="l09321"></a>09321         position[1] = apos[1] - ymin;
<a name="l09322"></a>09322         position[2] = apos[2] - zmin;
<a name="l09323"></a>09323 
<a name="l09324"></a>09324         <span class="comment">/* Integrate over points within this atom&#39;s (inflated) radius */</span>
<a name="l09325"></a>09325         rtot = (arad + thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>);
<a name="l09326"></a>09326         rtot2 = VSQR(rtot);
<a name="l09327"></a>09327         dx = rtot/hx;
<a name="l09328"></a>09328         imin = (int)floor((position[0]-rtot)/hx);
<a name="l09329"></a>09329         <span class="keywordflow">if</span> (imin &lt; 1) {
<a name="l09330"></a>09330             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09331"></a>09331             <span class="keywordflow">return</span>;
<a name="l09332"></a>09332         }
<a name="l09333"></a>09333         imax = (int)ceil((position[0]+rtot)/hx);
<a name="l09334"></a>09334         <span class="keywordflow">if</span> (imax &gt; (nx-2)) {
<a name="l09335"></a>09335             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09336"></a>09336             <span class="keywordflow">return</span>;
<a name="l09337"></a>09337         }
<a name="l09338"></a>09338         jmin = (int)floor((position[1]-rtot)/hy);
<a name="l09339"></a>09339         <span class="keywordflow">if</span> (jmin &lt; 1) {
<a name="l09340"></a>09340             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09341"></a>09341             <span class="keywordflow">return</span>;
<a name="l09342"></a>09342         }
<a name="l09343"></a>09343         jmax = (int)ceil((position[1]+rtot)/hy);
<a name="l09344"></a>09344         <span class="keywordflow">if</span> (jmax &gt; (ny-2)) {
<a name="l09345"></a>09345             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09346"></a>09346             <span class="keywordflow">return</span>;
<a name="l09347"></a>09347         }
<a name="l09348"></a>09348         kmin = (int)floor((position[2]-rtot)/hzed);
<a name="l09349"></a>09349         <span class="keywordflow">if</span> (kmin &lt; 1) {
<a name="l09350"></a>09350             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09351"></a>09351             <span class="keywordflow">return</span>;
<a name="l09352"></a>09352         }
<a name="l09353"></a>09353         kmax = (int)ceil((position[2]+rtot)/hzed);
<a name="l09354"></a>09354         <span class="keywordflow">if</span> (kmax &gt; (nz-2)) {
<a name="l09355"></a>09355             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbDirectPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09356"></a>09356             <span class="keywordflow">return</span>;
<a name="l09357"></a>09357         }
<a name="l09358"></a>09358         <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l09359"></a>09359             <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l09360"></a>09360                 <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l09361"></a>09361                     <span class="comment">/* i,j,k */</span>
<a name="l09362"></a>09362                     gpos[0] = (i+0.5)*hx + xmin;
<a name="l09363"></a>09363                     gpos[1] = j*hy + ymin;
<a name="l09364"></a>09364                     gpos[2] = k*hzed + zmin;
<a name="l09365"></a>09365                     Hxijk = (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l09366"></a>09366                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09367"></a>09367                             atom, dHxijk);
<a name="l09368"></a>09368                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHxijk[l] *= Hxijk;
<a name="l09369"></a>09369                     gpos[0] = i*hx + xmin;
<a name="l09370"></a>09370                     gpos[1] = (j+0.5)*hy + ymin;
<a name="l09371"></a>09371                     gpos[2] = k*hzed + zmin;
<a name="l09372"></a>09372                     Hyijk = (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l09373"></a>09373                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09374"></a>09374                             atom, dHyijk);
<a name="l09375"></a>09375                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHyijk[l] *= Hyijk;
<a name="l09376"></a>09376                     gpos[0] = i*hx + xmin;
<a name="l09377"></a>09377                     gpos[1] = j*hy + ymin;
<a name="l09378"></a>09378                     gpos[2] = (k+0.5)*hzed + zmin;
<a name="l09379"></a>09379                     Hzijk = (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l09380"></a>09380                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09381"></a>09381                             atom, dHzijk);
<a name="l09382"></a>09382                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHzijk[l] *= Hzijk;
<a name="l09383"></a>09383                     <span class="comment">/* i-1,j,k */</span>
<a name="l09384"></a>09384                     gpos[0] = (i-0.5)*hx + xmin;
<a name="l09385"></a>09385                     gpos[1] = j*hy + ymin;
<a name="l09386"></a>09386                     gpos[2] = k*hzed + zmin;
<a name="l09387"></a>09387                     Hxim1jk = (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i-1,j,k)] - epsp)*depsi;
<a name="l09388"></a>09388                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09389"></a>09389                             atom, dHxim1jk);
<a name="l09390"></a>09390                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHxim1jk[l] *= Hxim1jk;
<a name="l09391"></a>09391                     <span class="comment">/* i,j-1,k */</span>
<a name="l09392"></a>09392                     gpos[0] = i*hx + xmin;
<a name="l09393"></a>09393                     gpos[1] = (j-0.5)*hy + ymin;
<a name="l09394"></a>09394                     gpos[2] = k*hzed + zmin;
<a name="l09395"></a>09395                     Hyijm1k = (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j-1,k)] - epsp)*depsi;
<a name="l09396"></a>09396                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09397"></a>09397                             atom, dHyijm1k);
<a name="l09398"></a>09398                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHyijm1k[l] *= Hyijm1k;
<a name="l09399"></a>09399                     <span class="comment">/* i,j,k-1 */</span>
<a name="l09400"></a>09400                     gpos[0] = i*hx + xmin;
<a name="l09401"></a>09401                     gpos[1] = j*hy + ymin;
<a name="l09402"></a>09402                     gpos[2] = (k-0.5)*hzed + zmin;
<a name="l09403"></a>09403                     Hzijkm1 = (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k-1)] - epsp)*depsi;
<a name="l09404"></a>09404                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09405"></a>09405                             atom, dHzijkm1);
<a name="l09406"></a>09406                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHzijkm1[l] *= Hzijkm1;
<a name="l09407"></a>09407 
<a name="l09408"></a>09408                     dbFmag = up[IJK(i,j,k)];
<a name="l09409"></a>09409                     tgrad[0] =
<a name="l09410"></a>09410                        (dHxijk[0]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l09411"></a>09411                      +  dHxim1jk[0]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l09412"></a>09412                      + (dHyijk[0]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l09413"></a>09413                      +  dHyijm1k[0]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l09414"></a>09414                      + (dHzijk[0]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l09415"></a>09415                      + dHzijkm1[0]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l09416"></a>09416                     tgrad[1] =
<a name="l09417"></a>09417                        (dHxijk[1]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l09418"></a>09418                      +  dHxim1jk[1]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l09419"></a>09419                      + (dHyijk[1]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l09420"></a>09420                      +  dHyijm1k[1]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l09421"></a>09421                      + (dHzijk[1]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l09422"></a>09422                      + dHzijkm1[1]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l09423"></a>09423                     tgrad[2] =
<a name="l09424"></a>09424                        (dHxijk[2]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l09425"></a>09425                      +  dHxim1jk[2]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l09426"></a>09426                      + (dHyijk[2]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l09427"></a>09427                      +  dHyijm1k[2]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l09428"></a>09428                      + (dHzijk[2]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l09429"></a>09429                      + dHzijkm1[2]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l09430"></a>09430                      force[0] += (dbFmag*tgrad[0]);
<a name="l09431"></a>09431                      force[1] += (dbFmag*tgrad[1]);
<a name="l09432"></a>09432                      force[2] += (dbFmag*tgrad[2]);
<a name="l09433"></a>09433 
<a name="l09434"></a>09434                 } <span class="comment">/* k loop */</span>
<a name="l09435"></a>09435             } <span class="comment">/* j loop */</span>
<a name="l09436"></a>09436         } <span class="comment">/* i loop */</span>
<a name="l09437"></a>09437 
<a name="l09438"></a>09438         force[0] = -force[0]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l09439"></a>09439         force[1] = -force[1]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l09440"></a>09440         force[2] = -force[2]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l09441"></a>09441 
<a name="l09442"></a>09442     }
<a name="l09443"></a>09443 }
<a name="l09444"></a>09444 
<a name="l09445"></a>09445 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gac7c5ef967b6b9b7dc5aa276994d689d0" title="Dielectric bounday direct polarization force between permanent multipoles and non-local induced dipol...">Vpmg_dbNLDirectPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *perm, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *nlInduced,
<a name="l09446"></a>09446                                      <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> force[3]) {
<a name="l09447"></a>09447      <a class="code" href="group___vpmg.html#ga3002128af85e2b38031ae380432fe735" title="Dielectric boundary direct polarization force between permanent multipoles and induced dipoles...">Vpmg_dbDirectPolForce</a>(thee, perm, nlInduced, atomID, force);
<a name="l09448"></a>09448 }
<a name="l09449"></a>09449 
<a name="l09450"></a>09450 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga50ee211712af0db8bdfe3fb4f97b4aca" title="Mutual polarization force for induced dipoles based on 5th order B-Splines. This force arises due to ...">Vpmg_qfMutualPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *induced,
<a name="l09451"></a>09451                               <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *nlinduced, <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> force[3]) {
<a name="l09452"></a>09452 
<a name="l09453"></a>09453     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l09454"></a>09454     <span class="keywordtype">double</span> *apos, *dipole, position[3], hx, hy, hzed;
<a name="l09455"></a>09455     <span class="keywordtype">double</span> *u, *unl;
<a name="l09456"></a>09456     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax;
<a name="l09457"></a>09457     <span class="keywordtype">double</span> de[3][3], denl[3][3];
<a name="l09458"></a>09458     <span class="keywordtype">double</span> mx, my, mz, dmx, dmy, dmz, d2mx, d2my, d2mz, mi, mj, mk;
<a name="l09459"></a>09459     <span class="keywordtype">double</span> ifloat, jfloat, kfloat;
<a name="l09460"></a>09460     <span class="keywordtype">double</span> f, fnl, uix, uiy, uiz, uixnl, uiynl, uiznl;
<a name="l09461"></a>09461     <span class="keywordtype">int</span> i,j,k,nx, ny, nz, im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1;
<a name="l09462"></a>09462     <span class="keywordtype">int</span> kp1, kp2, ii, jj, kk;
<a name="l09463"></a>09463 
<a name="l09464"></a>09464     VASSERT(thee != VNULL);   <span class="comment">/* PMG object with PBE info. */</span>
<a name="l09465"></a>09465     VASSERT(induced != VNULL); <span class="comment">/* potential due to induced dipoles. */</span>
<a name="l09466"></a>09466     VASSERT(nlinduced != VNULL); <span class="comment">/* potential due to non-local induced dipoles. */</span>
<a name="l09467"></a>09467     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l09468"></a>09468     VASSERT(atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);    <span class="comment">/* all atoms must be in the same partition. */</span>
<a name="l09469"></a>09469     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l09470"></a>09470     dipole = Vatom_getInducedDipole(atom);
<a name="l09471"></a>09471     uix = dipole[0];
<a name="l09472"></a>09472     uiy = dipole[1];
<a name="l09473"></a>09473     uiz = dipole[2];
<a name="l09474"></a>09474     dipole = Vatom_getNLInducedDipole(atom);
<a name="l09475"></a>09475     uixnl = dipole[0];
<a name="l09476"></a>09476     uiynl = dipole[1];
<a name="l09477"></a>09477     uiznl = dipole[2];
<a name="l09478"></a>09478     u = induced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l09479"></a>09479     unl = nlinduced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l09480"></a>09480 
<a name="l09481"></a>09481     <span class="keywordflow">for</span> (i=0;i&lt;3;i++){
<a name="l09482"></a>09482        <span class="keywordflow">for</span> (j=0;j&lt;3;j++){
<a name="l09483"></a>09483           de[i][j] = 0.0;
<a name="l09484"></a>09484           denl[i][j] = 0.0;
<a name="l09485"></a>09485        }
<a name="l09486"></a>09486     }
<a name="l09487"></a>09487 
<a name="l09488"></a>09488     <span class="comment">/* Mesh info */</span>
<a name="l09489"></a>09489     nx = induced-&gt;<a class="code" href="structs_vgrid.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l09490"></a>09490     ny = induced-&gt;<a class="code" href="structs_vgrid.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l09491"></a>09491     nz = induced-&gt;<a class="code" href="structs_vgrid.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l09492"></a>09492     hx = induced-&gt;<a class="code" href="structs_vgrid.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l09493"></a>09493     hy = induced-&gt;<a class="code" href="structs_vgrid.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l09494"></a>09494     hzed = induced-&gt;<a class="code" href="structs_vgrid.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l09495"></a>09495     xmin = induced-&gt;<a class="code" href="structs_vgrid.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l09496"></a>09496     ymin = induced-&gt;<a class="code" href="structs_vgrid.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l09497"></a>09497     zmin = induced-&gt;<a class="code" href="structs_vgrid.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l09498"></a>09498     xmax = induced-&gt;<a class="code" href="structs_vgrid.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l09499"></a>09499     ymax = induced-&gt;<a class="code" href="structs_vgrid.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l09500"></a>09500     zmax = induced-&gt;<a class="code" href="structs_vgrid.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l09501"></a>09501     xlen = xmax-xmin;
<a name="l09502"></a>09502     ylen = ymax-ymin;
<a name="l09503"></a>09503     zlen = zmax-zmin;
<a name="l09504"></a>09504 
<a name="l09505"></a>09505     <span class="comment">/* If we aren&#39;t in the current position, then we&#39;re done */</span>
<a name="l09506"></a>09506     <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> == 0) <span class="keywordflow">return</span>;
<a name="l09507"></a>09507 
<a name="l09508"></a>09508     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l09509"></a>09509     <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin+2*hx))   || (apos[0]&gt;=(xmax-2*hx)) \
<a name="l09510"></a>09510      || (apos[1]&lt;=(ymin+2*hy))   || (apos[1]&gt;=(ymax-2*hy)) \
<a name="l09511"></a>09511      || (apos[2]&lt;=(zmin+2*hzed)) || (apos[2]&gt;=(zmax-2*hzed))) {
<a name="l09512"></a>09512         Vnm_print(2, <span class="stringliteral">&quot;qfMutualPolForce:  Atom off the mesh (ignoring) %6.3f %6.3f %6.3f\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l09513"></a>09513         fflush(stderr);
<a name="l09514"></a>09514     } <span class="keywordflow">else</span> {
<a name="l09515"></a>09515 
<a name="l09516"></a>09516         <span class="comment">/* Convert the atom position to grid coordinates */</span>
<a name="l09517"></a>09517         position[0] = apos[0] - xmin;
<a name="l09518"></a>09518         position[1] = apos[1] - ymin;
<a name="l09519"></a>09519         position[2] = apos[2] - zmin;
<a name="l09520"></a>09520         ifloat = position[0]/hx;
<a name="l09521"></a>09521         jfloat = position[1]/hy;
<a name="l09522"></a>09522         kfloat = position[2]/hzed;
<a name="l09523"></a>09523         ip1 = (int)ceil(ifloat);
<a name="l09524"></a>09524         ip2 = ip1 + 2;
<a name="l09525"></a>09525         im1 = (int)floor(ifloat);
<a name="l09526"></a>09526         im2 = im1 - 2;
<a name="l09527"></a>09527         jp1 = (int)ceil(jfloat);
<a name="l09528"></a>09528         jp2 = jp1 + 2;
<a name="l09529"></a>09529         jm1 = (int)floor(jfloat);
<a name="l09530"></a>09530         jm2 = jm1 - 2;
<a name="l09531"></a>09531         kp1 = (int)ceil(kfloat);
<a name="l09532"></a>09532         kp2 = kp1 + 2;
<a name="l09533"></a>09533         km1 = (int)floor(kfloat);
<a name="l09534"></a>09534         km2 = km1 - 2;
<a name="l09535"></a>09535 
<a name="l09536"></a>09536         <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l09537"></a>09537 <span class="comment">         * later on if something goes wrong */</span>
<a name="l09538"></a>09538         ip2 = VMIN2(ip2,nx-1);
<a name="l09539"></a>09539         ip1 = VMIN2(ip1,nx-1);
<a name="l09540"></a>09540         im1 = VMAX2(im1,0);
<a name="l09541"></a>09541         im2 = VMAX2(im2,0);
<a name="l09542"></a>09542         jp2 = VMIN2(jp2,ny-1);
<a name="l09543"></a>09543         jp1 = VMIN2(jp1,ny-1);
<a name="l09544"></a>09544         jm1 = VMAX2(jm1,0);
<a name="l09545"></a>09545         jm2 = VMAX2(jm2,0);
<a name="l09546"></a>09546         kp2 = VMIN2(kp2,nz-1);
<a name="l09547"></a>09547         kp1 = VMIN2(kp1,nz-1);
<a name="l09548"></a>09548         km1 = VMAX2(km1,0);
<a name="l09549"></a>09549         km2 = VMAX2(km2,0);
<a name="l09550"></a>09550 
<a name="l09551"></a>09551         <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l09552"></a>09552             mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l09553"></a>09553             mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l09554"></a>09554             dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l09555"></a>09555             d2mx = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mi);
<a name="l09556"></a>09556             <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l09557"></a>09557                 mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l09558"></a>09558                 my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l09559"></a>09559                 dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l09560"></a>09560                 d2my = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mj);
<a name="l09561"></a>09561                 <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l09562"></a>09562                     mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l09563"></a>09563                     mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l09564"></a>09564                     dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l09565"></a>09565                     d2mz = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mk);
<a name="l09566"></a>09566                     f = u[IJK(ii,jj,kk)];
<a name="l09567"></a>09567                     fnl = unl[IJK(ii,jj,kk)];
<a name="l09568"></a>09568 
<a name="l09569"></a>09569                     <span class="comment">/* The gradient of the reaction field</span>
<a name="l09570"></a>09570 <span class="comment">                       due to induced dipoles */</span>
<a name="l09571"></a>09571                     de[0][0] += f*d2mx*my*mz/(hx*hx);
<a name="l09572"></a>09572                     de[1][0] += f*dmx*dmy*mz/(hy*hx);
<a name="l09573"></a>09573                     de[1][1] += f*mx*d2my*mz/(hy*hy);
<a name="l09574"></a>09574                     de[2][0] += f*dmx*my*dmz/(hx*hzed);
<a name="l09575"></a>09575                     de[2][1] += f*mx*dmy*dmz/(hy*hzed);
<a name="l09576"></a>09576                     de[2][2] += f*mx*my*d2mz/(hzed*hzed);
<a name="l09577"></a>09577 
<a name="l09578"></a>09578                     <span class="comment">/* The gradient of the reaction field</span>
<a name="l09579"></a>09579 <span class="comment">                       due to non-local induced dipoles */</span>
<a name="l09580"></a>09580                     denl[0][0] += fnl*d2mx*my*mz/(hx*hx);
<a name="l09581"></a>09581                     denl[1][0] += fnl*dmx*dmy*mz/(hy*hx);
<a name="l09582"></a>09582                     denl[1][1] += fnl*mx*d2my*mz/(hy*hy);
<a name="l09583"></a>09583                     denl[2][0] += fnl*dmx*my*dmz/(hx*hzed);
<a name="l09584"></a>09584                     denl[2][1] += fnl*mx*dmy*dmz/(hy*hzed);
<a name="l09585"></a>09585                     denl[2][2] += fnl*mx*my*d2mz/(hzed*hzed);
<a name="l09586"></a>09586                 }
<a name="l09587"></a>09587             }
<a name="l09588"></a>09588         }
<a name="l09589"></a>09589     }
<a name="l09590"></a>09590 
<a name="l09591"></a>09591     <span class="comment">/* mutual polarization force */</span>
<a name="l09592"></a>09592     force[0] = -(de[0][0]*uixnl + de[1][0]*uiynl + de[2][0]*uiznl);
<a name="l09593"></a>09593     force[1] = -(de[1][0]*uixnl + de[1][1]*uiynl + de[2][1]*uiznl);
<a name="l09594"></a>09594     force[2] = -(de[2][0]*uixnl + de[2][1]*uiynl + de[2][2]*uiznl);
<a name="l09595"></a>09595     force[0] -=  denl[0][0]*uix + denl[1][0]*uiy + denl[2][0]*uiz;
<a name="l09596"></a>09596     force[1] -=  denl[1][0]*uix + denl[1][1]*uiy + denl[2][1]*uiz;
<a name="l09597"></a>09597     force[2] -=  denl[2][0]*uix + denl[2][1]*uiy + denl[2][2]*uiz;
<a name="l09598"></a>09598 
<a name="l09599"></a>09599     force[0] = 0.5 * force[0];
<a name="l09600"></a>09600     force[1] = 0.5 * force[1];
<a name="l09601"></a>09601     force[2] = 0.5 * force[2];
<a name="l09602"></a>09602 
<a name="l09603"></a>09603 }
<a name="l09604"></a>09604 
<a name="l09605"></a>09605 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga8079ccc5a2b7af75a38d5951465aa1c5" title="Ionic boundary mutual polarization force for induced dipoles based on 5th order B-Splines. This force arises due to self-consistent convergence of the solute induced dipoles and reaction field.">Vpmg_ibMutualPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *induced, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *nlinduced,
<a name="l09606"></a>09606                                    <span class="keywordtype">int</span> atomID, <span class="keywordtype">double</span> force[3]) {
<a name="l09607"></a>09607 
<a name="l09608"></a>09608     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l09609"></a>09609     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l09610"></a>09610     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l09611"></a>09611     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09612"></a>09612     <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm;
<a name="l09613"></a>09613 
<a name="l09614"></a>09614     <span class="keywordtype">double</span> *apos, position[3], arad, irad, zkappa2, hx, hy, hzed;
<a name="l09615"></a>09615     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax, rtot2;
<a name="l09616"></a>09616     <span class="keywordtype">double</span> rtot, dx, dx2, dy, dy2, dz, dz2, gpos[3], tgrad[3], fmag;
<a name="l09617"></a>09617     <span class="keywordtype">double</span> izmagic;
<a name="l09618"></a>09618     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, imin, imax, jmin, jmax, kmin, kmax;
<a name="l09619"></a>09619 
<a name="l09620"></a>09620     VASSERT(thee != VNULL);        <span class="comment">/* We need a PMG object with PBE info. */</span>
<a name="l09621"></a>09621     VASSERT(induced != VNULL);     <span class="comment">/* We need the potential due to induced dipoles. */</span>
<a name="l09622"></a>09622     VASSERT(nlinduced != VNULL);   <span class="comment">/* We need the potential due to non-local induced dipoles. */</span>
<a name="l09623"></a>09623     VASSERT (!thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad7b924f1c23e72861d74d43aedd60a27">nonlin</a>); <span class="comment">/* Nonlinear PBE is not implemented for AMOEBA */</span>
<a name="l09624"></a>09624 
<a name="l09625"></a>09625     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l09626"></a>09626     VASSERT (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0);   <span class="comment">/* Currently all atoms must be in the same partition. */</span>
<a name="l09627"></a>09627 
<a name="l09628"></a>09628     acc = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l09629"></a>09629     srfm = thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>;
<a name="l09630"></a>09630     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l09631"></a>09631     arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l09632"></a>09632 
<a name="l09633"></a>09633     <span class="comment">/* Reset force */</span>
<a name="l09634"></a>09634     force[0] = 0.0;
<a name="l09635"></a>09635     force[1] = 0.0;
<a name="l09636"></a>09636     force[2] = 0.0;
<a name="l09637"></a>09637 
<a name="l09638"></a>09638     <span class="comment">/* If we aren&#39;t in the current position, then we&#39;re done */</span>
<a name="l09639"></a>09639     <span class="keywordflow">if</span> (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> == 0) <span class="keywordflow">return</span>;
<a name="l09640"></a>09640 
<a name="l09641"></a>09641     <span class="comment">/* Get PBE info */</span>
<a name="l09642"></a>09642     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09643"></a>09643     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l09644"></a>09644     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l09645"></a>09645     irad = <a class="code" href="group___vpbe.html#gabf77d3500a5e3b3c8673eab703bb53e0" title="Get maximum radius of ion species.">Vpbe_getMaxIonRadius</a>(pbe);
<a name="l09646"></a>09646     zkappa2 = <a class="code" href="group___vpbe.html#ga56e38face81d2d29659541b5e3f5e442" title="Get modified squared Debye-Huckel parameter.">Vpbe_getZkappa2</a>(pbe);
<a name="l09647"></a>09647     izmagic = 1.0/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l09648"></a>09648 
<a name="l09649"></a>09649     VASSERT (zkappa2 &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>); <span class="comment">/* Should be a check for this further up.*/</span>
<a name="l09650"></a>09650 
<a name="l09651"></a>09651     <span class="comment">/* Mesh info */</span>
<a name="l09652"></a>09652     nx = induced-&gt;<a class="code" href="structs_vgrid.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l09653"></a>09653     ny = induced-&gt;<a class="code" href="structs_vgrid.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l09654"></a>09654     nz = induced-&gt;<a class="code" href="structs_vgrid.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l09655"></a>09655     hx = induced-&gt;<a class="code" href="structs_vgrid.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l09656"></a>09656     hy = induced-&gt;<a class="code" href="structs_vgrid.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l09657"></a>09657     hzed = induced-&gt;<a class="code" href="structs_vgrid.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l09658"></a>09658     xmin = induced-&gt;<a class="code" href="structs_vgrid.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l09659"></a>09659     ymin = induced-&gt;<a class="code" href="structs_vgrid.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l09660"></a>09660     zmin = induced-&gt;<a class="code" href="structs_vgrid.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l09661"></a>09661     xmax = induced-&gt;<a class="code" href="structs_vgrid.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l09662"></a>09662     ymax = induced-&gt;<a class="code" href="structs_vgrid.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l09663"></a>09663     zmax = induced-&gt;<a class="code" href="structs_vgrid.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l09664"></a>09664     xlen = xmax-xmin;
<a name="l09665"></a>09665     ylen = ymax-ymin;
<a name="l09666"></a>09666     zlen = zmax-zmin;
<a name="l09667"></a>09667 
<a name="l09668"></a>09668     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l09669"></a>09669     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l09670"></a>09670       (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l09671"></a>09671       (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l09672"></a>09672         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibMutalPolForce:  Atom at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l09673"></a>09673         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibMutalPolForce:    xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l09674"></a>09674         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibMutalPolForce:    ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l09675"></a>09675         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_ibMutalPolForce:    zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l09676"></a>09676         fflush(stderr);
<a name="l09677"></a>09677     } <span class="keywordflow">else</span> {
<a name="l09678"></a>09678 
<a name="l09679"></a>09679         <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l09680"></a>09680         position[0] = apos[0] - xmin;
<a name="l09681"></a>09681         position[1] = apos[1] - ymin;
<a name="l09682"></a>09682         position[2] = apos[2] - zmin;
<a name="l09683"></a>09683 
<a name="l09684"></a>09684         <span class="comment">/* Integrate over points within this atom&#39;s (inflated) radius */</span>
<a name="l09685"></a>09685         rtot = (irad + arad + thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>);
<a name="l09686"></a>09686         rtot2 = VSQR(rtot);
<a name="l09687"></a>09687         dx = rtot + 0.5*hx;
<a name="l09688"></a>09688         imin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[0] - dx)/hx));
<a name="l09689"></a>09689         imax = VMIN2(nx-1,(<span class="keywordtype">int</span>)floor((position[0] + dx)/hx));
<a name="l09690"></a>09690         <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l09691"></a>09691             dx2 = VSQR(position[0] - hx*i);
<a name="l09692"></a>09692             <span class="keywordflow">if</span> (rtot2 &gt; dx2) dy = VSQRT(rtot2 - dx2) + 0.5*hy;
<a name="l09693"></a>09693             <span class="keywordflow">else</span> dy = 0.5*hy;
<a name="l09694"></a>09694             jmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[1] - dy)/hy));
<a name="l09695"></a>09695             jmax = VMIN2(ny-1,(<span class="keywordtype">int</span>)floor((position[1] + dy)/hy));
<a name="l09696"></a>09696             <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l09697"></a>09697                 dy2 = VSQR(position[1] - hy*j);
<a name="l09698"></a>09698                 <span class="keywordflow">if</span> (rtot2 &gt; (dx2+dy2)) dz = VSQRT(rtot2-dx2-dy2)+0.5*hzed;
<a name="l09699"></a>09699                 <span class="keywordflow">else</span> dz = 0.5*hzed;
<a name="l09700"></a>09700                 kmin = VMAX2(0,(<span class="keywordtype">int</span>)ceil((position[2] - dz)/hzed));
<a name="l09701"></a>09701                 kmax = VMIN2(nz-1,(<span class="keywordtype">int</span>)floor((position[2] + dz)/hzed));
<a name="l09702"></a>09702                 <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l09703"></a>09703                     dz2 = VSQR(k*hzed - position[2]);
<a name="l09704"></a>09704                     <span class="comment">/* See if grid point is inside ivdw radius and set ccf</span>
<a name="l09705"></a>09705 <span class="comment">                     * accordingly (do spline assignment here) */</span>
<a name="l09706"></a>09706                     <span class="keywordflow">if</span> ((dz2 + dy2 + dx2) &lt;= rtot2) {
<a name="l09707"></a>09707                         gpos[0] = i*hx + xmin;
<a name="l09708"></a>09708                         gpos[1] = j*hy + ymin;
<a name="l09709"></a>09709                         gpos[2] = k*hzed + zmin;
<a name="l09710"></a>09710                         <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, irad,
<a name="l09711"></a>09711                           atom, tgrad);
<a name="l09712"></a>09712                         fmag = induced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>[IJK(i,j,k)];
<a name="l09713"></a>09713                         fmag *= nlinduced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>[IJK(i,j,k)];
<a name="l09714"></a>09714                         fmag *= thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)];
<a name="l09715"></a>09715                         force[0] += (zkappa2*fmag*tgrad[0]);
<a name="l09716"></a>09716                         force[1] += (zkappa2*fmag*tgrad[1]);
<a name="l09717"></a>09717                         force[2] += (zkappa2*fmag*tgrad[2]);
<a name="l09718"></a>09718                     }
<a name="l09719"></a>09719                 } <span class="comment">/* k loop */</span>
<a name="l09720"></a>09720             } <span class="comment">/* j loop */</span>
<a name="l09721"></a>09721         } <span class="comment">/* i loop */</span>
<a name="l09722"></a>09722     }
<a name="l09723"></a>09723 
<a name="l09724"></a>09724     force[0] = force[0] * 0.5 * hx * hy * hzed * izmagic;
<a name="l09725"></a>09725     force[1] = force[1] * 0.5 * hx * hy * hzed * izmagic;
<a name="l09726"></a>09726     force[2] = force[2] * 0.5 * hx * hy * hzed * izmagic;
<a name="l09727"></a>09727 }
<a name="l09728"></a>09728 
<a name="l09729"></a>09729 VPUBLIC <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga0dc448837df168e881f733a9f98b7714" title="Dielectric boundary mutual polarization force for induced dipoles based on 5th order B-Splines...">Vpmg_dbMutualPolForce</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee, <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *induced,
<a name="l09730"></a>09730                                    <a class="code" href="structs_vgrid.html" title="Electrostatic potential oracle for Cartesian mesh data.">Vgrid</a> *nlinduced, <span class="keywordtype">int</span> atomID,
<a name="l09731"></a>09731                                    <span class="keywordtype">double</span> force[3]) {
<a name="l09732"></a>09732 
<a name="l09733"></a>09733     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l09734"></a>09734     <a class="code" href="structs_vacc.html" title="Oracle for solvent- and ion-accessibility around a biomolecule.">Vacc</a> *acc;
<a name="l09735"></a>09735     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09736"></a>09736     <a class="code" href="group___vhal.html#ga5ccf1935e3604af8c42bc644b3979304" title="Declaration of the Vsurf_Meth type as the Vsurf_Meth enum.">Vsurf_Meth</a> srfm;
<a name="l09737"></a>09737 
<a name="l09738"></a>09738     <span class="keywordtype">double</span> *apos, position[3], arad, hx, hy, hzed, izmagic, deps, depsi;
<a name="l09739"></a>09739     <span class="keywordtype">double</span> xlen, ylen, zlen, xmin, ymin, zmin, xmax, ymax, zmax, rtot2, epsp;
<a name="l09740"></a>09740     <span class="keywordtype">double</span> rtot, dx, gpos[3], tgrad[3], dbFmag, epsw, kT;
<a name="l09741"></a>09741     <span class="keywordtype">double</span> *u, *unl, Hxijk, Hyijk, Hzijk, Hxim1jk, Hyijm1k, Hzijkm1;
<a name="l09742"></a>09742     <span class="keywordtype">double</span> dHxijk[3], dHyijk[3], dHzijk[3], dHxim1jk[3], dHyijm1k[3];
<a name="l09743"></a>09743     <span class="keywordtype">double</span> dHzijkm1[3];
<a name="l09744"></a>09744     <span class="keywordtype">int</span> i, j, k, l, nx, ny, nz, imin, imax, jmin, jmax, kmin, kmax;
<a name="l09745"></a>09745 
<a name="l09746"></a>09746     VASSERT(thee != VNULL); <span class="comment">/* PMG object with PBE info. */</span>
<a name="l09747"></a>09747     VASSERT(induced != VNULL); <span class="comment">/* potential due to induced dipoles.*/</span>
<a name="l09748"></a>09748     VASSERT(nlinduced != VNULL); <span class="comment">/* potential due to non-local induced dipoles.*/</span>
<a name="l09749"></a>09749 
<a name="l09750"></a>09750     acc = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l09751"></a>09751     srfm = thee-&gt;<a class="code" href="structs_vpmg.html#acbb8e8ee0c4e779c7fb16d59ef07ddfc">surfMeth</a>;
<a name="l09752"></a>09752     atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>, atomID);
<a name="l09753"></a>09753     VASSERT (atom-&gt;<a class="code" href="structs_vatom.html#ad764ef856af40b026335ce3d1caefcde">partID</a> != 0); <span class="comment">/* all atoms must be in the same partition.*/</span>
<a name="l09754"></a>09754     apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l09755"></a>09755     arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l09756"></a>09756 
<a name="l09757"></a>09757     <span class="comment">/* Reset force */</span>
<a name="l09758"></a>09758     force[0] = 0.0;
<a name="l09759"></a>09759     force[1] = 0.0;
<a name="l09760"></a>09760     force[2] = 0.0;
<a name="l09761"></a>09761 
<a name="l09762"></a>09762     <span class="comment">/* Get PBE info */</span>
<a name="l09763"></a>09763     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09764"></a>09764     acc = pbe-&gt;<a class="code" href="structs_vpbe.html#a7d9be58fd45767b82b6b320e3f6052e0">acc</a>;
<a name="l09765"></a>09765     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l09766"></a>09766     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l09767"></a>09767     kT = <a class="code" href="group___vpbe.html#gae9aa99eb531a803268fc963796c3bba2" title="Get temperature.">Vpbe_getTemperature</a>(pbe)*(1e-3)*<a class="code" href="group___vunit.html#gae194adb8dae1861b5d34d4fc9d2afc86" title="Avogadro&#39;s number.">Vunit_Na</a>*<a class="code" href="group___vunit.html#ga40e8477a103f27ff0b5f5ce0719c4306" title="Boltzmann constant.">Vunit_kb</a>;
<a name="l09768"></a>09768     izmagic = 1.0/<a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l09769"></a>09769 
<a name="l09770"></a>09770     deps = (epsw - epsp);
<a name="l09771"></a>09771     depsi = 1.0/deps;
<a name="l09772"></a>09772     VASSERT(VABS(deps) &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>);
<a name="l09773"></a>09773 
<a name="l09774"></a>09774     <span class="comment">/* Mesh info */</span>
<a name="l09775"></a>09775     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l09776"></a>09776     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l09777"></a>09777     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l09778"></a>09778     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l09779"></a>09779     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l09780"></a>09780     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l09781"></a>09781     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l09782"></a>09782     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l09783"></a>09783     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l09784"></a>09784     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab5bbe897a0c25c58341c216a1b31fbbf">xmin</a>;
<a name="l09785"></a>09785     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a8c17b15efd6e0337c596d98616e9b9da">ymin</a>;
<a name="l09786"></a>09786     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#aaea53ab3c236de8e4f167c3807d35b47">zmin</a>;
<a name="l09787"></a>09787     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a30554afc6599846bcd01cbf986d0998a">xmax</a>;
<a name="l09788"></a>09788     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#afc6ae6b11b9521d908c52e4fb3ea09ce">ymax</a>;
<a name="l09789"></a>09789     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ade09ae0d27b0b7a2d1e886efc6d1a500">zmax</a>;
<a name="l09790"></a>09790     u = induced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l09791"></a>09791     unl = nlinduced-&gt;<a class="code" href="structs_vgrid.html#a23436a7a2b44939627b59df11be7ad75">data</a>;
<a name="l09792"></a>09792 
<a name="l09793"></a>09793     <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l09794"></a>09794     <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l09795"></a>09795       (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l09796"></a>09796       (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l09797"></a>09797         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:  Atom at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring):\n&quot;</span>, apos[0], apos[1], apos[2]);
<a name="l09798"></a>09798         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:    xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l09799"></a>09799         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:    ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l09800"></a>09800         Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:    zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l09801"></a>09801         fflush(stderr);
<a name="l09802"></a>09802     } <span class="keywordflow">else</span> {
<a name="l09803"></a>09803 
<a name="l09804"></a>09804         <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l09805"></a>09805         position[0] = apos[0] - xmin;
<a name="l09806"></a>09806         position[1] = apos[1] - ymin;
<a name="l09807"></a>09807         position[2] = apos[2] - zmin;
<a name="l09808"></a>09808 
<a name="l09809"></a>09809         <span class="comment">/* Integrate over points within this atom&#39;s (inflated) radius */</span>
<a name="l09810"></a>09810         rtot = (arad + thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>);
<a name="l09811"></a>09811         rtot2 = VSQR(rtot);
<a name="l09812"></a>09812         dx = rtot/hx;
<a name="l09813"></a>09813         imin = (int)floor((position[0]-rtot)/hx);
<a name="l09814"></a>09814         <span class="keywordflow">if</span> (imin &lt; 1) {
<a name="l09815"></a>09815             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09816"></a>09816             <span class="keywordflow">return</span>;
<a name="l09817"></a>09817         }
<a name="l09818"></a>09818         imax = (int)ceil((position[0]+rtot)/hx);
<a name="l09819"></a>09819         <span class="keywordflow">if</span> (imax &gt; (nx-2)) {
<a name="l09820"></a>09820             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09821"></a>09821             <span class="keywordflow">return</span>;
<a name="l09822"></a>09822         }
<a name="l09823"></a>09823         jmin = (int)floor((position[1]-rtot)/hy);
<a name="l09824"></a>09824         <span class="keywordflow">if</span> (jmin &lt; 1) {
<a name="l09825"></a>09825             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09826"></a>09826             <span class="keywordflow">return</span>;
<a name="l09827"></a>09827         }
<a name="l09828"></a>09828         jmax = (int)ceil((position[1]+rtot)/hy);
<a name="l09829"></a>09829         <span class="keywordflow">if</span> (jmax &gt; (ny-2)) {
<a name="l09830"></a>09830             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09831"></a>09831             <span class="keywordflow">return</span>;
<a name="l09832"></a>09832         }
<a name="l09833"></a>09833         kmin = (int)floor((position[2]-rtot)/hzed);
<a name="l09834"></a>09834         <span class="keywordflow">if</span> (kmin &lt; 1) {
<a name="l09835"></a>09835             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09836"></a>09836             <span class="keywordflow">return</span>;
<a name="l09837"></a>09837         }
<a name="l09838"></a>09838         kmax = (int)ceil((position[2]+rtot)/hzed);
<a name="l09839"></a>09839         <span class="keywordflow">if</span> (kmax &gt; (nz-2)) {
<a name="l09840"></a>09840             Vnm_print(2, <span class="stringliteral">&quot;Vpmg_dbMutualPolForce:  Atom %d off grid!\n&quot;</span>, atomID);
<a name="l09841"></a>09841             <span class="keywordflow">return</span>;
<a name="l09842"></a>09842         }
<a name="l09843"></a>09843         <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l09844"></a>09844             <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l09845"></a>09845                 <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l09846"></a>09846                     <span class="comment">/* i,j,k */</span>
<a name="l09847"></a>09847                     gpos[0] = (i+0.5)*hx + xmin;
<a name="l09848"></a>09848                     gpos[1] = j*hy + ymin;
<a name="l09849"></a>09849                     gpos[2] = k*hzed + zmin;
<a name="l09850"></a>09850                     Hxijk = (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l09851"></a>09851                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09852"></a>09852                             atom, dHxijk);
<a name="l09853"></a>09853                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHxijk[l] *= Hxijk;
<a name="l09854"></a>09854                     gpos[0] = i*hx + xmin;
<a name="l09855"></a>09855                     gpos[1] = (j+0.5)*hy + ymin;
<a name="l09856"></a>09856                     gpos[2] = k*hzed + zmin;
<a name="l09857"></a>09857                     Hyijk = (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l09858"></a>09858                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09859"></a>09859                             atom, dHyijk);
<a name="l09860"></a>09860                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHyijk[l] *= Hyijk;
<a name="l09861"></a>09861                     gpos[0] = i*hx + xmin;
<a name="l09862"></a>09862                     gpos[1] = j*hy + ymin;
<a name="l09863"></a>09863                     gpos[2] = (k+0.5)*hzed + zmin;
<a name="l09864"></a>09864                     Hzijk = (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] - epsp)*depsi;
<a name="l09865"></a>09865                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09866"></a>09866                             atom, dHzijk);
<a name="l09867"></a>09867                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHzijk[l] *= Hzijk;
<a name="l09868"></a>09868                     <span class="comment">/* i-1,j,k */</span>
<a name="l09869"></a>09869                     gpos[0] = (i-0.5)*hx + xmin;
<a name="l09870"></a>09870                     gpos[1] = j*hy + ymin;
<a name="l09871"></a>09871                     gpos[2] = k*hzed + zmin;
<a name="l09872"></a>09872                     Hxim1jk = (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i-1,j,k)] - epsp)*depsi;
<a name="l09873"></a>09873                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09874"></a>09874                             atom, dHxim1jk);
<a name="l09875"></a>09875                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHxim1jk[l] *= Hxim1jk;
<a name="l09876"></a>09876                     <span class="comment">/* i,j-1,k */</span>
<a name="l09877"></a>09877                     gpos[0] = i*hx + xmin;
<a name="l09878"></a>09878                     gpos[1] = (j-0.5)*hy + ymin;
<a name="l09879"></a>09879                     gpos[2] = k*hzed + zmin;
<a name="l09880"></a>09880                     Hyijm1k = (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j-1,k)] - epsp)*depsi;
<a name="l09881"></a>09881                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09882"></a>09882                             atom, dHyijm1k);
<a name="l09883"></a>09883                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHyijm1k[l] *= Hyijm1k;
<a name="l09884"></a>09884                     <span class="comment">/* i,j,k-1 */</span>
<a name="l09885"></a>09885                     gpos[0] = i*hx + xmin;
<a name="l09886"></a>09886                     gpos[1] = j*hy + ymin;
<a name="l09887"></a>09887                     gpos[2] = (k-0.5)*hzed + zmin;
<a name="l09888"></a>09888                     Hzijkm1 = (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k-1)] - epsp)*depsi;
<a name="l09889"></a>09889                     <a class="code" href="vpmg_8c.html#a1271687db8aa07b73c4ce3316943b72c" title="Selects a spline based surface method from either VSM_SPLINE, VSM_SPLINE5 or VSM_SPLINE7.">Vpmg_splineSelect</a>(srfm, acc, gpos, thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>, 0.,
<a name="l09890"></a>09890                             atom, dHzijkm1);
<a name="l09891"></a>09891                     <span class="keywordflow">for</span> (l=0; l&lt;3; l++) dHzijkm1[l] *= Hzijkm1;
<a name="l09892"></a>09892                     dbFmag = unl[IJK(i,j,k)];
<a name="l09893"></a>09893                     tgrad[0] =
<a name="l09894"></a>09894                        (dHxijk[0]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l09895"></a>09895                      +  dHxim1jk[0]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l09896"></a>09896                      + (dHyijk[0]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l09897"></a>09897                      +  dHyijm1k[0]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l09898"></a>09898                      + (dHzijk[0]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l09899"></a>09899                      + dHzijkm1[0]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l09900"></a>09900                     tgrad[1] =
<a name="l09901"></a>09901                        (dHxijk[1]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l09902"></a>09902                      +  dHxim1jk[1]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l09903"></a>09903                      + (dHyijk[1]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l09904"></a>09904                      +  dHyijm1k[1]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l09905"></a>09905                      + (dHzijk[1]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l09906"></a>09906                      + dHzijkm1[1]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l09907"></a>09907                     tgrad[2] =
<a name="l09908"></a>09908                        (dHxijk[2]  *(u[IJK(i+1,j,k)]-u[IJK(i,j,k)])
<a name="l09909"></a>09909                      +  dHxim1jk[2]*(u[IJK(i-1,j,k)]-u[IJK(i,j,k)]))/VSQR(hx)
<a name="l09910"></a>09910                      + (dHyijk[2]  *(u[IJK(i,j+1,k)]-u[IJK(i,j,k)])
<a name="l09911"></a>09911                      +  dHyijm1k[2]*(u[IJK(i,j-1,k)]-u[IJK(i,j,k)]))/VSQR(hy)
<a name="l09912"></a>09912                      + (dHzijk[2]  *(u[IJK(i,j,k+1)]-u[IJK(i,j,k)])
<a name="l09913"></a>09913                      + dHzijkm1[2]*(u[IJK(i,j,k-1)]-u[IJK(i,j,k)]))/VSQR(hzed);
<a name="l09914"></a>09914                      force[0] += (dbFmag*tgrad[0]);
<a name="l09915"></a>09915                      force[1] += (dbFmag*tgrad[1]);
<a name="l09916"></a>09916                      force[2] += (dbFmag*tgrad[2]);
<a name="l09917"></a>09917                 } <span class="comment">/* k loop */</span>
<a name="l09918"></a>09918             } <span class="comment">/* j loop */</span>
<a name="l09919"></a>09919         } <span class="comment">/* i loop */</span>
<a name="l09920"></a>09920 
<a name="l09921"></a>09921         force[0] = -force[0]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l09922"></a>09922         force[1] = -force[1]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l09923"></a>09923         force[2] = -force[2]*hx*hy*hzed*deps*0.5*izmagic;
<a name="l09924"></a>09924     }
<a name="l09925"></a>09925 }
<a name="l09926"></a>09926 
<a name="l09927"></a>09927 <span class="preprocessor">#endif </span><span class="comment">/* if defined(WITH_TINKER) */</span>
<a name="l09928"></a>09928 
<a name="l09929"></a><a class="code" href="vpmg_8h.html#abe8b2056b56093552215f2e97c8f5c1b">09929</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#abe8b2056b56093552215f2e97c8f5c1b" title="Fill operator coefficient arrays from a 7th order polynomial based surface calculation.">fillcoCoefSpline4</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l09930"></a>09930 
<a name="l09931"></a>09931     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l09932"></a>09932     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09933"></a>09933     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l09934"></a>09934     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax, ionmask, ionstr, dist2;
<a name="l09935"></a>09935     <span class="keywordtype">double</span> xlen, ylen, zlen, position[3], itot, stot, ictot, ictot2, sctot;
<a name="l09936"></a>09936     <span class="keywordtype">double</span> irad, dx, dy, dz, epsw, epsp, w2i;
<a name="l09937"></a>09937     <span class="keywordtype">double</span> hx, hy, hzed, *apos, arad, sctot2;
<a name="l09938"></a>09938     <span class="keywordtype">double</span> dx2, dy2, dz2, stot2, itot2, rtot, rtot2, splineWin;
<a name="l09939"></a>09939     <span class="keywordtype">double</span> dist, value, denom, sm, sm2, sm3, sm4, sm5, sm6, sm7;
<a name="l09940"></a>09940     <span class="keywordtype">double</span> e, e2, e3, e4, e5, e6, e7;
<a name="l09941"></a>09941     <span class="keywordtype">double</span> b, b2, b3, b4, b5, b6, b7;
<a name="l09942"></a>09942     <span class="keywordtype">double</span> c0, c1, c2, c3, c4, c5, c6, c7;
<a name="l09943"></a>09943     <span class="keywordtype">double</span> ic0, ic1, ic2, ic3, ic4, ic5, ic6, ic7;
<a name="l09944"></a>09944     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, iatom;
<a name="l09945"></a>09945     <span class="keywordtype">int</span> imin, imax, jmin, jmax, kmin, kmax;
<a name="l09946"></a>09946 
<a name="l09947"></a>09947     VASSERT(thee != VNULL);
<a name="l09948"></a>09948     splineWin = thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>;
<a name="l09949"></a>09949 
<a name="l09950"></a>09950     <span class="comment">/* Get PBE info */</span>
<a name="l09951"></a>09951     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l09952"></a>09952     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l09953"></a>09953     irad = <a class="code" href="group___vpbe.html#gabf77d3500a5e3b3c8673eab703bb53e0" title="Get maximum radius of ion species.">Vpbe_getMaxIonRadius</a>(pbe);
<a name="l09954"></a>09954     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(pbe);
<a name="l09955"></a>09955     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l09956"></a>09956     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l09957"></a>09957 
<a name="l09958"></a>09958     <span class="comment">/* Mesh info */</span>
<a name="l09959"></a>09959     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l09960"></a>09960     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l09961"></a>09961     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l09962"></a>09962     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l09963"></a>09963     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l09964"></a>09964     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l09965"></a>09965 
<a name="l09966"></a>09966     <span class="comment">/* Define the total domain size */</span>
<a name="l09967"></a>09967     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l09968"></a>09968     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l09969"></a>09969     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l09970"></a>09970 
<a name="l09971"></a>09971     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l09972"></a>09972     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l09973"></a>09973     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l09974"></a>09974     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l09975"></a>09975     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l09976"></a>09976     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l09977"></a>09977     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l09978"></a>09978 
<a name="l09979"></a>09979     <span class="comment">/* This is a floating point parameter related to the non-zero nature of the</span>
<a name="l09980"></a>09980 <span class="comment">     * bulk ionic strength.  If the ionic strength is greater than zero; this</span>
<a name="l09981"></a>09981 <span class="comment">     * parameter is set to 1.0 and later scaled by the appropriate pre-factors.</span>
<a name="l09982"></a>09982 <span class="comment">     * Otherwise, this parameter is set to 0.0 */</span>
<a name="l09983"></a>09983     <span class="keywordflow">if</span> (ionstr &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) ionmask = 1.0;
<a name="l09984"></a>09984     <span class="keywordflow">else</span> ionmask = 0.0;
<a name="l09985"></a>09985 
<a name="l09986"></a>09986     <span class="comment">/* Reset the kappa, epsx, epsy, and epsz arrays */</span>
<a name="l09987"></a>09987     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) {
<a name="l09988"></a>09988         thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] = 1.0;
<a name="l09989"></a>09989         thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i] = 1.0;
<a name="l09990"></a>09990         thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i] = 1.0;
<a name="l09991"></a>09991         thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i] = 1.0;
<a name="l09992"></a>09992     }
<a name="l09993"></a>09993 
<a name="l09994"></a>09994     <span class="comment">/* Loop through the atoms and do assign the dielectric */</span>
<a name="l09995"></a>09995     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l09996"></a>09996 
<a name="l09997"></a>09997         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l09998"></a>09998         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l09999"></a>09999         arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l10000"></a>10000 
<a name="l10001"></a>10001         b = arad - splineWin;
<a name="l10002"></a>10002         e = arad + splineWin;
<a name="l10003"></a>10003         e2 = e * e;
<a name="l10004"></a>10004         e3 = e2 * e;
<a name="l10005"></a>10005         e4 = e3 * e;
<a name="l10006"></a>10006         e5 = e4 * e;
<a name="l10007"></a>10007         e6 = e5 * e;
<a name="l10008"></a>10008         e7 = e6 * e;
<a name="l10009"></a>10009         b2 = b * b;
<a name="l10010"></a>10010         b3 = b2 * b;
<a name="l10011"></a>10011         b4 = b3 * b;
<a name="l10012"></a>10012         b5 = b4 * b;
<a name="l10013"></a>10013         b6 = b5 * b;
<a name="l10014"></a>10014         b7 = b6 * b;
<a name="l10015"></a>10015         denom = e7  - 7.0*b*e6 + 21.0*b2*e5 - 35.0*e4*b3
<a name="l10016"></a>10016               + 35.0*e3*b4 - 21.0*b5*e2  + 7.0*e*b6 - b7;
<a name="l10017"></a>10017         c0 = b4*(35.0*e3 - 21.0*b*e2 + 7*e*b2 - b3)/denom;
<a name="l10018"></a>10018         c1 = -140.0*b3*e3/denom;
<a name="l10019"></a>10019         c2 = 210.0*e2*b2*(e + b)/denom;
<a name="l10020"></a>10020         c3 = -140.0*e*b*(e2 + 3.0*b*e + b2)/denom;
<a name="l10021"></a>10021         c4 =  35.0*(e3 + 9.0*b*e2 + + 9.0*e*b2 + b3)/denom;
<a name="l10022"></a>10022         c5 = -84.0*(e2 + 3.0*b*e + b2)/denom;
<a name="l10023"></a>10023         c6 =  70.0*(e + b)/denom;
<a name="l10024"></a>10024         c7 = -20.0/denom;
<a name="l10025"></a>10025 
<a name="l10026"></a>10026         b = irad + arad - splineWin;
<a name="l10027"></a>10027         e = irad + arad + splineWin;
<a name="l10028"></a>10028         e2 = e * e;
<a name="l10029"></a>10029         e3 = e2 * e;
<a name="l10030"></a>10030         e4 = e3 * e;
<a name="l10031"></a>10031         e5 = e4 * e;
<a name="l10032"></a>10032         e6 = e5 * e;
<a name="l10033"></a>10033         e7 = e6 * e;
<a name="l10034"></a>10034         b2 = b * b;
<a name="l10035"></a>10035         b3 = b2 * b;
<a name="l10036"></a>10036         b4 = b3 * b;
<a name="l10037"></a>10037         b5 = b4 * b;
<a name="l10038"></a>10038         b6 = b5 * b;
<a name="l10039"></a>10039         b7 = b6 * b;
<a name="l10040"></a>10040         denom = e7  - 7.0*b*e6 + 21.0*b2*e5 - 35.0*e4*b3
<a name="l10041"></a>10041               + 35.0*e3*b4 - 21.0*b5*e2  + 7.0*e*b6 - b7;
<a name="l10042"></a>10042         ic0 = b4*(35.0*e3 - 21.0*b*e2 + 7*e*b2 - b3)/denom;
<a name="l10043"></a>10043         ic1 = -140.0*b3*e3/denom;
<a name="l10044"></a>10044         ic2 = 210.0*e2*b2*(e + b)/denom;
<a name="l10045"></a>10045         ic3 = -140.0*e*b*(e2 + 3.0*b*e + b2)/denom;
<a name="l10046"></a>10046         ic4 =  35.0*(e3 + 9.0*b*e2 + + 9.0*e*b2 + b3)/denom;
<a name="l10047"></a>10047         ic5 = -84.0*(e2 + 3.0*b*e + b2)/denom;
<a name="l10048"></a>10048         ic6 =  70.0*(e + b)/denom;
<a name="l10049"></a>10049         ic7 = -20.0/denom;
<a name="l10050"></a>10050 
<a name="l10051"></a>10051         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l10052"></a>10052         <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l10053"></a>10053             (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l10054"></a>10054             (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l10055"></a>10055             <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l10056"></a>10056                 (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l10057"></a>10057                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Atom #%d at (%4.3f, %4.3f,\</span>
<a name="l10058"></a>10058 <span class="stringliteral"> %4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l10059"></a>10059                   iatom, apos[0], apos[1], apos[2]);
<a name="l10060"></a>10060                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    xmin = %g, xmax = %g\n&quot;</span>,
<a name="l10061"></a>10061                   xmin, xmax);
<a name="l10062"></a>10062                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    ymin = %g, ymax = %g\n&quot;</span>,
<a name="l10063"></a>10063                   ymin, ymax);
<a name="l10064"></a>10064                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    zmin = %g, zmax = %g\n&quot;</span>,
<a name="l10065"></a>10065                   zmin, zmax);
<a name="l10066"></a>10066             }
<a name="l10067"></a>10067             fflush(stderr);
<a name="l10068"></a>10068 
<a name="l10069"></a>10069         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arad &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a> ) { <span class="comment">/* if we&#39;re on the mesh */</span>
<a name="l10070"></a>10070 
<a name="l10071"></a>10071             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l10072"></a>10072             position[0] = apos[0] - xmin;
<a name="l10073"></a>10073             position[1] = apos[1] - ymin;
<a name="l10074"></a>10074             position[2] = apos[2] - zmin;
<a name="l10075"></a>10075 
<a name="l10076"></a>10076             <span class="comment">/* MARK ION ACCESSIBILITY AND DIELECTRIC VALUES FOR LATER</span>
<a name="l10077"></a>10077 <span class="comment">             * ASSIGNMENT (Steps #1-3) */</span>
<a name="l10078"></a>10078             itot = irad + arad + splineWin;
<a name="l10079"></a>10079             itot2 = VSQR(itot);
<a name="l10080"></a>10080             ictot = VMAX2(0, (irad + arad - splineWin));
<a name="l10081"></a>10081             ictot2 = VSQR(ictot);
<a name="l10082"></a>10082             stot = arad + splineWin;
<a name="l10083"></a>10083             stot2 = VSQR(stot);
<a name="l10084"></a>10084             sctot = VMAX2(0, (arad - splineWin));
<a name="l10085"></a>10085             sctot2 = VSQR(sctot);
<a name="l10086"></a>10086 
<a name="l10087"></a>10087            <span class="comment">/* We&#39;ll search over grid points which are in the greater of</span>
<a name="l10088"></a>10088 <span class="comment">             * these two radii */</span>
<a name="l10089"></a>10089             rtot = VMAX2(itot, stot);
<a name="l10090"></a>10090             rtot2 = VMAX2(itot2, stot2);
<a name="l10091"></a>10091             dx = rtot + 0.5*hx;
<a name="l10092"></a>10092             dy = rtot + 0.5*hy;
<a name="l10093"></a>10093             dz = rtot + 0.5*hzed;
<a name="l10094"></a>10094             imin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[0] - dx)/hx));
<a name="l10095"></a>10095             imax = VMIN2(nx-1,(<span class="keywordtype">int</span>)ceil((position[0] + dx)/hx));
<a name="l10096"></a>10096             jmin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[1] - dy)/hy));
<a name="l10097"></a>10097             jmax = VMIN2(ny-1,(<span class="keywordtype">int</span>)ceil((position[1] + dy)/hy));
<a name="l10098"></a>10098             kmin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[2] - dz)/hzed));
<a name="l10099"></a>10099             kmax = VMIN2(nz-1,(<span class="keywordtype">int</span>)ceil((position[2] + dz)/hzed));
<a name="l10100"></a>10100             <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l10101"></a>10101                 dx2 = VSQR(position[0] - hx*i);
<a name="l10102"></a>10102                 <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l10103"></a>10103                     dy2 = VSQR(position[1] - hy*j);
<a name="l10104"></a>10104                     <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l10105"></a>10105                         dz2 = VSQR(position[2] - k*hzed);
<a name="l10106"></a>10106 
<a name="l10107"></a>10107                         <span class="comment">/* ASSIGN CCF */</span>
<a name="l10108"></a>10108                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l10109"></a>10109                             dist2 = dz2 + dy2 + dx2;
<a name="l10110"></a>10110                             <span class="keywordflow">if</span> (dist2 &gt;= itot2) {
<a name="l10111"></a>10111                                 ;
<a name="l10112"></a>10112                             }
<a name="l10113"></a>10113                             <span class="keywordflow">if</span> (dist2 &lt;= ictot2) {
<a name="l10114"></a>10114                                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] = 0.0;
<a name="l10115"></a>10115                             }
<a name="l10116"></a>10116                             <span class="keywordflow">if</span> ((dist2 &lt; itot2) &amp;&amp; (dist2 &gt; ictot2)) {
<a name="l10117"></a>10117                                 dist = VSQRT(dist2);
<a name="l10118"></a>10118                                 sm = dist;
<a name="l10119"></a>10119                                 sm2 = dist2;
<a name="l10120"></a>10120                                 sm3 = sm2 * sm;
<a name="l10121"></a>10121                                 sm4 = sm3 * sm;
<a name="l10122"></a>10122                                 sm5 = sm4 * sm;
<a name="l10123"></a>10123                                 sm6 = sm5 * sm;
<a name="l10124"></a>10124                                 sm7 = sm6 * sm;
<a name="l10125"></a>10125                                 value = ic0 + ic1*sm + ic2*sm2 + ic3*sm3
<a name="l10126"></a>10126                                       + ic4*sm4 + ic5*sm5 + ic6*sm6 + ic7*sm7;
<a name="l10127"></a>10127                                 <span class="keywordflow">if</span> (value &gt; 1.0) {
<a name="l10128"></a>10128                                    value = 1.0;
<a name="l10129"></a>10129                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 0.0){
<a name="l10130"></a>10130                                    value = 0.0;
<a name="l10131"></a>10131                                 }
<a name="l10132"></a>10132                                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] *= value;
<a name="l10133"></a>10133                             }
<a name="l10134"></a>10134                         }
<a name="l10135"></a>10135 
<a name="l10136"></a>10136                         <span class="comment">/* ASSIGN A1CF */</span>
<a name="l10137"></a>10137                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l10138"></a>10138                             dist2 = dz2+dy2+VSQR(position[0]-(i+0.5)*hx);
<a name="l10139"></a>10139                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l10140"></a>10140                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] *= 1.0;
<a name="l10141"></a>10141                             }
<a name="l10142"></a>10142                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l10143"></a>10143                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] = 0.0;
<a name="l10144"></a>10144                             }
<a name="l10145"></a>10145                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l10146"></a>10146                                 dist = VSQRT(dist2);
<a name="l10147"></a>10147                                 sm = dist;
<a name="l10148"></a>10148                                 sm2 = VSQR(sm);
<a name="l10149"></a>10149                                 sm3 = sm2 * sm;
<a name="l10150"></a>10150                                 sm4 = sm3 * sm;
<a name="l10151"></a>10151                                 sm5 = sm4 * sm;
<a name="l10152"></a>10152                                 sm6 = sm5 * sm;
<a name="l10153"></a>10153                                 sm7 = sm6 * sm;
<a name="l10154"></a>10154                                 value = c0 + c1*sm + c2*sm2 + c3*sm3
<a name="l10155"></a>10155                                       + c4*sm4 + c5*sm5 + c6*sm6 + c7*sm7;
<a name="l10156"></a>10156                                 <span class="keywordflow">if</span> (value &gt; 1.0) {
<a name="l10157"></a>10157                                    value = 1.0;
<a name="l10158"></a>10158                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 0.0){
<a name="l10159"></a>10159                                    value = 0.0;
<a name="l10160"></a>10160                                 }
<a name="l10161"></a>10161                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] *= value;
<a name="l10162"></a>10162                             }
<a name="l10163"></a>10163                         }
<a name="l10164"></a>10164 
<a name="l10165"></a>10165                         <span class="comment">/* ASSIGN A2CF */</span>
<a name="l10166"></a>10166                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l10167"></a>10167                             dist2 = dz2+dx2+VSQR(position[1]-(j+0.5)*hy);
<a name="l10168"></a>10168                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l10169"></a>10169                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] *= 1.0;
<a name="l10170"></a>10170                             }
<a name="l10171"></a>10171                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l10172"></a>10172                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] = 0.0;
<a name="l10173"></a>10173                             }
<a name="l10174"></a>10174                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l10175"></a>10175                                 dist = VSQRT(dist2);
<a name="l10176"></a>10176                                 sm = dist;
<a name="l10177"></a>10177                                 sm2 = VSQR(sm);
<a name="l10178"></a>10178                                 sm3 = sm2 * sm;
<a name="l10179"></a>10179                                 sm4 = sm3 * sm;
<a name="l10180"></a>10180                                 sm5 = sm4 * sm;
<a name="l10181"></a>10181                                 sm6 = sm5 * sm;
<a name="l10182"></a>10182                                 sm7 = sm6 * sm;
<a name="l10183"></a>10183                                 value = c0 + c1*sm + c2*sm2 + c3*sm3
<a name="l10184"></a>10184                                       + c4*sm4 + c5*sm5 + c6*sm6 + c7*sm7;
<a name="l10185"></a>10185                                 <span class="keywordflow">if</span> (value &gt; 1.0) {
<a name="l10186"></a>10186                                    value = 1.0;
<a name="l10187"></a>10187                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 0.0){
<a name="l10188"></a>10188                                    value = 0.0;
<a name="l10189"></a>10189                                 }
<a name="l10190"></a>10190                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] *= value;
<a name="l10191"></a>10191                             }
<a name="l10192"></a>10192                         }
<a name="l10193"></a>10193 
<a name="l10194"></a>10194                         <span class="comment">/* ASSIGN A3CF */</span>
<a name="l10195"></a>10195                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l10196"></a>10196                             dist2 = dy2+dx2+VSQR(position[2]-(k+0.5)*hzed);
<a name="l10197"></a>10197                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l10198"></a>10198                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] *= 1.0;
<a name="l10199"></a>10199                             }
<a name="l10200"></a>10200                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l10201"></a>10201                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] = 0.0;
<a name="l10202"></a>10202                             }
<a name="l10203"></a>10203                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l10204"></a>10204                                 dist = VSQRT(dist2);
<a name="l10205"></a>10205                                 sm = dist;
<a name="l10206"></a>10206                                 sm2 = dist2;
<a name="l10207"></a>10207                                 sm3 = sm2 * sm;
<a name="l10208"></a>10208                                 sm4 = sm3 * sm;
<a name="l10209"></a>10209                                 sm5 = sm4 * sm;
<a name="l10210"></a>10210                                 sm6 = sm5 * sm;
<a name="l10211"></a>10211                                 sm7 = sm6 * sm;
<a name="l10212"></a>10212                                 value = c0 + c1*sm + c2*sm2 + c3*sm3
<a name="l10213"></a>10213                                       + c4*sm4 + c5*sm5 + c6*sm6 + c7*sm7;
<a name="l10214"></a>10214                                 <span class="keywordflow">if</span> (value &gt; 1.0) {
<a name="l10215"></a>10215                                    value = 1.0;
<a name="l10216"></a>10216                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 0.0){
<a name="l10217"></a>10217                                    value = 0.0;
<a name="l10218"></a>10218                                 }
<a name="l10219"></a>10219                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] *= value;
<a name="l10220"></a>10220                             }
<a name="l10221"></a>10221                         }
<a name="l10222"></a>10222 
<a name="l10223"></a>10223 
<a name="l10224"></a>10224                     } <span class="comment">/* k loop */</span>
<a name="l10225"></a>10225                 } <span class="comment">/* j loop */</span>
<a name="l10226"></a>10226             } <span class="comment">/* i loop */</span>
<a name="l10227"></a>10227         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l10228"></a>10228     } <span class="comment">/* endfor (over all atoms) */</span>
<a name="l10229"></a>10229 
<a name="l10230"></a>10230     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling coefficient arrays\n&quot;</span>);
<a name="l10231"></a>10231     <span class="comment">/* Interpret markings and fill the coefficient arrays */</span>
<a name="l10232"></a>10232     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l10233"></a>10233         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l10234"></a>10234             <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l10235"></a>10235 
<a name="l10236"></a>10236                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] = ionmask*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)];
<a name="l10237"></a>10237                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)]
<a name="l10238"></a>10238                   + epsp;
<a name="l10239"></a>10239                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)]
<a name="l10240"></a>10240                   + epsp;
<a name="l10241"></a>10241                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)]
<a name="l10242"></a>10242                   + epsp;
<a name="l10243"></a>10243 
<a name="l10244"></a>10244             } <span class="comment">/* i loop */</span>
<a name="l10245"></a>10245         } <span class="comment">/* j loop */</span>
<a name="l10246"></a>10246     } <span class="comment">/* k loop */</span>
<a name="l10247"></a>10247 
<a name="l10248"></a>10248 }
<a name="l10249"></a>10249 
<a name="l10250"></a>10250 VPUBLIC <span class="keywordtype">void</span> fillcoPermanentInduced(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l10251"></a>10251 
<a name="l10252"></a>10252     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l10253"></a>10253     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l10254"></a>10254     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l10255"></a>10255     <span class="comment">/* Coversions */</span>
<a name="l10256"></a>10256     <span class="keywordtype">double</span> zmagic, f;
<a name="l10257"></a>10257     <span class="comment">/* Grid */</span>
<a name="l10258"></a>10258     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax;
<a name="l10259"></a>10259     <span class="keywordtype">double</span> xlen, ylen, zlen, position[3], ifloat, jfloat, kfloat;
<a name="l10260"></a>10260     <span class="keywordtype">double</span> hx, hy, hzed, *apos;
<a name="l10261"></a>10261     <span class="comment">/* Multipole */</span>
<a name="l10262"></a>10262     <span class="keywordtype">double</span> charge, *dipole,*quad;
<a name="l10263"></a>10263     <span class="keywordtype">double</span> c,ux,uy,uz,qxx,qyx,qyy,qzx,qzy,qzz,qave;
<a name="l10264"></a>10264     <span class="comment">/* B-spline weights */</span>
<a name="l10265"></a>10265     <span class="keywordtype">double</span> mx,my,mz,dmx,dmy,dmz,d2mx,d2my,d2mz;
<a name="l10266"></a>10266     <span class="keywordtype">double</span> mi,mj,mk;
<a name="l10267"></a>10267     <span class="comment">/* Loop variables */</span>
<a name="l10268"></a>10268     <span class="keywordtype">int</span> i, ii, jj, kk, nx, ny, nz, iatom;
<a name="l10269"></a>10269     <span class="keywordtype">int</span> im2, im1, ip1, ip2, jm2, jm1, jp1, jp2, km2, km1, kp1, kp2;
<a name="l10270"></a>10270 
<a name="l10271"></a>10271     VASSERT(thee != VNULL);
<a name="l10272"></a>10272 
<a name="l10273"></a>10273     <span class="comment">/* Get PBE info */</span>
<a name="l10274"></a>10274     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l10275"></a>10275     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l10276"></a>10276     zmagic = <a class="code" href="group___vpbe.html#ga7fb9c15c98345dccc07853fec763de4e" title="Get charge scaling factor.">Vpbe_getZmagic</a>(pbe);
<a name="l10277"></a>10277 
<a name="l10278"></a>10278     <span class="comment">/* Mesh info */</span>
<a name="l10279"></a>10279     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l10280"></a>10280     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l10281"></a>10281     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l10282"></a>10282     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l10283"></a>10283     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l10284"></a>10284     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l10285"></a>10285 
<a name="l10286"></a>10286     <span class="comment">/* Conversion */</span>
<a name="l10287"></a>10287     f = zmagic/(hx*hy*hzed);
<a name="l10288"></a>10288 
<a name="l10289"></a>10289     <span class="comment">/* Define the total domain size */</span>
<a name="l10290"></a>10290     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l10291"></a>10291     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l10292"></a>10292     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l10293"></a>10293 
<a name="l10294"></a>10294     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l10295"></a>10295     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l10296"></a>10296     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l10297"></a>10297     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l10298"></a>10298     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l10299"></a>10299     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l10300"></a>10300     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l10301"></a>10301 
<a name="l10302"></a>10302     <span class="comment">/* Fill in the source term (permanent atomic multipoles</span>
<a name="l10303"></a>10303 <span class="comment">       and induced dipoles) */</span>
<a name="l10304"></a>10304     Vnm_print(0, <span class="stringliteral">&quot;fillcoPermanentInduced:  filling in source term.\n&quot;</span>);
<a name="l10305"></a>10305     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l10306"></a>10306 
<a name="l10307"></a>10307         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l10308"></a>10308         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l10309"></a>10309 
<a name="l10310"></a>10310         c = <a class="code" href="group___vatom.html#gad310786c8f4b295fea34c76b9c308ac5" title="Get atomic charge.">Vatom_getCharge</a>(atom)*f;
<a name="l10311"></a>10311 
<a name="l10312"></a>10312 <span class="preprocessor">#if defined(WITH_TINKER)</span>
<a name="l10313"></a>10313 <span class="preprocessor"></span>        dipole = Vatom_getDipole(atom);
<a name="l10314"></a>10314         ux = dipole[0]/hx*f;
<a name="l10315"></a>10315         uy = dipole[1]/hy*f;
<a name="l10316"></a>10316         uz = dipole[2]/hzed*f;
<a name="l10317"></a>10317         dipole = Vatom_getInducedDipole(atom);
<a name="l10318"></a>10318         ux = ux + dipole[0]/hx*f;
<a name="l10319"></a>10319         uy = uy + dipole[1]/hy*f;
<a name="l10320"></a>10320         uz = uz + dipole[2]/hzed*f;
<a name="l10321"></a>10321         quad = Vatom_getQuadrupole(atom);
<a name="l10322"></a>10322         qxx = (1.0/3.0)*quad[0]/(hx*hx)*f;
<a name="l10323"></a>10323         qyx = (2.0/3.0)*quad[3]/(hx*hy)*f;
<a name="l10324"></a>10324         qyy = (1.0/3.0)*quad[4]/(hy*hy)*f;
<a name="l10325"></a>10325         qzx = (2.0/3.0)*quad[6]/(hzed*hx)*f;
<a name="l10326"></a>10326         qzy = (2.0/3.0)*quad[7]/(hzed*hy)*f;
<a name="l10327"></a>10327         qzz = (1.0/3.0)*quad[8]/(hzed*hzed)*f;
<a name="l10328"></a>10328 <span class="preprocessor">#else</span>
<a name="l10329"></a>10329 <span class="preprocessor"></span>        ux = 0.0;
<a name="l10330"></a>10330         uy = 0.0;
<a name="l10331"></a>10331         uz = 0.0;
<a name="l10332"></a>10332         qxx = 0.0;
<a name="l10333"></a>10333         qyx = 0.0;
<a name="l10334"></a>10334         qyy = 0.0;
<a name="l10335"></a>10335         qzx = 0.0;
<a name="l10336"></a>10336         qzy = 0.0;
<a name="l10337"></a>10337         qzz = 0.0;
<a name="l10338"></a>10338 <span class="preprocessor">#endif </span><span class="comment">/* if defined(WITH_TINKER) */</span>
<a name="l10339"></a>10339 
<a name="l10340"></a>10340         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l10341"></a>10341         <span class="keywordflow">if</span> ((apos[0]&lt;=(xmin-2*hx)) || (apos[0]&gt;=(xmax+2*hx))  || \
<a name="l10342"></a>10342             (apos[1]&lt;=(ymin-2*hy)) || (apos[1]&gt;=(ymax+2*hy))  || \
<a name="l10343"></a>10343             (apos[2]&lt;=(zmin-2*hzed)) || (apos[2]&gt;=(zmax+2*hzed))) {
<a name="l10344"></a>10344             Vnm_print(2, <span class="stringliteral">&quot;fillcoPermanentMultipole: Atom #%d at (%4.3f, %4.3f, %4.3f) is off the mesh (ignoring this atom):\n&quot;</span>, iatom, apos[0], apos[1], apos[2]);
<a name="l10345"></a>10345             Vnm_print(2, <span class="stringliteral">&quot;fillcoPermanentMultipole: xmin = %g, xmax = %g\n&quot;</span>, xmin, xmax);
<a name="l10346"></a>10346             Vnm_print(2, <span class="stringliteral">&quot;fillcoPermanentMultipole: ymin = %g, ymax = %g\n&quot;</span>, ymin, ymax);
<a name="l10347"></a>10347             Vnm_print(2, <span class="stringliteral">&quot;fillcoPermanentMultipole: zmin = %g, zmax = %g\n&quot;</span>, zmin, zmax);
<a name="l10348"></a>10348             fflush(stderr);
<a name="l10349"></a>10349         } <span class="keywordflow">else</span> {
<a name="l10350"></a>10350 
<a name="l10351"></a>10351             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l10352"></a>10352             position[0] = apos[0] - xmin;
<a name="l10353"></a>10353             position[1] = apos[1] - ymin;
<a name="l10354"></a>10354             position[2] = apos[2] - zmin;
<a name="l10355"></a>10355 
<a name="l10356"></a>10356             <span class="comment">/* Figure out which vertices we&#39;re next to */</span>
<a name="l10357"></a>10357             ifloat = position[0]/hx;
<a name="l10358"></a>10358             jfloat = position[1]/hy;
<a name="l10359"></a>10359             kfloat = position[2]/hzed;
<a name="l10360"></a>10360 
<a name="l10361"></a>10361             ip1   = (int)ceil(ifloat);
<a name="l10362"></a>10362             ip2   = ip1 + 2;
<a name="l10363"></a>10363             im1   = (int)floor(ifloat);
<a name="l10364"></a>10364             im2   = im1 - 2;
<a name="l10365"></a>10365             jp1   = (int)ceil(jfloat);
<a name="l10366"></a>10366             jp2   = jp1 + 2;
<a name="l10367"></a>10367             jm1   = (int)floor(jfloat);
<a name="l10368"></a>10368             jm2   = jm1 - 2;
<a name="l10369"></a>10369             kp1   = (int)ceil(kfloat);
<a name="l10370"></a>10370             kp2   = kp1 + 2;
<a name="l10371"></a>10371             km1   = (int)floor(kfloat);
<a name="l10372"></a>10372             km2   = km1 - 2;
<a name="l10373"></a>10373 
<a name="l10374"></a>10374             <span class="comment">/* This step shouldn&#39;t be necessary, but it saves nasty debugging</span>
<a name="l10375"></a>10375 <span class="comment">             * later on if something goes wrong */</span>
<a name="l10376"></a>10376             ip2 = VMIN2(ip2,nx-1);
<a name="l10377"></a>10377             ip1 = VMIN2(ip1,nx-1);
<a name="l10378"></a>10378             im1 = VMAX2(im1,0);
<a name="l10379"></a>10379             im2 = VMAX2(im2,0);
<a name="l10380"></a>10380             jp2 = VMIN2(jp2,ny-1);
<a name="l10381"></a>10381             jp1 = VMIN2(jp1,ny-1);
<a name="l10382"></a>10382             jm1 = VMAX2(jm1,0);
<a name="l10383"></a>10383             jm2 = VMAX2(jm2,0);
<a name="l10384"></a>10384             kp2 = VMIN2(kp2,nz-1);
<a name="l10385"></a>10385             kp1 = VMIN2(kp1,nz-1);
<a name="l10386"></a>10386             km1 = VMAX2(km1,0);
<a name="l10387"></a>10387             km2 = VMAX2(km2,0);
<a name="l10388"></a>10388 
<a name="l10389"></a>10389             <span class="comment">/* Now assign fractions of the charge to the nearby verts */</span>
<a name="l10390"></a>10390             <span class="keywordflow">for</span> (ii=im2; ii&lt;=ip2; ii++) {
<a name="l10391"></a>10391                 mi = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(ii,ifloat);
<a name="l10392"></a>10392                 mx = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mi);
<a name="l10393"></a>10393                 dmx = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mi);
<a name="l10394"></a>10394                 d2mx = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mi);
<a name="l10395"></a>10395                 <span class="keywordflow">for</span> (jj=jm2; jj&lt;=jp2; jj++) {
<a name="l10396"></a>10396                     mj = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(jj,jfloat);
<a name="l10397"></a>10397                     my = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mj);
<a name="l10398"></a>10398                     dmy = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mj);
<a name="l10399"></a>10399                     d2my = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mj);
<a name="l10400"></a>10400                     <span class="keywordflow">for</span> (kk=km2; kk&lt;=kp2; kk++) {
<a name="l10401"></a>10401                         mk = <a class="code" href="vpmg_8c.html#afcf864c3b65f0d536a2985d931dc4692" title="Return 2.5 plus difference of i - f.">VFCHI4</a>(kk,kfloat);
<a name="l10402"></a>10402                         mz = <a class="code" href="vpmg_8c.html#ac953c7091df8e4a1df53463baf8fe7ee" title="Evaluate a 5th Order B-Spline (4th order polynomial)">bspline4</a>(mk);
<a name="l10403"></a>10403                         dmz = <a class="code" href="vpmg_8c.html#aaefa250362d354e032dd1d104cfea094" title="Evaluate a 5th Order B-Spline derivative (4th order polynomial)">dbspline4</a>(mk);
<a name="l10404"></a>10404                         d2mz = <a class="code" href="vpmg_8c.html#a9e0486c0940668c5db8b56f165c474b6" title="Evaluate the 2nd derivative of a 5th Order B-Spline.">d2bspline4</a>(mk);
<a name="l10405"></a>10405                         charge = mx*my*mz*c -
<a name="l10406"></a>10406                          dmx*my*mz*ux - mx*dmy*mz*uy - mx*my*dmz*uz +
<a name="l10407"></a>10407                          d2mx*my*mz*qxx +
<a name="l10408"></a>10408                          dmx*dmy*mz*qyx + mx*d2my*mz*qyy +
<a name="l10409"></a>10409                          dmx*my*dmz*qzx + mx*dmy*dmz*qzy + mx*my*d2mz*qzz;
<a name="l10410"></a>10410                         thee-&gt;<a class="code" href="structs_vpmg.html#af5fad380d5bd1cd089fe97ac1755838c">charge</a>[IJK(ii,jj,kk)] += charge;
<a name="l10411"></a>10411 
<a name="l10412"></a>10412                     }
<a name="l10413"></a>10413                 }
<a name="l10414"></a>10414             }
<a name="l10415"></a>10415         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l10416"></a>10416 
<a name="l10417"></a>10417     } <span class="comment">/* endfor (each atom) */</span>
<a name="l10418"></a>10418 }
<a name="l10419"></a>10419 
<a name="l10420"></a><a class="code" href="vpmg_8h.html#ab7b5543b591c9433e7190a2fe45b4ca2">10420</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="vpmg_8c.html#ab7b5543b591c9433e7190a2fe45b4ca2" title="Fill operator coefficient arrays from a 5th order polynomial based surface calculation.">fillcoCoefSpline3</a>(<a class="code" href="structs_vpmg.html" title="Contains public data members for Vpmg class/module.">Vpmg</a> *thee) {
<a name="l10421"></a>10421 
<a name="l10422"></a>10422     <a class="code" href="structs_valist.html" title="Container class for list of atom objects.">Valist</a> *alist;
<a name="l10423"></a>10423     <a class="code" href="structs_vpbe.html" title="Contains public data members for Vpbe class/module.">Vpbe</a> *<a class="code" href="structs_vopot.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l10424"></a>10424     <a class="code" href="structs_vatom.html" title="Contains public data members for Vatom class/module.">Vatom</a> *atom;
<a name="l10425"></a>10425     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax, zmin, zmax, ionmask, ionstr, dist2;
<a name="l10426"></a>10426     <span class="keywordtype">double</span> xlen, ylen, zlen, position[3], itot, stot, ictot, ictot2, sctot;
<a name="l10427"></a>10427     <span class="keywordtype">double</span> irad, dx, dy, dz, epsw, epsp, w2i;
<a name="l10428"></a>10428     <span class="keywordtype">double</span> hx, hy, hzed, *apos, arad, sctot2;
<a name="l10429"></a>10429     <span class="keywordtype">double</span> dx2, dy2, dz2, stot2, itot2, rtot, rtot2, splineWin;
<a name="l10430"></a>10430     <span class="keywordtype">double</span> dist, value, denom, sm, sm2, sm3, sm4, sm5;
<a name="l10431"></a>10431     <span class="keywordtype">double</span> e, e2, e3, e4, e5;
<a name="l10432"></a>10432     <span class="keywordtype">double</span> b, b2, b3, b4, b5;
<a name="l10433"></a>10433     <span class="keywordtype">double</span> c0, c1, c2, c3, c4, c5;
<a name="l10434"></a>10434     <span class="keywordtype">double</span> ic0, ic1, ic2, ic3, ic4, ic5;
<a name="l10435"></a>10435     <span class="keywordtype">int</span> i, j, k, nx, ny, nz, iatom;
<a name="l10436"></a>10436     <span class="keywordtype">int</span> imin, imax, jmin, jmax, kmin, kmax;
<a name="l10437"></a>10437 
<a name="l10438"></a>10438     VASSERT(thee != VNULL);
<a name="l10439"></a>10439     splineWin = thee-&gt;<a class="code" href="structs_vpmg.html#a34a451852a765e3e9d3e34f9866b7133">splineWin</a>;
<a name="l10440"></a>10440 
<a name="l10441"></a>10441     <span class="comment">/* Get PBE info */</span>
<a name="l10442"></a>10442     pbe = thee-&gt;<a class="code" href="structs_vpmg.html#a31a61d9da3a83d7c0328aaaffc6f9a8d">pbe</a>;
<a name="l10443"></a>10443     alist = pbe-&gt;<a class="code" href="structs_vpbe.html#ae0b1ff92bae2d15bb71adebfe53bbc17">alist</a>;
<a name="l10444"></a>10444     irad = <a class="code" href="group___vpbe.html#gabf77d3500a5e3b3c8673eab703bb53e0" title="Get maximum radius of ion species.">Vpbe_getMaxIonRadius</a>(pbe);
<a name="l10445"></a>10445     ionstr = <a class="code" href="group___vpbe.html#gabca9ea80c0a56d3848c54b37d0418f20" title="Get bulk ionic strength.">Vpbe_getBulkIonicStrength</a>(pbe);
<a name="l10446"></a>10446     epsw = <a class="code" href="group___vpbe.html#gaa27f724cd82148fd89335c405c3d80b5" title="Get solvent dielectric constant.">Vpbe_getSolventDiel</a>(pbe);
<a name="l10447"></a>10447     epsp = <a class="code" href="group___vpbe.html#ga54d318d98803a19fa5ea8b13fb73c7b0" title="Get solute dielectric constant.">Vpbe_getSoluteDiel</a>(pbe);
<a name="l10448"></a>10448 
<a name="l10449"></a>10449     <span class="comment">/* Mesh info */</span>
<a name="l10450"></a>10450     nx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a02d47a4f36ec0bcce348696534567e30">nx</a>;
<a name="l10451"></a>10451     ny = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9f4e20a91b26459133b83992e9d8d381">ny</a>;
<a name="l10452"></a>10452     nz = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac2eda98bb6d7e89cc3239973db2800cf">nz</a>;
<a name="l10453"></a>10453     hx = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a09cc6059a12cdba15210ace9262ba0d8">hx</a>;
<a name="l10454"></a>10454     hy = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a0a41827213e18b1a3078188354c5ebda">hy</a>;
<a name="l10455"></a>10455     hzed = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ae18e39ac2cd971370f4827f0f666a308">hzed</a>;
<a name="l10456"></a>10456 
<a name="l10457"></a>10457     <span class="comment">/* Define the total domain size */</span>
<a name="l10458"></a>10458     xlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a9ef23ea2587b7b978becada47514941e">xlen</a>;
<a name="l10459"></a>10459     ylen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#af6e5073e12867d9e39d9c098bb21ec1e">ylen</a>;
<a name="l10460"></a>10460     zlen = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ab8f801c48f0e20bbf7a0921ac4684f0e">zlen</a>;
<a name="l10461"></a>10461 
<a name="l10462"></a>10462     <span class="comment">/* Define the min/max dimensions */</span>
<a name="l10463"></a>10463     xmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> - (xlen/2.0);
<a name="l10464"></a>10464     ymin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> - (ylen/2.0);
<a name="l10465"></a>10465     zmin = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> - (zlen/2.0);
<a name="l10466"></a>10466     xmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a1fd8a9e50b513a92ce2ac6bb86fe671f">xcent</a> + (xlen/2.0);
<a name="l10467"></a>10467     ymax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ad088abbf1b005461a749e4e8821474f3">ycent</a> + (ylen/2.0);
<a name="l10468"></a>10468     zmax = thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#ac3ce9b451742fd0facf6d6dc05b6cb06">zcent</a> + (zlen/2.0);
<a name="l10469"></a>10469 
<a name="l10470"></a>10470     <span class="comment">/* This is a floating point parameter related to the non-zero nature of the</span>
<a name="l10471"></a>10471 <span class="comment">     * bulk ionic strength.  If the ionic strength is greater than zero; this</span>
<a name="l10472"></a>10472 <span class="comment">     * parameter is set to 1.0 and later scaled by the appropriate pre-factors.</span>
<a name="l10473"></a>10473 <span class="comment">     * Otherwise, this parameter is set to 0.0 */</span>
<a name="l10474"></a>10474     <span class="keywordflow">if</span> (ionstr &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) ionmask = 1.0;
<a name="l10475"></a>10475     <span class="keywordflow">else</span> ionmask = 0.0;
<a name="l10476"></a>10476 
<a name="l10477"></a>10477     <span class="comment">/* Reset the kappa, epsx, epsy, and epsz arrays */</span>
<a name="l10478"></a>10478     <span class="keywordflow">for</span> (i=0; i&lt;(nx*ny*nz); i++) {
<a name="l10479"></a>10479         thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[i] = 1.0;
<a name="l10480"></a>10480         thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[i] = 1.0;
<a name="l10481"></a>10481         thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[i] = 1.0;
<a name="l10482"></a>10482         thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[i] = 1.0;
<a name="l10483"></a>10483     }
<a name="l10484"></a>10484 
<a name="l10485"></a>10485     <span class="comment">/* Loop through the atoms and do assign the dielectric */</span>
<a name="l10486"></a>10486     <span class="keywordflow">for</span> (iatom=0; iatom&lt;<a class="code" href="group___valist.html#gaff55ce9b8624255736b0ccf62030f230" title="Get number of atoms in the list.">Valist_getNumberAtoms</a>(alist); iatom++) {
<a name="l10487"></a>10487 
<a name="l10488"></a>10488         atom = <a class="code" href="group___valist.html#gaf9175f6b6d2c33ad79bd525fc9e0e043" title="Get pointer to particular atom in list.">Valist_getAtom</a>(alist, iatom);
<a name="l10489"></a>10489         apos = <a class="code" href="group___vatom.html#ga282b06da5d33678cab1173a6fe5bc89c" title="Get atomic position.">Vatom_getPosition</a>(atom);
<a name="l10490"></a>10490         arad = <a class="code" href="group___vatom.html#ga9739f811224b6e7219cf6e21e0b4d9b4" title="Get atomic position.">Vatom_getRadius</a>(atom);
<a name="l10491"></a>10491 
<a name="l10492"></a>10492         b = arad - splineWin;
<a name="l10493"></a>10493         e = arad + splineWin;
<a name="l10494"></a>10494         e2 = e * e;
<a name="l10495"></a>10495         e3 = e2 * e;
<a name="l10496"></a>10496         e4 = e3 * e;
<a name="l10497"></a>10497         e5 = e4 * e;
<a name="l10498"></a>10498         b2 = b * b;
<a name="l10499"></a>10499         b3 = b2 * b;
<a name="l10500"></a>10500         b4 = b3 * b;
<a name="l10501"></a>10501         b5 = b4 * b;
<a name="l10502"></a>10502         denom = pow((e - b), 5.0);
<a name="l10503"></a>10503         c0 = -10.0*e2*b3 + 5.0*e*b4 - b5;
<a name="l10504"></a>10504         c1 = 30.0*e2*b2;
<a name="l10505"></a>10505         c2 = -30.0*(e2*b + e*b2);
<a name="l10506"></a>10506         c3 = 10.0*(e2 + 4.0*e*b + b2);
<a name="l10507"></a>10507         c4 = -15.0*(e + b);
<a name="l10508"></a>10508         c5 = 6;
<a name="l10509"></a>10509         c0 = c0/denom;
<a name="l10510"></a>10510         c1 = c1/denom;
<a name="l10511"></a>10511         c2 = c2/denom;
<a name="l10512"></a>10512         c3 = c3/denom;
<a name="l10513"></a>10513         c4 = c4/denom;
<a name="l10514"></a>10514         c5 = c5/denom;
<a name="l10515"></a>10515 
<a name="l10516"></a>10516         b = irad + arad - splineWin;
<a name="l10517"></a>10517         e = irad + arad + splineWin;
<a name="l10518"></a>10518         e2 = e * e;
<a name="l10519"></a>10519         e3 = e2 * e;
<a name="l10520"></a>10520         e4 = e3 * e;
<a name="l10521"></a>10521         e5 = e4 * e;
<a name="l10522"></a>10522         b2 = b * b;
<a name="l10523"></a>10523         b3 = b2 * b;
<a name="l10524"></a>10524         b4 = b3 * b;
<a name="l10525"></a>10525         b5 = b4 * b;
<a name="l10526"></a>10526         denom = pow((e - b), 5.0);
<a name="l10527"></a>10527         ic0 = -10.0*e2*b3 + 5.0*e*b4 - b5;
<a name="l10528"></a>10528         ic1 = 30.0*e2*b2;
<a name="l10529"></a>10529         ic2 = -30.0*(e2*b + e*b2);
<a name="l10530"></a>10530         ic3 = 10.0*(e2 + 4.0*e*b + b2);
<a name="l10531"></a>10531         ic4 = -15.0*(e + b);
<a name="l10532"></a>10532         ic5 = 6;
<a name="l10533"></a>10533         ic0 = c0/denom;
<a name="l10534"></a>10534         ic1 = c1/denom;
<a name="l10535"></a>10535         ic2 = c2/denom;
<a name="l10536"></a>10536         ic3 = c3/denom;
<a name="l10537"></a>10537         ic4 = c4/denom;
<a name="l10538"></a>10538         ic5 = c5/denom;
<a name="l10539"></a>10539 
<a name="l10540"></a>10540         <span class="comment">/* Make sure we&#39;re on the grid */</span>
<a name="l10541"></a>10541         <span class="keywordflow">if</span> ((apos[0]&lt;=xmin) || (apos[0]&gt;=xmax)  || \
<a name="l10542"></a>10542             (apos[1]&lt;=ymin) || (apos[1]&gt;=ymax)  || \
<a name="l10543"></a>10543             (apos[2]&lt;=zmin) || (apos[2]&gt;=zmax)) {
<a name="l10544"></a>10544             <span class="keywordflow">if</span> ((thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a072c52c1c2ec4be113a1be5db227ee50">BCFL_FOCUS</a>) &amp;&amp;
<a name="l10545"></a>10545                 (thee-&gt;<a class="code" href="structs_vpmg.html#a69de9f0c9aad00589d3fa06c257e438b">pmgp</a>-&gt;<a class="code" href="structs_vpmgp.html#a309c773e3e7c928a3e7a7e8e356d85a6">bcfl</a> != <a class="code" href="group___vhal.html#gga156281db9d201569da4620821ed24201a1dcaaa7c99a05f5540ef016b62267470">BCFL_MAP</a>)) {
<a name="l10546"></a>10546                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:  Atom #%d at (%4.3f, %4.3f,\</span>
<a name="l10547"></a>10547 <span class="stringliteral"> %4.3f) is off the mesh (ignoring):\n&quot;</span>,
<a name="l10548"></a>10548                   iatom, apos[0], apos[1], apos[2]);
<a name="l10549"></a>10549                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    xmin = %g, xmax = %g\n&quot;</span>,
<a name="l10550"></a>10550                   xmin, xmax);
<a name="l10551"></a>10551                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    ymin = %g, ymax = %g\n&quot;</span>,
<a name="l10552"></a>10552                   ymin, ymax);
<a name="l10553"></a>10553                 Vnm_print(2, <span class="stringliteral">&quot;Vpmg_fillco:    zmin = %g, zmax = %g\n&quot;</span>,
<a name="l10554"></a>10554                   zmin, zmax);
<a name="l10555"></a>10555             }
<a name="l10556"></a>10556             fflush(stderr);
<a name="l10557"></a>10557 
<a name="l10558"></a>10558         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arad &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a> ) { <span class="comment">/* if we&#39;re on the mesh */</span>
<a name="l10559"></a>10559 
<a name="l10560"></a>10560             <span class="comment">/* Convert the atom position to grid reference frame */</span>
<a name="l10561"></a>10561             position[0] = apos[0] - xmin;
<a name="l10562"></a>10562             position[1] = apos[1] - ymin;
<a name="l10563"></a>10563             position[2] = apos[2] - zmin;
<a name="l10564"></a>10564 
<a name="l10565"></a>10565             <span class="comment">/* MARK ION ACCESSIBILITY AND DIELECTRIC VALUES FOR LATER</span>
<a name="l10566"></a>10566 <span class="comment">             * ASSIGNMENT (Steps #1-3) */</span>
<a name="l10567"></a>10567             itot = irad + arad + splineWin;
<a name="l10568"></a>10568             itot2 = VSQR(itot);
<a name="l10569"></a>10569             ictot = VMAX2(0, (irad + arad - splineWin));
<a name="l10570"></a>10570             ictot2 = VSQR(ictot);
<a name="l10571"></a>10571             stot = arad + splineWin;
<a name="l10572"></a>10572             stot2 = VSQR(stot);
<a name="l10573"></a>10573             sctot = VMAX2(0, (arad - splineWin));
<a name="l10574"></a>10574             sctot2 = VSQR(sctot);
<a name="l10575"></a>10575 
<a name="l10576"></a>10576            <span class="comment">/* We&#39;ll search over grid points which are in the greater of</span>
<a name="l10577"></a>10577 <span class="comment">             * these two radii */</span>
<a name="l10578"></a>10578             rtot = VMAX2(itot, stot);
<a name="l10579"></a>10579             rtot2 = VMAX2(itot2, stot2);
<a name="l10580"></a>10580             dx = rtot + 0.5*hx;
<a name="l10581"></a>10581             dy = rtot + 0.5*hy;
<a name="l10582"></a>10582             dz = rtot + 0.5*hzed;
<a name="l10583"></a>10583             imin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[0] - dx)/hx));
<a name="l10584"></a>10584             imax = VMIN2(nx-1,(<span class="keywordtype">int</span>)ceil((position[0] + dx)/hx));
<a name="l10585"></a>10585             jmin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[1] - dy)/hy));
<a name="l10586"></a>10586             jmax = VMIN2(ny-1,(<span class="keywordtype">int</span>)ceil((position[1] + dy)/hy));
<a name="l10587"></a>10587             kmin = VMAX2(0,(<span class="keywordtype">int</span>)floor((position[2] - dz)/hzed));
<a name="l10588"></a>10588             kmax = VMIN2(nz-1,(<span class="keywordtype">int</span>)ceil((position[2] + dz)/hzed));
<a name="l10589"></a>10589             <span class="keywordflow">for</span> (i=imin; i&lt;=imax; i++) {
<a name="l10590"></a>10590                 dx2 = VSQR(position[0] - hx*i);
<a name="l10591"></a>10591                 <span class="keywordflow">for</span> (j=jmin; j&lt;=jmax; j++) {
<a name="l10592"></a>10592                     dy2 = VSQR(position[1] - hy*j);
<a name="l10593"></a>10593                     <span class="keywordflow">for</span> (k=kmin; k&lt;=kmax; k++) {
<a name="l10594"></a>10594                         dz2 = VSQR(position[2] - k*hzed);
<a name="l10595"></a>10595 
<a name="l10596"></a>10596                         <span class="comment">/* ASSIGN CCF */</span>
<a name="l10597"></a>10597                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l10598"></a>10598                             dist2 = dz2 + dy2 + dx2;
<a name="l10599"></a>10599                             <span class="keywordflow">if</span> (dist2 &gt;= itot2) {
<a name="l10600"></a>10600                                 ;
<a name="l10601"></a>10601                             }
<a name="l10602"></a>10602                             <span class="keywordflow">if</span> (dist2 &lt;= ictot2) {
<a name="l10603"></a>10603                                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] = 0.0;
<a name="l10604"></a>10604                             }
<a name="l10605"></a>10605                             <span class="keywordflow">if</span> ((dist2 &lt; itot2) &amp;&amp; (dist2 &gt; ictot2)) {
<a name="l10606"></a>10606                                 dist = VSQRT(dist2);
<a name="l10607"></a>10607                                 sm = dist;
<a name="l10608"></a>10608                                 sm2 = dist2;
<a name="l10609"></a>10609                                 sm3 = sm2 * sm;
<a name="l10610"></a>10610                                 sm4 = sm3 * sm;
<a name="l10611"></a>10611                                 sm5 = sm4 * sm;
<a name="l10612"></a>10612                                 value = ic0 + ic1*sm + ic2*sm2 + ic3*sm3
<a name="l10613"></a>10613                                       + ic4*sm4 + ic5*sm5;
<a name="l10614"></a>10614                                 <span class="keywordflow">if</span> (value &gt; 1.0) {
<a name="l10615"></a>10615                                    value = 1.0;
<a name="l10616"></a>10616                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 0.0){
<a name="l10617"></a>10617                                    value = 0.0;
<a name="l10618"></a>10618                                 }
<a name="l10619"></a>10619                                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] *= value;
<a name="l10620"></a>10620                             }
<a name="l10621"></a>10621                         }
<a name="l10622"></a>10622 
<a name="l10623"></a>10623                         <span class="comment">/* ASSIGN A1CF */</span>
<a name="l10624"></a>10624                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l10625"></a>10625                             dist2 = dz2+dy2+VSQR(position[0]-(i+0.5)*hx);
<a name="l10626"></a>10626                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l10627"></a>10627                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] *= 1.0;
<a name="l10628"></a>10628                             }
<a name="l10629"></a>10629                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l10630"></a>10630                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] = 0.0;
<a name="l10631"></a>10631                             }
<a name="l10632"></a>10632                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l10633"></a>10633                                 dist = VSQRT(dist2);
<a name="l10634"></a>10634                                 sm = dist;
<a name="l10635"></a>10635                                 sm2 = VSQR(sm);
<a name="l10636"></a>10636                                 sm3 = sm2 * sm;
<a name="l10637"></a>10637                                 sm4 = sm3 * sm;
<a name="l10638"></a>10638                                 sm5 = sm4 * sm;
<a name="l10639"></a>10639                                 value = c0 + c1*sm + c2*sm2 + c3*sm3
<a name="l10640"></a>10640                                       + c4*sm4 + c5*sm5;
<a name="l10641"></a>10641                                 <span class="keywordflow">if</span> (value &gt; 1.0) {
<a name="l10642"></a>10642                                    value = 1.0;
<a name="l10643"></a>10643                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 0.0){
<a name="l10644"></a>10644                                    value = 0.0;
<a name="l10645"></a>10645                                 }
<a name="l10646"></a>10646                                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] *= value;
<a name="l10647"></a>10647                             }
<a name="l10648"></a>10648                         }
<a name="l10649"></a>10649 
<a name="l10650"></a>10650                         <span class="comment">/* ASSIGN A2CF */</span>
<a name="l10651"></a>10651                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l10652"></a>10652                             dist2 = dz2+dx2+VSQR(position[1]-(j+0.5)*hy);
<a name="l10653"></a>10653                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l10654"></a>10654                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] *= 1.0;
<a name="l10655"></a>10655                             }
<a name="l10656"></a>10656                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l10657"></a>10657                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] = 0.0;
<a name="l10658"></a>10658                             }
<a name="l10659"></a>10659                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l10660"></a>10660                                 dist = VSQRT(dist2);
<a name="l10661"></a>10661                                 sm = dist;
<a name="l10662"></a>10662                                 sm2 = VSQR(sm);
<a name="l10663"></a>10663                                 sm3 = sm2 * sm;
<a name="l10664"></a>10664                                 sm4 = sm3 * sm;
<a name="l10665"></a>10665                                 sm5 = sm4 * sm;
<a name="l10666"></a>10666                                 value = c0 + c1*sm + c2*sm2 + c3*sm3
<a name="l10667"></a>10667                                       + c4*sm4 + c5*sm5;
<a name="l10668"></a>10668                                 <span class="keywordflow">if</span> (value &gt; 1.0) {
<a name="l10669"></a>10669                                    value = 1.0;
<a name="l10670"></a>10670                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 0.0){
<a name="l10671"></a>10671                                    value = 0.0;
<a name="l10672"></a>10672                                 }
<a name="l10673"></a>10673                                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] *= value;
<a name="l10674"></a>10674                             }
<a name="l10675"></a>10675                         }
<a name="l10676"></a>10676 
<a name="l10677"></a>10677                         <span class="comment">/* ASSIGN A3CF */</span>
<a name="l10678"></a>10678                         <span class="keywordflow">if</span> (thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] &gt; <a class="code" href="group___vhal.html#gae6cbe2adcbb8e0ffafaa5780a677bdb7" title="A small number used in Vpmg to decide if points are on/off grid-lines or non-zer0 (etc...">VPMGSMALL</a>) {
<a name="l10679"></a>10679                             dist2 = dy2+dx2+VSQR(position[2]-(k+0.5)*hzed);
<a name="l10680"></a>10680                             <span class="keywordflow">if</span> (dist2 &gt;= stot2) {
<a name="l10681"></a>10681                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] *= 1.0;
<a name="l10682"></a>10682                             }
<a name="l10683"></a>10683                             <span class="keywordflow">if</span> (dist2 &lt;= sctot2) {
<a name="l10684"></a>10684                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] = 0.0;
<a name="l10685"></a>10685                             }
<a name="l10686"></a>10686                             <span class="keywordflow">if</span> ((dist2 &gt; sctot2) &amp;&amp; (dist2 &lt; stot2)) {
<a name="l10687"></a>10687                                 dist = VSQRT(dist2);
<a name="l10688"></a>10688                                 sm = dist;
<a name="l10689"></a>10689                                 sm2 = dist2;
<a name="l10690"></a>10690                                 sm3 = sm2 * sm;
<a name="l10691"></a>10691                                 sm4 = sm3 * sm;
<a name="l10692"></a>10692                                 sm5 = sm4 * sm;
<a name="l10693"></a>10693                                 value = c0 + c1*sm + c2*sm2 + c3*sm3
<a name="l10694"></a>10694                                       + c4*sm4 + c5*sm5;
<a name="l10695"></a>10695                                 <span class="keywordflow">if</span> (value &gt; 1.0) {
<a name="l10696"></a>10696                                    value = 1.0;
<a name="l10697"></a>10697                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; 0.0){
<a name="l10698"></a>10698                                    value = 0.0;
<a name="l10699"></a>10699                                 }
<a name="l10700"></a>10700                                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] *= value;
<a name="l10701"></a>10701                             }
<a name="l10702"></a>10702                         }
<a name="l10703"></a>10703 
<a name="l10704"></a>10704 
<a name="l10705"></a>10705                     } <span class="comment">/* k loop */</span>
<a name="l10706"></a>10706                 } <span class="comment">/* j loop */</span>
<a name="l10707"></a>10707             } <span class="comment">/* i loop */</span>
<a name="l10708"></a>10708         } <span class="comment">/* endif (on the mesh) */</span>
<a name="l10709"></a>10709     } <span class="comment">/* endfor (over all atoms) */</span>
<a name="l10710"></a>10710 
<a name="l10711"></a>10711     Vnm_print(0, <span class="stringliteral">&quot;Vpmg_fillco:  filling coefficient arrays\n&quot;</span>);
<a name="l10712"></a>10712     <span class="comment">/* Interpret markings and fill the coefficient arrays */</span>
<a name="l10713"></a>10713     <span class="keywordflow">for</span> (k=0; k&lt;nz; k++) {
<a name="l10714"></a>10714         <span class="keywordflow">for</span> (j=0; j&lt;ny; j++) {
<a name="l10715"></a>10715             <span class="keywordflow">for</span> (i=0; i&lt;nx; i++) {
<a name="l10716"></a>10716 
<a name="l10717"></a>10717                 thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)] = ionmask*thee-&gt;<a class="code" href="structs_vpmg.html#ac6b30598dfa3fffe97620639ad0e12ff">kappa</a>[IJK(i,j,k)];
<a name="l10718"></a>10718                 thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#ab1394ee327288f1cf2ffe7fee2cbda6e">epsx</a>[IJK(i,j,k)]
<a name="l10719"></a>10719                   + epsp;
<a name="l10720"></a>10720                 thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#ae5834bc24c1a0be3744992ef0409b2e0">epsy</a>[IJK(i,j,k)]
<a name="l10721"></a>10721                   + epsp;
<a name="l10722"></a>10722                 thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)] = (epsw-epsp)*thee-&gt;<a class="code" href="structs_vpmg.html#a3457423c2a7fdb7830cad479de3b2b9e">epsz</a>[IJK(i,j,k)]
<a name="l10723"></a>10723                   + epsp;
<a name="l10724"></a>10724 
<a name="l10725"></a>10725             } <span class="comment">/* i loop */</span>
<a name="l10726"></a>10726         } <span class="comment">/* j loop */</span>
<a name="l10727"></a>10727     } <span class="comment">/* k loop */</span>
<a name="l10728"></a>10728 
<a name="l10729"></a>10729 }
<a name="l10730"></a>10730 
<a name="l10731"></a><a class="code" href="group___vpmg.html#ga60b35ab9ae779ffa7329589f64a4111e">10731</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga60b35ab9ae779ffa7329589f64a4111e" title="Build a column-compressed matrix in Harwell-Boeing format.">bcolcomp</a>(<span class="keywordtype">int</span> *iparm, <span class="keywordtype">double</span> *rparm, <span class="keywordtype">int</span> *iwork, <span class="keywordtype">double</span> *rwork,
<a name="l10732"></a>10732         <span class="keywordtype">double</span> *values, <span class="keywordtype">int</span> *rowind, <span class="keywordtype">int</span> *colptr, <span class="keywordtype">int</span> *flag) {
<a name="l10733"></a>10733     <span class="keywordtype">int</span> nrow, ncol, nnzero, i;
<a name="l10734"></a>10734     <span class="keywordtype">int</span> nxc, nyc, nzc, nf, nc, narr, narrc, n_rpc;
<a name="l10735"></a>10735     <span class="keywordtype">int</span> n_iz, n_ipc, iretot, iintot;
<a name="l10736"></a>10736     <span class="keywordtype">int</span> nrwk, niwk, nx, ny, nz, nlev, ierror, maxlev, mxlv;
<a name="l10737"></a>10737     <span class="keywordtype">int</span> mgcoar, mgdisc, mgsolv;
<a name="l10738"></a>10738     <span class="keywordtype">int</span> k_iz;
<a name="l10739"></a>10739     <span class="keywordtype">int</span> k_ipc, k_rpc, k_ac, k_cc, k_fc, k_pc;
<a name="l10740"></a>10740 
<a name="l10741"></a>10741     WARN_UNTESTED;
<a name="l10742"></a>10742 
<a name="l10743"></a>10743     <span class="comment">// Decode some parameters</span>
<a name="l10744"></a>10744     nrwk = VAT(iparm, 1);
<a name="l10745"></a>10745     niwk = VAT(iparm, 2);
<a name="l10746"></a>10746     nx   = VAT(iparm, 3);
<a name="l10747"></a>10747     ny   = VAT(iparm, 4);
<a name="l10748"></a>10748     nz   = VAT(iparm, 5);
<a name="l10749"></a>10749     nlev = VAT(iparm, 6);
<a name="l10750"></a>10750 
<a name="l10751"></a>10751     <span class="comment">// Some checks on input</span>
<a name="l10752"></a>10752     mxlv = Vmaxlev(nx, ny, nz);
<a name="l10753"></a>10753 
<a name="l10754"></a>10754     <span class="comment">// Basic grid sizes, etc.</span>
<a name="l10755"></a>10755     mgcoar = VAT(iparm, 18);
<a name="l10756"></a>10756     mgdisc = VAT(iparm, 19);
<a name="l10757"></a>10757     mgsolv = VAT(iparm, 21);
<a name="l10758"></a>10758     <a class="code" href="group___p_m_g_c.html#ga9d22f2b899f947ef541bb735f8f5de3d" title="This routine computes the required sizes of the real and integer work arrays for the multigrid code...">Vmgsz</a>(&amp;mgcoar, &amp;mgdisc, &amp;mgsolv,
<a name="l10759"></a>10759             &amp;nx, &amp;ny, &amp;nz,
<a name="l10760"></a>10760             &amp;nlev,
<a name="l10761"></a>10761             &amp;nxc, &amp;nyc, &amp;nzc,
<a name="l10762"></a>10762             &amp;nf, &amp;nc,
<a name="l10763"></a>10763             &amp;narr, &amp;narrc,
<a name="l10764"></a>10764             &amp;n_rpc, &amp;n_iz, &amp;n_ipc,
<a name="l10765"></a>10765             &amp;iretot, &amp;iintot);
<a name="l10766"></a>10766 
<a name="l10767"></a>10767     <span class="comment">// Split up the integer work array</span>
<a name="l10768"></a>10768     k_iz  = 1;
<a name="l10769"></a>10769     k_ipc = k_iz + n_iz;
<a name="l10770"></a>10770 
<a name="l10771"></a>10771     <span class="comment">// Split up the real work array</span>
<a name="l10772"></a>10772     k_rpc = 1;
<a name="l10773"></a>10773     k_cc  = k_rpc + n_rpc;
<a name="l10774"></a>10774     k_fc  = k_cc  + narr;
<a name="l10775"></a>10775     k_pc  = k_fc  + narr;
<a name="l10776"></a>10776     k_ac  = k_pc  + 27*narrc;
<a name="l10777"></a>10777 
<a name="l10778"></a>10778     <a class="code" href="group___vpmg.html#gab5bd1e304d44f0a7721da2181d809f61" title="Build a column-compressed matrix in Harwell-Boeing format.">bcolcomp2</a>(iparm, rparm,
<a name="l10779"></a>10779             &amp;nx, &amp;ny, &amp;nz, RAT(iwork, k_iz),
<a name="l10780"></a>10780             RAT(iwork, k_ipc), RAT(rwork, k_rpc),
<a name="l10781"></a>10781             RAT(rwork, k_ac), RAT(rwork, k_cc),
<a name="l10782"></a>10782             values, rowind, colptr, flag);
<a name="l10783"></a>10783 }
<a name="l10784"></a>10784 
<a name="l10785"></a><a class="code" href="group___vpmg.html#gab5bd1e304d44f0a7721da2181d809f61">10785</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gab5bd1e304d44f0a7721da2181d809f61" title="Build a column-compressed matrix in Harwell-Boeing format.">bcolcomp2</a>(<span class="keywordtype">int</span> *iparm, <span class="keywordtype">double</span> *rparm,
<a name="l10786"></a>10786         <span class="keywordtype">int</span> *nx, <span class="keywordtype">int</span> *ny, <span class="keywordtype">int</span> *nz,
<a name="l10787"></a>10787         <span class="keywordtype">int</span> *iz, <span class="keywordtype">int</span> *ipc, <span class="keywordtype">double</span> *rpc,
<a name="l10788"></a>10788         <span class="keywordtype">double</span> *ac, <span class="keywordtype">double</span> *cc, <span class="keywordtype">double</span> *values,
<a name="l10789"></a>10789         <span class="keywordtype">int</span> *rowind, <span class="keywordtype">int</span> *colptr, <span class="keywordtype">int</span> *flag) {
<a name="l10790"></a>10790 
<a name="l10791"></a>10791     <span class="keywordtype">int</span> nlev = 1;
<a name="l10792"></a>10792     <span class="keywordtype">int</span> lev = VAT(iparm, 6);
<a name="l10793"></a>10793 
<a name="l10794"></a>10794     MAT2(iz, 50, nlev);
<a name="l10795"></a>10795 
<a name="l10796"></a>10796     WARN_UNTESTED;
<a name="l10797"></a>10797 
<a name="l10798"></a>10798     <span class="comment">/*</span>
<a name="l10799"></a>10799 <span class="comment">     * Build the multigrid data structure in iz</span>
<a name="l10800"></a>10800 <span class="comment">     *    THIS MAY HAVE BEEN DONE ALREADY, BUT IT&#39;S OK TO DO IT AGAIN,</span>
<a name="l10801"></a>10801 <span class="comment">     *    RIGHT?</span>
<a name="l10802"></a>10802 <span class="comment">     *    call buildstr (nx,ny,nz,nlev,iz)</span>
<a name="l10803"></a>10803 <span class="comment">     *</span>
<a name="l10804"></a>10804 <span class="comment">     *    We&#39;re interested in the finest level</span>
<a name="l10805"></a>10805 <span class="comment">     */</span>
<a name="l10806"></a>10806     <a class="code" href="group___vpmg.html#gac5fa6f2c37f8a78d0f213cf84abcf8d7" title="Build a column-compressed matrix in Harwell-Boeing format.">bcolcomp3</a>(nx, ny, nz,
<a name="l10807"></a>10807             RAT(ipc, VAT2(iz, 5, lev)), RAT(rpc, VAT2(iz, 6, lev)),
<a name="l10808"></a>10808             RAT(ac, VAT2(iz, 7, lev)), RAT(cc, VAT2(iz, 1, lev)),
<a name="l10809"></a>10809             values, rowind, colptr, flag);
<a name="l10810"></a>10810 }
<a name="l10811"></a>10811 
<a name="l10812"></a>10812 <span class="comment">/**************************************************************************</span>
<a name="l10813"></a>10813 <span class="comment"> * Routine:  bcolcomp3</span>
<a name="l10814"></a>10814 <span class="comment"> * Purpose:  Build a column-compressed matrix in Harwell-Boeing format</span>
<a name="l10815"></a>10815 <span class="comment"> * Args:     flag   0 ==&gt; Use Poisson operator only</span>
<a name="l10816"></a>10816 <span class="comment"> *                  1 ==&gt; Use linearization of full operator around current</span>
<a name="l10817"></a>10817 <span class="comment"> *                        solution</span>
<a name="l10818"></a>10818 <span class="comment"> * Author:   Nathan Baker (mostly ripped off from Harwell-Boeing format</span>
<a name="l10819"></a>10819 <span class="comment"> *           documentation)</span>
<a name="l10820"></a>10820 <span class="comment"> **************************************************************************/</span>
<a name="l10821"></a><a class="code" href="group___vpmg.html#gac5fa6f2c37f8a78d0f213cf84abcf8d7">10821</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gac5fa6f2c37f8a78d0f213cf84abcf8d7" title="Build a column-compressed matrix in Harwell-Boeing format.">bcolcomp3</a>(<span class="keywordtype">int</span> *nx, <span class="keywordtype">int</span> *ny, <span class="keywordtype">int</span> *nz,
<a name="l10822"></a>10822         <span class="keywordtype">int</span> *ipc, <span class="keywordtype">double</span> *rpc,
<a name="l10823"></a>10823         <span class="keywordtype">double</span> *ac, <span class="keywordtype">double</span> *cc,
<a name="l10824"></a>10824         <span class="keywordtype">double</span> *values, <span class="keywordtype">int</span> *rowind, <span class="keywordtype">int</span> *colptr, <span class="keywordtype">int</span> *flag) {
<a name="l10825"></a>10825 
<a name="l10826"></a>10826     MAT2(ac, *nx * *ny * *nz, 1);
<a name="l10827"></a>10827 
<a name="l10828"></a>10828     WARN_UNTESTED;
<a name="l10829"></a>10829 
<a name="l10830"></a>10830     <a class="code" href="group___vpmg.html#gab2403b9193313b36ec9fa9603e6a8833" title="Build a column-compressed matrix in Harwell-Boeing format.">bcolcomp4</a>(nx, ny, nz,
<a name="l10831"></a>10831             ipc, rpc,
<a name="l10832"></a>10832             RAT2(ac, 1, 1), cc,
<a name="l10833"></a>10833             RAT2(ac, 1, 2), RAT2(ac, 1, 3), RAT2(ac, 1, 4),
<a name="l10834"></a>10834             values, rowind, colptr, flag);
<a name="l10835"></a>10835 }
<a name="l10836"></a>10836 
<a name="l10837"></a>10837 
<a name="l10838"></a>10838 
<a name="l10839"></a>10839 <span class="comment">/**************************************************************************</span>
<a name="l10840"></a>10840 <span class="comment"> * Routine:  bcolcomp4</span>
<a name="l10841"></a>10841 <span class="comment"> * Purpose:  Build a column-compressed matrix in Harwell-Boeing format</span>
<a name="l10842"></a>10842 <span class="comment"> * Args:     flag   0 ==&gt; Use Poisson operator only</span>
<a name="l10843"></a>10843 <span class="comment"> *                  1 ==&gt; Use linearization of full operator around current</span>
<a name="l10844"></a>10844 <span class="comment"> *                        solution</span>
<a name="l10845"></a>10845 <span class="comment"> * Author:   Nathan Baker (mostly ripped off from Harwell-Boeing format</span>
<a name="l10846"></a>10846 <span class="comment"> *           documentation)</span>
<a name="l10847"></a>10847 <span class="comment"> **************************************************************************/</span>
<a name="l10848"></a><a class="code" href="group___vpmg.html#gab2403b9193313b36ec9fa9603e6a8833">10848</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#gab2403b9193313b36ec9fa9603e6a8833" title="Build a column-compressed matrix in Harwell-Boeing format.">bcolcomp4</a>(<span class="keywordtype">int</span> *nx, <span class="keywordtype">int</span> *ny, <span class="keywordtype">int</span> *nz,
<a name="l10849"></a>10849         <span class="keywordtype">int</span> *ipc, <span class="keywordtype">double</span> *rpc,
<a name="l10850"></a>10850         <span class="keywordtype">double</span> *oC, <span class="keywordtype">double</span> *cc, <span class="keywordtype">double</span> *oE, <span class="keywordtype">double</span> *oN, <span class="keywordtype">double</span> *uC,
<a name="l10851"></a>10851         <span class="keywordtype">double</span> *values, <span class="keywordtype">int</span> *rowind, <span class="keywordtype">int</span> *colptr, <span class="keywordtype">int</span> *flag) {
<a name="l10852"></a>10852 
<a name="l10853"></a>10853     <span class="keywordtype">int</span> nxm2, nym2, nzm2;
<a name="l10854"></a>10854     <span class="keywordtype">int</span> ii, jj, kk, ll;
<a name="l10855"></a>10855     <span class="keywordtype">int</span>  i,  j,  k,  l;
<a name="l10856"></a>10856     <span class="keywordtype">int</span> inonz, iirow, nn, nrow, ncol, nonz, irow, n;
<a name="l10857"></a>10857 
<a name="l10858"></a>10858     <span class="keywordtype">int</span> doit;
<a name="l10859"></a>10859 
<a name="l10860"></a>10860     MAT3(oE, *nx, *ny, *nz);
<a name="l10861"></a>10861     MAT3(oN, *nx, *ny, *nz);
<a name="l10862"></a>10862     MAT3(uC, *nx, *ny, *nz);
<a name="l10863"></a>10863     MAT3(cc, *nx, *ny, *nz);
<a name="l10864"></a>10864     MAT3(oC, *nx, *ny, *nz);
<a name="l10865"></a>10865 
<a name="l10866"></a>10866     WARN_UNTESTED;
<a name="l10867"></a>10867 
<a name="l10868"></a>10868     <span class="comment">// Get some column, row, and nonzero information</span>
<a name="l10869"></a>10869     n = *nx * *ny * *nz;
<a name="l10870"></a>10870     nxm2 = *nx - 2;
<a name="l10871"></a>10871     nym2 = *ny - 2;
<a name="l10872"></a>10872     nzm2 = *nz - 2;
<a name="l10873"></a>10873     nn   = nxm2 * nym2 * nzm2;
<a name="l10874"></a>10874     ncol = nn;
<a name="l10875"></a>10875     nrow = nn;
<a name="l10876"></a>10876     nonz = 7 * nn - 2 * nxm2 * nym2 - 2 * nxm2 - 2;
<a name="l10877"></a>10877 
<a name="l10878"></a>10878     <span class="comment">// Intialize some pointers</span>
<a name="l10879"></a>10879     inonz = 1;
<a name="l10880"></a>10880 
<a name="l10881"></a>10881     <span class="comment">/*</span>
<a name="l10882"></a>10882 <span class="comment">     * Run over the dimensions of the matrix (non-zero only in the interior</span>
<a name="l10883"></a>10883 <span class="comment">     * of the mesh</span>
<a name="l10884"></a>10884 <span class="comment">     */</span>
<a name="l10885"></a>10885     <span class="keywordflow">for</span> (k=2; k&lt;=*nz-1; k++) {
<a name="l10886"></a>10886         <span class="comment">// Offset the index to the output grid index</span>
<a name="l10887"></a>10887         kk = k - 1;
<a name="l10888"></a>10888 
<a name="l10889"></a>10889         <span class="keywordflow">for</span> (j=2; j&lt;=*ny-1; j++) {
<a name="l10890"></a>10890             <span class="comment">// Offset the index to the output grid index</span>
<a name="l10891"></a>10891             jj = j - 1;
<a name="l10892"></a>10892 
<a name="l10893"></a>10893             <span class="keywordflow">for</span> (i=2; i&lt;=*nx-1; i++) {
<a name="l10894"></a>10894                 <span class="comment">// Offset the index to the output grid index</span>
<a name="l10895"></a>10895                 ii = i - 1;
<a name="l10896"></a>10896 
<a name="l10897"></a>10897                 <span class="comment">// Get the output (i,j,k) row number in natural ordering</span>
<a name="l10898"></a>10898                 ll = (kk - 1) * nxm2 * nym2 + (jj - 1) * nxm2 + (ii - 1) + 1;
<a name="l10899"></a>10899                 l  = (k  - 1) * *nx  * *ny  + (j  - 1) * *nx  + (i  - 1) + 1;
<a name="l10900"></a>10900 
<a name="l10901"></a>10901                 <span class="comment">// Store where this column starts</span>
<a name="l10902"></a>10902                 VAT(colptr,ll) = inonz;
<a name="l10903"></a>10903 
<a name="l10904"></a>10904                 <span class="comment">// SUB-DIAGONAL 3</span>
<a name="l10905"></a>10905                 iirow = ll - nxm2 * nym2;
<a name="l10906"></a>10906                 irow  =  l - *nx  * *ny;
<a name="l10907"></a>10907 
<a name="l10908"></a>10908                 doit = (iirow &gt;= 1) &amp;&amp; (iirow &lt;= nn);
<a name="l10909"></a>10909                 doit = doit &amp;&amp; (irow &gt;= 1) &amp;&amp; (irow &lt;= n);
<a name="l10910"></a>10910 
<a name="l10911"></a>10911                 <span class="keywordflow">if</span> (doit) {
<a name="l10912"></a>10912                     VAT(values, inonz) = -VAT3(uC, i, j, k-1);
<a name="l10913"></a>10913                     VAT(rowind, inonz) = iirow;
<a name="l10914"></a>10914                     inonz++;
<a name="l10915"></a>10915                 }
<a name="l10916"></a>10916 
<a name="l10917"></a>10917 
<a name="l10918"></a>10918 
<a name="l10919"></a>10919                 <span class="comment">// SUB-DIAGONAL 2</span>
<a name="l10920"></a>10920                 iirow = ll - nxm2;
<a name="l10921"></a>10921                 irow  =  l - *nx;
<a name="l10922"></a>10922 
<a name="l10923"></a>10923                 doit = (iirow &gt;= 1) &amp;&amp; (iirow &lt;= nn);
<a name="l10924"></a>10924                 doit = doit &amp;&amp; (irow &gt;= 1) &amp;&amp; (irow &lt;= n);
<a name="l10925"></a>10925 
<a name="l10926"></a>10926                 <span class="keywordflow">if</span> (doit) {
<a name="l10927"></a>10927                     VAT(values, inonz) = -VAT3(oN, i, j-1, k);
<a name="l10928"></a>10928                     VAT(rowind, inonz) = iirow;
<a name="l10929"></a>10929                     inonz++;
<a name="l10930"></a>10930                 }
<a name="l10931"></a>10931 
<a name="l10932"></a>10932 
<a name="l10933"></a>10933 
<a name="l10934"></a>10934                 <span class="comment">// SUB-DIAGONAL 1</span>
<a name="l10935"></a>10935                 iirow = ll - 1;
<a name="l10936"></a>10936                 irow =   l - 1;
<a name="l10937"></a>10937 
<a name="l10938"></a>10938                 doit = (iirow &gt;= 1) &amp;&amp; (iirow &lt;= nn);
<a name="l10939"></a>10939                 doit = doit &amp;&amp; (irow &lt;= 1) &amp;&amp; (irow &lt;= n);
<a name="l10940"></a>10940                 <span class="keywordflow">if</span> (doit) {
<a name="l10941"></a>10941                     VAT(values, inonz) = -VAT3(oE, i-1, j, k);
<a name="l10942"></a>10942                     VAT(rowind, inonz) = iirow;
<a name="l10943"></a>10943                     inonz++;
<a name="l10944"></a>10944                 }
<a name="l10945"></a>10945 
<a name="l10946"></a>10946 
<a name="l10947"></a>10947 
<a name="l10948"></a>10948                 <span class="comment">// DIAGONAL</span>
<a name="l10949"></a>10949                 iirow = ll;
<a name="l10950"></a>10950                 irow  =  l;
<a name="l10951"></a>10951 
<a name="l10952"></a>10952                 <span class="keywordflow">if</span> (*flag == 0) {
<a name="l10953"></a>10953                     VAT(values, inonz) = VAT3(oC, i, j, k);
<a name="l10954"></a>10954                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*flag == 1) {
<a name="l10955"></a>10955                     VAT(values, inonz) = VAT3(oC, i, j, k)
<a name="l10956"></a>10956                                        + VAT3(cc, i, j, k);
<a name="l10957"></a>10957                 } <span class="keywordflow">else</span> {
<a name="l10958"></a>10958                     VABORT_MSG0(<span class="stringliteral">&quot;PMGF1&quot;</span>);
<a name="l10959"></a>10959                 }
<a name="l10960"></a>10960 
<a name="l10961"></a>10961                 VAT(rowind, inonz) = iirow;
<a name="l10962"></a>10962                 inonz++;
<a name="l10963"></a>10963 
<a name="l10964"></a>10964                 <span class="comment">// SUPER-DIAGONAL 1</span>
<a name="l10965"></a>10965                 iirow = ll + 1;
<a name="l10966"></a>10966                 irow  =  l + 1;
<a name="l10967"></a>10967                 doit = (iirow &gt;= 1) &amp;&amp; (iirow &lt;= nn);
<a name="l10968"></a>10968                 doit = doit &amp;&amp; (irow &gt;= 1) &amp;&amp; (irow &lt;= n);
<a name="l10969"></a>10969                 <span class="keywordflow">if</span> (doit) {
<a name="l10970"></a>10970                     VAT(values, inonz) = -VAT3(oE, i, j, k);
<a name="l10971"></a>10971                     VAT(rowind, inonz) = iirow;
<a name="l10972"></a>10972                     inonz++;
<a name="l10973"></a>10973                 }
<a name="l10974"></a>10974 
<a name="l10975"></a>10975 
<a name="l10976"></a>10976 
<a name="l10977"></a>10977                 <span class="comment">// SUPER-DIAGONAL 2</span>
<a name="l10978"></a>10978                 iirow = ll + nxm2;
<a name="l10979"></a>10979                 irow  =  l + *nx;
<a name="l10980"></a>10980                 doit = (iirow &gt;= 1) &amp;&amp; (iirow &lt;= nn);
<a name="l10981"></a>10981                 doit = doit &amp;&amp; (irow &gt;= 1) &amp;&amp; (irow &lt;= n);
<a name="l10982"></a>10982                 <span class="keywordflow">if</span> (doit) {
<a name="l10983"></a>10983                     VAT(values, inonz) = -VAT3(oN, i, j, k);
<a name="l10984"></a>10984                     VAT(rowind, inonz) = iirow;
<a name="l10985"></a>10985                     inonz++;
<a name="l10986"></a>10986                 }
<a name="l10987"></a>10987 
<a name="l10988"></a>10988 
<a name="l10989"></a>10989 
<a name="l10990"></a>10990                 <span class="comment">// SUPER-DIAGONAL 3</span>
<a name="l10991"></a>10991                 iirow = ll + nxm2 * nym2;
<a name="l10992"></a>10992                 irow  =  l + *nx  * *ny;
<a name="l10993"></a>10993                 doit = (iirow &gt;= 1) &amp;&amp; (iirow &lt;= nn);
<a name="l10994"></a>10994                 doit = doit &amp;&amp; (irow &gt;= 1) &amp;&amp; (irow &lt;= n);
<a name="l10995"></a>10995                 <span class="keywordflow">if</span> (doit) {
<a name="l10996"></a>10996                     VAT(values, inonz) = -VAT3(uC, i, j, k);
<a name="l10997"></a>10997                     VAT(rowind, inonz) = iirow;
<a name="l10998"></a>10998                     inonz++;
<a name="l10999"></a>10999                 }
<a name="l11000"></a>11000             }
<a name="l11001"></a>11001         }
<a name="l11002"></a>11002     }
<a name="l11003"></a>11003 
<a name="l11004"></a>11004     VAT(colptr, ncol + 1) = inonz;
<a name="l11005"></a>11005 
<a name="l11006"></a>11006     <span class="keywordflow">if</span> (inonz != (nonz + 1)) {
<a name="l11007"></a>11007         VABORT_MSG2(<span class="stringliteral">&quot;BCOLCOMP4:  ERROR -- INONZ = %d, NONZ = %d&quot;</span>, inonz, nonz);
<a name="l11008"></a>11008     }
<a name="l11009"></a>11009 }
<a name="l11010"></a>11010 
<a name="l11011"></a>11011 
<a name="l11012"></a>11012 
<a name="l11013"></a><a class="code" href="group___vpmg.html#ga08fc3acae8bd36d0ff7c463f3d68988f">11013</a> VPRIVATE <span class="keywordtype">void</span> <a class="code" href="group___vpmg.html#ga08fc3acae8bd36d0ff7c463f3d68988f" title="Print a column-compressed matrix in Harwell-Boeing format.">pcolcomp</a>(<span class="keywordtype">int</span> *nrow, <span class="keywordtype">int</span> *ncol, <span class="keywordtype">int</span> *nnzero,
<a name="l11014"></a>11014         <span class="keywordtype">double</span> *values, <span class="keywordtype">int</span> *rowind, <span class="keywordtype">int</span> *colptr,
<a name="l11015"></a>11015         <span class="keywordtype">char</span> *path, <span class="keywordtype">char</span> *title, <span class="keywordtype">char</span> *mxtype) {
<a name="l11016"></a>11016 
<a name="l11017"></a>11017     <span class="keywordtype">char</span> key[] = <span class="stringliteral">&quot;key&quot;</span>;
<a name="l11018"></a>11018     <span class="keywordtype">char</span> ptrfmt[] = <span class="stringliteral">&quot;(10I8)&quot;</span>;
<a name="l11019"></a>11019     <span class="keywordtype">char</span> indfmt[] = <span class="stringliteral">&quot;(10I8)&quot;</span>;
<a name="l11020"></a>11020     <span class="keywordtype">char</span> valfmt[] = <span class="stringliteral">&quot;(5E15.8)&quot;</span>;
<a name="l11021"></a>11021     <span class="keywordtype">char</span> rhsfmt[] = <span class="stringliteral">&quot;(5E15.8)&quot;</span>;
<a name="l11022"></a>11022 
<a name="l11023"></a>11023     <span class="keywordtype">int</span> i, totcrd, ptrcrd, indcrd, valcrd, neltvl, rhscrd;
<a name="l11024"></a>11024 
<a name="l11025"></a>11025     FILE *outFile;
<a name="l11026"></a>11026 
<a name="l11027"></a>11027     WARN_UNTESTED;
<a name="l11028"></a>11028 
<a name="l11029"></a>11029     <span class="comment">// Open the file for reading</span>
<a name="l11030"></a>11030     outFile = fopen(path, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l11031"></a>11031 
<a name="l11032"></a>11032     <span class="comment">// Set some default values</span>
<a name="l11033"></a>11033     ptrcrd = (int)(*ncol   / 10 + 1) - 1;
<a name="l11034"></a>11034     indcrd = (int)(*nnzero / 10 + 1) - 1;
<a name="l11035"></a>11035     valcrd = (int)(*nnzero / 10 + 1) - 1;
<a name="l11036"></a>11036     totcrd = ptrcrd + indcrd + valcrd;
<a name="l11037"></a>11037     rhscrd = 0;
<a name="l11038"></a>11038     neltvl = 0;
<a name="l11039"></a>11039 
<a name="l11040"></a>11040     <span class="comment">// Print the header</span>
<a name="l11041"></a>11041     fprintf(outFile, <span class="stringliteral">&quot;%72s%8s\n&quot;</span>,
<a name="l11042"></a>11042             title, key);
<a name="l11043"></a>11043     fprintf(outFile, <span class="stringliteral">&quot;%14d%14d%14d%14d%14d\n&quot;</span>,
<a name="l11044"></a>11044             totcrd, ptrcrd, indcrd, valcrd, rhscrd);
<a name="l11045"></a>11045     fprintf(outFile, <span class="stringliteral">&quot;%3s\n&quot;</span>, mxtype);
<a name="l11046"></a>11046     fprintf(outFile, <span class="stringliteral">&quot;           %14d%14d%14d%14d\n&quot;</span>,
<a name="l11047"></a>11047             *nrow, *ncol, *nnzero, neltvl);
<a name="l11048"></a>11048     fprintf(outFile, <span class="stringliteral">&quot;%16s%16s%20s%20s\n&quot;</span>,
<a name="l11049"></a>11049             ptrfmt, indfmt, valfmt, rhsfmt);
<a name="l11050"></a>11050 
<a name="l11051"></a>11051     <span class="comment">// Write the matrix structure</span>
<a name="l11052"></a>11052     <span class="keywordflow">for</span> (i=1; i&lt;=*ncol+1; i++)
<a name="l11053"></a>11053         fprintf(outFile, <span class="stringliteral">&quot;%8d&quot;</span>, VAT(colptr, i));
<a name="l11054"></a>11054     fprintf(outFile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l11055"></a>11055 
<a name="l11056"></a>11056     <span class="keywordflow">for</span> (i=1; i&lt;=*nnzero; i++)
<a name="l11057"></a>11057         fprintf(outFile, <span class="stringliteral">&quot;%8d&quot;</span>, VAT(rowind, i));
<a name="l11058"></a>11058     fprintf(outFile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l11059"></a>11059 
<a name="l11060"></a>11060     <span class="comment">// Write out the values</span>
<a name="l11061"></a>11061     <span class="keywordflow">if</span> (valcrd &gt; 0) {
<a name="l11062"></a>11062         <span class="keywordflow">for</span> (i=1; i&lt;=*nnzero; i++)
<a name="l11063"></a>11063             fprintf(outFile, <span class="stringliteral">&quot;%15.8e&quot;</span>, VAT(values, i));
<a name="l11064"></a>11064         fprintf(outFile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l11065"></a>11065     }
<a name="l11066"></a>11066 
<a name="l11067"></a>11067     <span class="comment">// Close the file</span>
<a name="l11068"></a>11068     fclose (outFile);
<a name="l11069"></a>11069 }
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="vpmg_8c.html">vpmg.c</a>      </li>

    <li class="footer">Generated on Wed Oct 17 2012 22:45:59 for APBS by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
